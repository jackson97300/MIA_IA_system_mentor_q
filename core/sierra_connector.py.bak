#!/usr/bin/env python3
"""
MIA_IA_SYSTEM - Sierra Chart Connector
ðŸ“¡ CONNECTEUR SIERRA CHART DTC PROTOCOL
Version: Production Ready
Performance: <30ms latency, protocole DTC natif, backup IBKR

RESPONSABILITÃ‰S CRITIQUES :
1. ðŸ”— PROTOCOLE DTC - Data and Trading Communications protocol Sierra Chart
2. ðŸ“Š STREAMING DATA - Market data temps rÃ©el, historical data access
3. ðŸ’¹ ORDER ROUTING - Trade execution via Sierra Chart gateway
4. ðŸ“ˆ BACKUP SYSTEM - Fallback principal si IBKR indisponible
5. ðŸ”„ SOCKET MANAGEMENT - TCP persistent connections, reconnection auto
6. ðŸ“‹ DTC MESSAGE HANDLING - Encoding/decoding messages binaires

INTÃ‰GRATION SYSTÃˆME :
- Backup primaire pour IBKR dans market_data_feed.py
- Compatible avec tous les types base_types.py
- Interface identique Ã  IBKRConnector pour seamless switching
- AccÃ¨s data feed Sierra Chart + order routing

PROTOCOLE DTC :
- Messages binaires TCP socket
- Authentication et session management
- Market data subscription/streaming
- Order placement et status tracking
- Heartbeat et keepalive automatique

WORKFLOW PRINCIPAL :
Connection â†’ DTC Auth â†’ Market Data Stream â†’ Order Management â†’ Monitoring
"""

import socket
import struct
import threading
import time
import queue
import json
import logging
from typing import Dict, List, Optional, Any, Callable, Union, Tuple
from dataclasses import dataclass, field
from enum import Enum, IntEnum
from datetime import datetime, timezone, timedelta
from collections import defaultdict, deque
import pandas as pd
import numpy as np

# Local imports
from .base_types import (
    MarketData, OrderFlowData, TradingSignal, TradeResult,
    ES_TICK_SIZE, ES_TICK_VALUE, SignalType, MarketRegime
)

logger = logging.getLogger(__name__)

# === SIERRA CHART DTC ENUMS ===

class SierraConnectionStatus(Enum):
    """Statuts de connexion Sierra Chart"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    AUTHENTICATED = "authenticated"
    READY = "ready"
    ERROR = "error"
    RECONNECTING = "reconnecting"

class DTCMessageType(IntEnum):
    """Types de messages DTC Protocol"""
    # Connection
    LOGON_REQUEST = 1
    LOGON_RESPONSE = 2
    HEARTBEAT = 3
    LOGOFF = 5
    
    # Market Data
    MARKET_DATA_REQUEST = 101
    MARKET_DATA_REJECT = 103
    MARKET_DATA_SNAPSHOT = 104
    MARKET_DATA_UPDATE_TRADE = 107
    MARKET_DATA_UPDATE_BID_ASK = 108
    
    # Historical Data
    HISTORICAL_PRICE_DATA_REQUEST = 114
    HISTORICAL_PRICE_DATA_RESPONSE_HEADER = 115
    HISTORICAL_PRICE_DATA_RECORD_RESPONSE = 116
    
    # Orders
    SUBMIT_NEW_SINGLE_ORDER = 208
    ORDER_UPDATE = 209
    OPEN_ORDERS_REQUEST = 218
    OPEN_ORDERS_RESPONSE = 219
    CANCEL_ORDER = 203

class SierraOrderStatus(Enum):
    """Statuts d'ordre Sierra Chart"""
    PENDING = "pending"
    SUBMITTED = "submitted"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"
    PARTIALLY_FILLED = "partially_filled"

class SierraDataType(Enum):
    """Types de donnÃ©es Sierra Chart"""
    REAL_TIME = "real_time"
    HISTORICAL = "historical" 
    DELAYED = "delayed"

# === DTC PROTOCOL STRUCTURES ===

@dataclass
class DTCMessage:
    """Message DTC gÃ©nÃ©rique"""
    message_type: int
    message_size: int
    data: bytes = b''

@dataclass
class SierraContract:
    """Contrat Sierra Chart"""
    symbol: str
    exchange: str = "CME"
    security_type: str = "Future"
    currency: str = "USD"
    
    def to_symbol_id(self) -> str:
        """Conversion vers symbol ID Sierra Chart"""
        return f"{self.symbol}.{self.exchange}"

@dataclass
class SierraTick:
    """Tick Sierra Chart"""
    timestamp: datetime
    symbol: str
    tick_type: str
    price: Optional[float] = None
    volume: Optional[int] = None
    bid_price: Optional[float] = None
    ask_price: Optional[float] = None
    bid_size: Optional[int] = None
    ask_size: Optional[int] = None

@dataclass
class SierraOrder:
    """Ordre Sierra Chart"""
    order_id: str
    symbol: str
    action: str  # BUY, SELL
    quantity: int
    order_type: str  # Market, Limit, Stop
    price: Optional[float] = None
    stop_price: Optional[float] = None
    status: SierraOrderStatus = SierraOrderStatus.PENDING
    filled_quantity: int = 0
    avg_fill_price: float = 0.0
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))

# === DTC MESSAGE BUILDERS ===

class DTCMessageBuilder:
    """Builder pour messages DTC"""
    
    @staticmethod
    def build_logon_request(username: str = "", password: str = "", 
                          client_name: str = "MIA_IA_SYSTEM") -> bytes:
        """Construction message LOGON_REQUEST"""
        try:
            # Message structure pour logon
            message_type = DTCMessageType.LOGON_REQUEST
            
            # Build message data (simplified DTC format)
            client_name_bytes = client_name.encode('utf-8')[:60].ljust(60, b'\x00')
            username_bytes = username.encode('utf-8')[:32].ljust(32, b'\x00')
            password_bytes = password.encode('utf-8')[:32].ljust(32, b'\x00')
            
            # DTC Header + Data
            message_data = struct.pack(
                '<H',  # Protocol version
                8
            ) + client_name_bytes + username_bytes + password_bytes
            
            message_size = len(message_data) + 4  # +4 for header
            
            # DTC Message header
            header = struct.pack('<HH', message_size, message_type)
            
            return header + message_data
            
        except Exception as e:
            logger.error(f"Erreur build logon request: {e}")
            return b''
    
    @staticmethod
    def build_market_data_request(symbol: str, request_action: int = 1) -> bytes:
        """Construction MARKET_DATA_REQUEST"""
        try:
            message_type = DTCMessageType.MARKET_DATA_REQUEST
            
            # Symbol encoding
            symbol_bytes = symbol.encode('utf-8')[:64].ljust(64, b'\x00')
            
            # Message data
            message_data = struct.pack(
                '<B',  # Request action (1=subscribe, 2=unsubscribe)
                request_action
            ) + symbol_bytes
            
            message_size = len(message_data) + 4
            header = struct.pack('<HH', message_size, message_type)
            
            return header + message_data
            
        except Exception as e:
            logger.error(f"Erreur build market data request: {e}")
            return b''
    
    @staticmethod
    def build_heartbeat() -> bytes:
        """Construction HEARTBEAT"""
        try:
            message_type = DTCMessageType.HEARTBEAT
            message_size = 4  # Header only
            
            return struct.pack('<HH', message_size, message_type)
            
        except Exception as e:
            logger.error(f"Erreur build heartbeat: {e}")
            return b''
    
    @staticmethod
    def build_submit_order(order: SierraOrder) -> bytes:
        """Construction SUBMIT_NEW_SINGLE_ORDER"""
        try:
            message_type = DTCMessageType.SUBMIT_NEW_SINGLE_ORDER
            
            # Symbol encoding
            symbol_bytes = order.symbol.encode('utf-8')[:64].ljust(64, b'\x00')
            order_id_bytes = order.order_id.encode('utf-8')[:32].ljust(32, b'\x00')
            
            # Order type mapping
            order_type_code = 1  # Market
            if order.order_type.upper() == "LIMIT":
                order_type_code = 2
            elif order.order_type.upper() == "STOP":
                order_type_code = 3
            
            # Buy/Sell mapping
            buy_sell = 1 if order.action.upper() == "BUY" else 2
            
            # Message data
            message_data = (
                symbol_bytes +
                order_id_bytes +
                struct.pack('<BBL', buy_sell, order_type_code, order.quantity)
            )
            
            # Add price fields if needed
            if order.price:
                message_data += struct.pack('<d', order.price)
            else:
                message_data += struct.pack('<d', 0.0)
            
            if order.stop_price:
                message_data += struct.pack('<d', order.stop_price)
            else:
                message_data += struct.pack('<d', 0.0)
            
            message_size = len(message_data) + 4
            header = struct.pack('<HH', message_size, message_type)
            
            return header + message_data
            
        except Exception as e:
            logger.error(f"Erreur build submit order: {e}")
            return b''

# === DTC MESSAGE PARSER ===

class DTCMessageParser:
    """Parser pour messages DTC reÃ§us"""
    
    @staticmethod
    def parse_header(data: bytes) -> Optional[DTCMessage]:
        """Parse header DTC"""
        try:
            if len(data) < 4:
                return None
            
            message_size, message_type = struct.unpack('<HH', data[:4])
            
            return DTCMessage(
                message_type=message_type,
                message_size=message_size,
                data=data[4:] if len(data) > 4 else b''
            )
            
        except Exception as e:
            logger.error(f"Erreur parse header: {e}")
            return None
    
    @staticmethod
    def parse_logon_response(data: bytes) -> Dict[str, Any]:
        """Parse LOGON_RESPONSE"""
        try:
            if len(data) < 4:
                return {'success': False, 'reason': 'Invalid response'}
            
            result, protocol_version = struct.unpack('<HH', data[:4])
            
            return {
                'success': result == 1,
                'protocol_version': protocol_version,
                'reason': 'Login successful' if result == 1 else 'Login failed'
            }
            
        except Exception as e:
            logger.error(f"Erreur parse logon response: {e}")
            return {'success': False, 'reason': str(e)}
    
    @staticmethod
    def parse_market_data_update(data: bytes) -> Optional[SierraTick]:
        """Parse MARKET_DATA_UPDATE"""
        try:
            if len(data) < 80:  # Minimum data size
                return None
            
            # Extract symbol (first 64 bytes)
            symbol_bytes = data[:64]
            symbol = symbol_bytes.rstrip(b'\x00').decode('utf-8')
            
            # Extract price and volume (simplified)
            offset = 64
            if len(data) >= offset + 16:
                price, volume = struct.unpack('<dL', data[offset:offset+12])
                
                return SierraTick(
                    timestamp=datetime.now(timezone.utc),
                    symbol=symbol,
                    tick_type="TRADE",
                    price=price,
                    volume=volume
                )
            
            return None
            
        except Exception as e:
            logger.error(f"Erreur parse market data update: {e}")
            return None

# === MAIN SIERRA CHART CONNECTOR ===

class SierraConnector:
    """
    CONNECTEUR SIERRA CHART MASTER
    
    ResponsabilitÃ©s :
    1. Connexion DTC protocol Sierra Chart
    2. Streaming market data temps rÃ©el
    3. Order execution et management
    4. Backup system pour IBKR
    5. Socket management robuste
    6. Interface standardisÃ©e systÃ¨me
    """
    
    def __init__(self, config: Optional[Dict] = None):
        """Initialisation connecteur Sierra Chart"""
        self.config = config or {}
        
        # Configuration connexion
        self.host = self.config.get('sierra_host', '127.0.0.1')
        self.port = self.config.get('sierra_port', 11099)  # Default DTC port
        self.username = self.config.get('sierra_username', '')
        self.password = self.config.get('sierra_password', '')
        self.client_name = self.config.get('sierra_client_name', 'MIA_IA_SYSTEM')
        
        # Ã‰tat connexion
        self.connection_status = SierraConnectionStatus.DISCONNECTED
        self.is_connected = False
        self.is_authenticated = False
        self.socket: Optional[socket.socket] = None
        self.last_connection_attempt = None
        self.reconnection_attempts = 0
        self.max_reconnection_attempts = 5
        
        # Data management
        self.contracts: Dict[str, SierraContract] = {}
        self.tick_buffer: queue.Queue = queue.Queue(maxsize=10000)
        self.market_data_cache: Dict[str, MarketData] = {}
        self.orders: Dict[str, SierraOrder] = {}
        self.next_order_id = 1
        
        # Message handling
        self.message_builder = DTCMessageBuilder()
        self.message_parser = DTCMessageParser()
        self.message_buffer = b''
        
        # Subscribers
        self.subscribers: Dict[str, Callable[[MarketData], None]] = {}
        self.tick_subscribers: Dict[str, Callable[[SierraTick], None]] = {}
        
        # Threading
        self.receive_thread: Optional[threading.Thread] = None
        self.processing_thread: Optional[threading.Thread] = None
        self.heartbeat_thread: Optional[threading.Thread] = None
        self.is_running = False
        
        # Statistics
        self.stats = {
            'ticks_received': 0,
            'orders_placed': 0,
            'orders_filled': 0,
            'messages_sent': 0,
            'messages_received': 0,
            'connection_uptime': 0,
            'last_heartbeat': datetime.now(timezone.utc)
        }
        
        logger.info(f"SierraConnector initialisÃ©: {self.host}:{self.port}")
    
    # === CONNECTION MANAGEMENT ===
    
    def connect(self) -> bool:
        """
        CONNEXION SIERRA CHART
        
        Ã‰tablit connexion DTC et authentification
        """
        try:
            logger.info(f"Connexion Sierra Chart: {self.host}:{self.port}")
            self.connection_status = SierraConnectionStatus.CONNECTING
            self.last_connection_attempt = datetime.now(timezone.utc)
            
            # CrÃ©ation socket TCP
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.settimeout(30)  # 30s timeout
            
            # Connexion
            self.socket.connect((self.host, self.port))
            self.connection_status = SierraConnectionStatus.CONNECTED
            self.is_connected = True
            
            logger.info("âœ… Socket Sierra Chart connectÃ©")
            
            # DÃ©marrage thread rÃ©ception
            self._start_receive_thread()
            
            # Authentification DTC
            if self._authenticate():
                self.connection_status = SierraConnectionStatus.AUTHENTICATED
                self.is_authenticated = True
                
                # DÃ©marrage threads processing
                self._start_processing_threads()
                
                # Initialisation contrats
                self._initialize_contracts()
                
                self.connection_status = SierraConnectionStatus.READY
                self.reconnection_attempts = 0
                
                logger.info("âœ… Connexion Sierra Chart authentifiÃ©e et prÃªte")
                return True
            
            else:
                logger.error("âŒ Ã‰chec authentification Sierra Chart")
                self.disconnect()
                return False
                
        except Exception as e:
            logger.error(f"Erreur connexion Sierra Chart: {e}")
            self.connection_status = SierraConnectionStatus.ERROR
            self.disconnect()
            return False
    
    def _authenticate(self) -> bool:
        """Authentification DTC"""
        try:
            # Envoi LOGON_REQUEST
            logon_message = self.message_builder.build_logon_request(
                username=self.username,
                password=self.password,
                client_name=self.client_name
            )
            
            if not self._send_message(logon_message):
                return False
            
            # Attendre LOGON_RESPONSE
            start_time = time.time()
            timeout = 10  # 10s timeout
            
            while time.time() - start_time < timeout:
                if self.is_authenticated:
                    return True
                time.sleep(0.1)
            
            logger.error("Timeout authentification Sierra Chart")
            return False
            
        except Exception as e:
            logger.error(f"Erreur authentification: {e}")
            return False
    
    def disconnect(self):
        """DÃ©connexion propre"""
        try:
            logger.info("DÃ©connexion Sierra Chart...")
            
            self.is_running = False
            self.is_connected = False
            self.is_authenticated = False
            self.connection_status = SierraConnectionStatus.DISCONNECTED
            
            # ArrÃªt threads
            self._stop_threads()
            
            # Fermeture socket
            if self.socket:
                try:
                    # Envoi LOGOFF si possible
                    logoff_message = struct.pack('<HH', 4, DTCMessageType.LOGOFF)
                    self.socket.send(logoff_message)
                except:
                    pass
                
                self.socket.close()
                self.socket = None
            
            logger.info("âœ… DÃ©connexion Sierra Chart terminÃ©e")
            
        except Exception as e:
            logger.error(f"Erreur dÃ©connexion: {e}")
    
    def _start_receive_thread(self):
        """DÃ©marrage thread rÃ©ception messages"""
        try:
            self.is_running = True
            
            self.receive_thread = threading.Thread(
                target=self._receive_loop,
                daemon=True,
                name="SierraReceive"
            )
            self.receive_thread.start()
            
        except Exception as e:
            logger.error(f"Erreur start receive thread: {e}")
    
    def _start_processing_threads(self):
        """DÃ©marrage threads processing"""
        try:
            # Thread processing ticks
            self.processing_thread = threading.Thread(
                target=self._processing_loop,
                daemon=True,
                name="SierraProcessing"
            )
            self.processing_thread.start()
            
            # Thread heartbeat
            self.heartbeat_thread = threading.Thread(
                target=self._heartbeat_loop,
                daemon=True,
                name="SierraHeartbeat"
            )
            self.heartbeat_thread.start()
            
            logger.info("âœ… Threads Sierra Chart dÃ©marrÃ©s")
            
        except Exception as e:
            logger.error(f"Erreur start processing threads: {e}")
    
    def _stop_threads(self):
        """ArrÃªt tous threads"""
        try:
            # Wait for threads to finish
            threads = [self.receive_thread, self.processing_thread, self.heartbeat_thread]
            
            for thread in threads:
                if thread and thread.is_alive():
                    thread.join(timeout=5)
            
        except Exception as e:
            logger.error(f"Erreur stop threads: {e}")
    
    # === MESSAGE HANDLING ===
    
    def _send_message(self, message: bytes) -> bool:
        """Envoi message DTC"""
        try:
            if not self.socket or not self.is_connected:
                return False
            
            self.socket.send(message)
            self.stats['messages_sent'] += 1
            
            return True
            
        except Exception as e:
            logger.error(f"Erreur send message: {e}")
            return False
    
    def _receive_loop(self):
        """Loop rÃ©ception messages DTC"""
        logger.info("ðŸ“¡ Sierra receive loop dÃ©marrÃ©")
        
        while self.is_running and self.socket:
            try:
                # RÃ©ception donnÃ©es
                data = self.socket.recv(4096)
                
                if not data:
                    logger.warning("Connexion Sierra Chart fermÃ©e par serveur")
                    break
                
                # Ajout au buffer
                self.message_buffer += data
                
                # Traitement messages complets
                self._process_message_buffer()
                
            except socket.timeout:
                continue
            except Exception as e:
                logger.error(f"Erreur receive loop: {e}")
                break
        
        logger.info("ðŸ“¡ Sierra receive loop terminÃ©")
    
    def _process_message_buffer(self):
        """Traitement buffer messages"""
        try:
            while len(self.message_buffer) >= 4:
                # Parse header
                message_size, message_type = struct.unpack('<HH', self.message_buffer[:4])
                
                # VÃ©rifier message complet
                if len(self.message_buffer) < message_size:
                    break
                
                # Extraire message
                message_data = self.message_buffer[4:message_size]
                self.message_buffer = self.message_buffer[message_size:]
                
                # Traitement message
                self._handle_message(message_type, message_data)
                self.stats['messages_received'] += 1
                
        except Exception as e:
            logger.error(f"Erreur process message buffer: {e}")
    
    def _handle_message(self, message_type: int, data: bytes):
        """Traitement message DTC individuel"""
        try:
            if message_type == DTCMessageType.LOGON_RESPONSE:
                response = self.message_parser.parse_logon_response(data)
                if response['success']:
                    self.is_authenticated = True
                    logger.info("âœ… Authentification Sierra Chart rÃ©ussie")
                else:
                    logger.error(f"âŒ Authentification Ã©chouÃ©e: {response['reason']}")
            
            elif message_type == DTCMessageType.HEARTBEAT:
                # Respond to heartbeat
                heartbeat_response = self.message_builder.build_heartbeat()
                self._send_message(heartbeat_response)
                self.stats['last_heartbeat'] = datetime.now(timezone.utc)
            
            elif message_type in [DTCMessageType.MARKET_DATA_UPDATE_TRADE, 
                                DTCMessageType.MARKET_DATA_UPDATE_BID_ASK]:
                # Traitement donnÃ©es marchÃ©
                tick = self.message_parser.parse_market_data_update(data)
                if tick and not self.tick_buffer.full():
                    self.tick_buffer.put_nowait(tick)
                    self.stats['ticks_received'] += 1
            
            elif message_type == DTCMessageType.ORDER_UPDATE:
                # Traitement mise Ã  jour ordre
                self._handle_order_update(data)
            
            else:
                logger.debug(f"Message DTC non traitÃ©: {message_type}")
                
        except Exception as e:
            logger.error(f"Erreur handle message {message_type}: {e}")
    
    def _handle_order_update(self, data: bytes):
        """Traitement mise Ã  jour ordre"""
        try:
            # Parsing simplifiÃ© order update
            if len(data) >= 100:  # Minimum size
                order_id_bytes = data[:32]
                order_id = order_id_bytes.rstrip(b'\x00').decode('utf-8')
                
                if order_id in self.orders:
                    # Update order status (simplified)
                    # Real implementation would parse full order status
                    logger.info(f"Order update reÃ§u: {order_id}")
                    
        except Exception as e:
            logger.error(f"Erreur handle order update: {e}")
    
    # === CONTRACT MANAGEMENT ===
    
    def _initialize_contracts(self):
        """Initialisation contrats Sierra Chart"""
        try:
            symbols = ['ES', 'NQ']
            
            for symbol in symbols:
                contract = SierraContract(
                    symbol=symbol,
                    exchange="CME",
                    security_type="Future"
                )
                
                self.contracts[symbol] = contract
                logger.info(f"Contrat Sierra Chart initialisÃ©: {symbol}")
            
            logger.info(f"âœ… {len(self.contracts)} contrats Sierra Chart initialisÃ©s")
            
        except Exception as e:
            logger.error(f"Erreur initialisation contrats: {e}")
    
    # === MARKET DATA STREAMING ===
    
    def subscribe_market_data(self, symbol: str, subscriber_name: str,
                            callback: Callable[[MarketData], None]) -> bool:
        """
        SUBSCRIPTION MARKET DATA
        
        Abonnement donnÃ©es marchÃ© Sierra Chart
        """
        try:
            if not self.is_authenticated:
                logger.error("Pas authentifiÃ© pour subscription market data")
                return False
            
            if symbol not in self.contracts:
                logger.error(f"Contrat non trouvÃ©: {symbol}")
                return False
            
            # Enregistrer callback
            self.subscribers[f"{symbol}_{subscriber_name}"] = callback
            
            # Envoi demande market data
            contract = self.contracts[symbol]
            symbol_id = contract.to_symbol_id()
            
            market_data_request = self.message_builder.build_market_data_request(symbol_id, 1)
            
            if self._send_message(market_data_request):
                logger.info(f"âœ… Market data subscription Sierra Chart: {symbol}")
                return True
            else:
                logger.error(f"âŒ Ã‰chec subscription market data: {symbol}")
                return False
                
        except Exception as e:
            logger.error(f"Erreur subscribe market data {symbol}: {e}")
            return False
    
    def unsubscribe_market_data(self, symbol: str, subscriber_name: str) -> bool:
        """DÃ©sabonnement market data"""
        try:
            key = f"{symbol}_{subscriber_name}"
            if key in self.subscribers:
                del self.subscribers[key]
                
                # Envoi demande unsubscribe
                if symbol in self.contracts:
                    contract = self.contracts[symbol]
                    symbol_id = contract.to_symbol_id()
                    
                    unsubscribe_request = self.message_builder.build_market_data_request(symbol_id, 2)
                    self._send_message(unsubscribe_request)
                
                logger.info(f"âœ… Unsubscribed Sierra Chart: {symbol}")
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Erreur unsubscribe {symbol}: {e}")
            return False
    
    # === ORDER MANAGEMENT ===
    
    def place_order(self, symbol: str, action: str, quantity: int,
                   order_type: str = "MARKET", price: Optional[float] = None,
                   stop_price: Optional[float] = None) -> Optional[str]:
        """
        PLACEMENT ORDRE SIERRA CHART
        
        Place ordre via DTC protocol
        """
        try:
            if not self.is_authenticated:
                logger.error("Pas authentifiÃ© pour placer ordre")
                return None
            
            if symbol not in self.contracts:
                logger.error(f"Contrat non trouvÃ©: {symbol}")
                return None
            
            # Validation paramÃ¨tres
            if action not in ["BUY", "SELL"]:
                logger.error(f"Action invalide: {action}")
                return None
            
            if quantity <= 0:
                logger.error(f"QuantitÃ© invalide: {quantity}")
                return None
            
            # GÃ©nÃ©ration ID ordre
            order_id = f"SC_{self.next_order_id:06d}"
            self.next_order_id += 1
            
            # CrÃ©ation ordre
            sierra_order = SierraOrder(
                order_id=order_id,
                symbol=symbol,
                action=action,
                quantity=quantity,
                order_type=order_type,
                price=price,
                stop_price=stop_price,
                status=SierraOrderStatus.PENDING
            )
            
            # Construction message DTC
            submit_message = self.message_builder.build_submit_order(sierra_order)
            
            if self._send_message(submit_message):
                self.orders[order_id] = sierra_order
                self.stats['orders_placed'] += 1
                
                logger.info(f"âœ… Ordre Sierra Chart placÃ©: {order_id} {action} {quantity} {symbol}")
                return order_id
            else:
                logger.error(f"âŒ Ã‰chec placement ordre Sierra Chart: {symbol}")
                return None
                
        except Exception as e:
            logger.error(f"Erreur place order: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """Annulation ordre"""
        try:
            if order_id not in self.orders:
                logger.error(f"Ordre non trouvÃ©: {order_id}")
                return False
            
            # Construction message CANCEL_ORDER
            message_type = DTCMessageType.CANCEL_ORDER
            order_id_bytes = order_id.encode('utf-8')[:32].ljust(32, b'\x00')
            
            message_data = order_id_bytes
            message_size = len(message_data) + 4
            header = struct.pack('<HH', message_size, message_type)
            
            cancel_message = header + message_data
            
            if self._send_message(cancel_message):
                # Update status
                self.orders[order_id].status = SierraOrderStatus.CANCELLED
                logger.info(f"âœ… Ordre Sierra Chart annulÃ©: {order_id}")
                return True
            else:
                logger.error(f"âŒ Ã‰chec annulation ordre: {order_id}")
                return False
                
        except Exception as e:
            logger.error(f"Erreur cancel order {order_id}: {e}")
            return False
    
    # === PROCESSING LOOPS ===
    
    def _processing_loop(self):
        """Loop traitement ticks"""
        logger.info("ðŸ“Š Sierra processing loop dÃ©marrÃ©")
        
        while self.is_running:
            try:
                # Traitement ticks
                tick = self.tick_buffer.get(timeout=1.0)
                self._process_tick(tick)
                
            except queue.Empty:
                continue
            except Exception as e:
                logger.error(f"Erreur processing loop: {e}")
                time.sleep(0.1)
        
        logger.info("ðŸ“Š Sierra processing loop terminÃ©")
    
    def _process_tick(self, tick: SierraTick):
        """Traitement tick individuel"""
        try:
            # Conversion vers MarketData
            market_data = self._convert_tick_to_market_data(tick)
            
            if market_data:
                # Cache update
                self.market_data_cache[tick.symbol] = market_data
                
                # Distribution subscribers
                for key, callback in self.subscribers.items():
                    if tick.symbol in key:
                        try:
                            callback(market_data)
                        except Exception as e:
                            logger.error(f"Erreur callback subscriber {key}: {e}")
            
        except Exception as e:
            logger.error(f"Erreur process tick: {e}")
    
    def _convert_tick_to_market_data(self, tick: SierraTick) -> Optional[MarketData]:
        """Conversion tick vers MarketData standardisÃ©"""
        try:
            if not tick.price:
                return None
            
            # Conversion vers format systÃ¨me
            market_data = MarketData(
                timestamp=pd.Timestamp(tick.timestamp),
                symbol=tick.symbol,
                open=tick.price,
                high=tick.price,
                low=tick.price,
                close=tick.price,
                volume=tick.volume or 0,
                bid=tick.bid_price or (tick.price - ES_TICK_SIZE),
                ask=tick.ask_price or (tick.price + ES_TICK_SIZE)
            )
            
            return market_data
            
        except Exception as e:
            logger.error(f"Erreur conversion tick: {e}")
            return None
    
    def _heartbeat_loop(self):
        """Loop heartbeat Sierra Chart"""
        logger.info("ðŸ’“ Sierra heartbeat dÃ©marrÃ©")
        
        while self.is_running:
            try:
                # VÃ©rification connexion
                if not self.is_connected or not self.socket:
                    logger.warning("Connexion Sierra Chart perdue")
                    self._attempt_reconnection()
                    break
                
                # Envoi heartbeat
                heartbeat_message = self.message_builder.build_heartbeat()
                if not self._send_message(heartbeat_message):
                    logger.warning("Ã‰chec envoi heartbeat")
                
                time.sleep(30)  # Heartbeat every 30 seconds
                
            except Exception as e:
                logger.error(f"Erreur heartbeat: {e}")
                time.sleep(10)
        
        logger.info("ðŸ’“ Sierra heartbeat terminÃ©")
    
    def _attempt_reconnection(self):
        """Tentative reconnexion automatique"""
        try:
            if self.reconnection_attempts >= self.max_reconnection_attempts:
                logger.error("Max reconnection attempts Sierra Chart atteint")
                return
            
            logger.info(f"Tentative reconnexion Sierra Chart {self.reconnection_attempts + 1}/{self.max_reconnection_attempts}")
            
            self.connection_status = SierraConnectionStatus.RECONNECTING
            self.reconnection_attempts += 1
            
            # DÃ©connexion propre
            self.disconnect()
            
            # Attendre avant reconnexion
            time.sleep(5)
            
            # Tentative reconnexion
            if self.connect():
                logger.info("âœ… Reconnexion Sierra Chart rÃ©ussie")
                self.reconnection_attempts = 0
            else:
                logger.error("âŒ Ã‰chec reconnexion Sierra Chart")
            
        except Exception as e:
            logger.error(f"Erreur attempt reconnection: {e}")
    
    # === PUBLIC INTERFACE ===
    
    def get_connection_status(self) -> Dict[str, Any]:
        """Status connexion Sierra Chart"""
        return {
            'status': self.connection_status.value,
            'is_connected': self.is_connected,
            'is_authenticated': self.is_authenticated,
            'protocol': 'DTC',
            'last_connection_attempt': self.last_connection_attempt.isoformat() if self.last_connection_attempt else None,
            'reconnection_attempts': self.reconnection_attempts,
            'contracts_loaded': len(self.contracts),
            'active_subscriptions': len(self.subscribers)
        }
    
    def get_orders(self) -> Dict[str, SierraOrder]:
        """Ordres actifs Sierra Chart"""
        return self.orders.copy()
    
    def get_statistics(self) -> Dict[str, Any]:
        """Statistiques Sierra Chart"""
        uptime = 0
        if self.last_connection_attempt and self.is_connected:
            uptime = (datetime.now(timezone.utc) - self.last_connection_attempt).total_seconds()
        
        self.stats['connection_uptime'] = uptime
        return self.stats.copy()

# === FACTORY FUNCTIONS ===

def create_sierra_connector(config: Optional[Dict] = None) -> SierraConnector:
    """Factory function pour Sierra Chart connector"""
    return SierraConnector(config)

# === TESTING ===

def test_sierra_connector():
    """Test Sierra Chart connector"""
    print("ðŸ“¡ TEST SIERRA CHART CONNECTOR")
    print("=" * 40)
    
    connector = create_sierra_connector()
    
    # Test connexion
    connected = connector.connect()
    print(f"âœ… Connexion: {connected}")
    
    if connected:
        # Test subscription
        def test_callback(market_data: MarketData):
            print(f"ðŸ“Š Sierra data: {market_data.symbol} @ {market_data.close}")
        
        success = connector.subscribe_market_data("ES", "test", test_callback)
        print(f"âœ… Subscription: {success}")
        
        # Test court
        time.sleep(5)
        
        # Test placement ordre
        order_id = connector.place_order("ES", "BUY", 1, "MARKET")
        print(f"âœ… Ordre placÃ©: {order_id}")
        
        # Status
        status = connector.get_connection_status()
        print(f"âœ… Status: {status['status']}")
        
        # DÃ©connexion
        connector.disconnect()
        print("âœ… DÃ©connexion")
    
    print("ðŸŽ¯ Sierra Chart connector test COMPLETED")
    return True

if __name__ == "__main__":
    test_sierra_connector()