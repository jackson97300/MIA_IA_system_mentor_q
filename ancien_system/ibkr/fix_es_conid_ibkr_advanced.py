#!/usr/bin/env python3
"""
üîß Fix ES ConID - M√©thode Avanc√©e IBKR
Script qui r√©sout le probl√®me de ConID incorrect en utilisant les m√©thodes officielles IBKR
Bas√© sur l'analyse des erreurs et les meilleures pratiques de la documentation
"""

import sys
import requests
import json
import time
from pathlib import Path
from datetime import datetime
from urllib3.exceptions import InsecureRequestWarning
import warnings

# Supprimer les warnings SSL pour localhost
warnings.filterwarnings('ignore', category=InsecureRequestWarning)

# Ajouter le chemin du projet
sys.path.append(str(Path(__file__).parent.parent))

def authenticate_ibkr():
    """Authentification IBKR Client Portal Gateway"""
    print("üîê Authentification IBKR...")
    
    base_url = "https://localhost:5000/v1/api"
    session = requests.Session()
    session.verify = False
    
    try:
        # V√©rifier le statut d'authentification
        auth_response = session.get(
            f"{base_url}/iserver/auth/status",
            timeout=10
        )
        
        if auth_response.status_code != 200:
            print(f"‚ùå Erreur authentification: {auth_response.status_code}")
            return None, None
        
        auth_data = auth_response.json()
        
        if auth_data.get('authenticated'):
            print("‚úÖ D√©j√† authentifi√©")
            return session, base_url
        
        print("‚ùå Authentification requise - Ouvrir https://localhost:5000/sso/Dispatcher")
        return None, None
        
    except Exception as e:
        print(f"‚ùå Erreur authentification: {e}")
        return None, None

def search_es_futures_advanced(session, base_url):
    """Recherche ES futures avec m√©thode avanc√©e bas√©e sur la documentation IBKR"""
    print("\nüîç Recherche ES futures - M√©thode avanc√©e IBKR")
    print("="*60)
    
    # M√©thodes de recherche bas√©es sur la documentation IBKR officielle
    search_methods = [
        # M√©thode 1: Recherche avec lastTradeDateOrContractMonth (recommand√©e par IBKR)
        {
            "name": "ES avec lastTradeDateOrContractMonth 202509",
            "params": {
                "symbol": "ES",
                "secType": "FUT",
                "exchange": "GLOBEX",
                "currency": "USD",
                "lastTradeDateOrContractMonth": "202509"
            }
        },
        # M√©thode 2: Recherche avec expiry (alternative)
        {
            "name": "ES avec expiry 202509",
            "params": {
                "symbol": "ES",
                "secType": "FUT",
                "exchange": "GLOBEX",
                "currency": "USD",
                "expiry": "202509"
            }
        },
        # M√©thode 3: Recherche avec localSymbol (convention IBKR)
        {
            "name": "ES avec localSymbol ESU25",
            "params": {
                "symbol": "ES",
                "secType": "FUT",
                "exchange": "GLOBEX",
                "currency": "USD",
                "localSymbol": "ESU25"  # ES September 2025
            }
        },
        # M√©thode 4: Recherche simple mais avec filtrage
        {
            "name": "ES simple avec filtrage",
            "params": {
                "symbol": "ES"
            }
        }
    ]
    
    all_contracts = []
    
    for method in search_methods:
        print(f"\nüîç Test: {method['name']}")
        print(f"   Param√®tres: {method['params']}")
        
        try:
            search_response = session.get(
                f"{base_url}/iserver/secdef/search",
                params=method['params'],
                timeout=15
            )
            
            print(f"   Status: {search_response.status_code}")
            
            if search_response.status_code == 200:
                contracts = search_response.json()
                print(f"   R√©sultats: {len(contracts)} contrats")
                
                for contract in contracts:
                    conid = contract.get('conid')
                    symbol = contract.get('symbol')
                    description = contract.get('description')
                    secType = contract.get('secType')
                    exchange = contract.get('exchange')
                    currency = contract.get('currency')
                    localSymbol = contract.get('localSymbol')
                    
                    # Filtrer les contrats ES
                    if symbol == "ES":
                        contract_info = {
                            'conid': conid,
                            'symbol': symbol,
                            'description': description,
                            'secType': secType,
                            'exchange': exchange,
                            'currency': currency,
                            'localSymbol': localSymbol,
                            'search_method': method['name']
                        }
                        
                        # √âviter les doublons
                        if not any(c['conid'] == conid for c in all_contracts):
                            all_contracts.append(contract_info)
                            
                            print(f"     ‚úÖ ConID: {conid}")
                            print(f"        Description: {description}")
                            print(f"        Type: {secType}")
                            print(f"        Exchange: {exchange}")
                            print(f"        Currency: {currency}")
                            print(f"        LocalSymbol: {localSymbol}")
            else:
                print(f"   ‚ùå Erreur: {search_response.status_code}")
                if search_response.status_code == 500:
                    print(f"   D√©tails: {search_response.text}")
                    
        except Exception as e:
            print(f"   ‚ùå Exception: {e}")
    
    return all_contracts

def get_contract_details_advanced(session, base_url, conid):
    """R√©cup√©rer les d√©tails complets d'un contrat avec analyse avanc√©e"""
    print(f"\nüìã D√©tails complets ConID: {conid}")
    
    try:
        details_response = session.get(
            f"{base_url}/iserver/secdef/info",
            params={"conid": conid},
            timeout=15
        )
        
        if details_response.status_code == 200:
            contract_data = details_response.json()
            print(f"‚úÖ D√©tails r√©cup√©r√©s")
            
            # Analyser les d√©tails
            symbol = contract_data.get('symbol')
            secType = contract_data.get('secType')
            exchange = contract_data.get('exchange')
            currency = contract_data.get('currency')
            localSymbol = contract_data.get('localSymbol')
            expiry = contract_data.get('expiry')
            lastTradeDateOrContractMonth = contract_data.get('lastTradeDateOrContractMonth')
            
            print(f"   Symbol: {symbol}")
            print(f"   SecType: {secType}")
            print(f"   Exchange: {exchange}")
            print(f"   Currency: {currency}")
            print(f"   LocalSymbol: {localSymbol}")
            print(f"   Expiry: {expiry}")
            print(f"   LastTradeDate: {lastTradeDateOrContractMonth}")
            
            return contract_data
        else:
            print(f"‚ùå Erreur d√©tails: {details_response.status_code}")
            return None
            
    except Exception as e:
        print(f"‚ùå Exception d√©tails: {e}")
        return None

def test_market_data_advanced(session, base_url, conid):
    """Tester les donn√©es de march√© avec m√©thode avanc√©e"""
    print(f"\nüìä Test donn√©es de march√© ConID: {conid}")
    
    try:
        # 1. Souscrire aux donn√©es (POST)
        print("üì° Souscription aux donn√©es...")
        
        subscribe_response = session.post(
            f"{base_url}/iserver/marketdata/snapshot",
            json={
                "conids": [conid],
                "fields": ["31", "83", "84", "86", "6", "7", "8", "9"]
            },
            timeout=15
        )
        
        print(f"   Souscription status: {subscribe_response.status_code}")
        
        if subscribe_response.status_code == 200:
            print("‚úÖ Souscription r√©ussie")
            
            # 2. Attendre un peu
            time.sleep(3)
            
            # 3. R√©cup√©rer les donn√©es (GET)
            print("üìä R√©cup√©ration des donn√©es...")
            
            market_response = session.get(
                f"{base_url}/iserver/marketdata/snapshot",
                params={
                    "conids": conid,
                    "fields": "31,83,84,86,6,7,8,9"
                },
                timeout=15
            )
            
            print(f"   R√©cup√©ration status: {market_response.status_code}")
            
            if market_response.status_code == 200:
                data = market_response.json()
                print(f"   Donn√©es re√ßues: {json.dumps(data, indent=2)}")
                
                if isinstance(data, list) and len(data) > 0:
                    tick_data = data[0]
                    
                    # Analyser les donn√©es
                    prices = {}
                    for key, value in tick_data.items():
                        if key == '31':
                            prices['bid'] = value
                        elif key == '83':
                            prices['ask'] = value
                        elif key == '84':
                            prices['last'] = value
                        elif key == '86':
                            prices['volume'] = value
                        elif key == '6':
                            prices['high'] = value
                        elif key == '7':
                            prices['low'] = value
                        elif key == '8':
                            prices['open'] = value
                        elif key == '9':
                            prices['close'] = value
                    
                    if prices:
                        print(f"   üí∞ Prix trouv√©s:")
                        for price_type, value in prices.items():
                            print(f"     {price_type}: {value}")
                        
                        # V√©rifier si le prix est r√©aliste pour ES
                        if prices.get('last'):
                            last_price = float(prices['last'])
                            print(f"   üìä Prix last: {last_price}")
                            
                            # Le prix ES devrait √™tre autour de 6481
                            if 6000 <= last_price <= 7000:
                                print(f"   ‚úÖ Prix r√©aliste pour ES!")
                                return prices
                            else:
                                print(f"   ‚ö†Ô∏è Prix suspect: {last_price}")
                        else:
                            print(f"   ‚ö†Ô∏è Pas de prix last")
                    else:
                        print(f"   ‚ö†Ô∏è Aucun prix trouv√©")
                else:
                    print(f"   ‚ö†Ô∏è Pas de donn√©es dans la r√©ponse")
            else:
                print(f"   ‚ùå Erreur r√©cup√©ration: {market_response.status_code}")
        else:
            print(f"   ‚ùå Erreur souscription: {subscribe_response.status_code}")
        
        return None
        
    except Exception as e:
        print(f"‚ùå Exception donn√©es: {e}")
        return None

def analyze_contracts_advanced(contracts):
    """Analyser les contrats avec logique avanc√©e"""
    print(f"\nüéØ Analyse avanc√©e de {len(contracts)} contrats...")
    
    es_futures = []
    es_sep25_candidates = []
    
    for contract in contracts:
        conid = contract['conid']
        description = contract['description']
        secType = contract['secType']
        localSymbol = contract.get('localSymbol', '')
        
        print(f"\nüîç ConID: {conid}")
        print(f"   Description: {description}")
        print(f"   Type: {secType}")
        print(f"   LocalSymbol: {localSymbol}")
        
        # V√©rifier si c'est un future ES
        if secType == "FUT":
            es_futures.append(contract)
            print(f"   ‚úÖ Future ES d√©tect√©")
            
            # V√©rifier si c'est Sep19'25 par plusieurs crit√®res
            is_sep25 = False
            
            # Crit√®re 1: Description
            if description:
                desc_lower = description.lower()
                if "sep" in desc_lower and "2025" in desc_lower:
                    is_sep25 = True
                    print(f"   üìÖ ES Sep19'25 d√©tect√© par description")
            
            # Crit√®re 2: LocalSymbol (convention IBKR)
            if localSymbol and "ESU25" in localSymbol.upper():
                is_sep25 = True
                print(f"   üìÖ ES Sep19'25 d√©tect√© par localSymbol")
            
            # Crit√®re 3: ConID connu (si on a des r√©f√©rences)
            known_es_sep25_conids = [
                # Ajouter ici les ConIDs connus pour ES Sep19'25
                # Ces valeurs peuvent √™tre trouv√©es via TWS ou documentation
            ]
            
            if conid in known_es_sep25_conids:
                is_sep25 = True
                print(f"   üìÖ ES Sep19'25 d√©tect√© par ConID connu")
            
            if is_sep25:
                es_sep25_candidates.append(contract)
                print(f"   üéØ ES Sep19'25 CANDIDAT CONFIRM√â!")
        else:
            print(f"   ‚ùå Pas un future")
    
    return es_futures, es_sep25_candidates

def try_alternative_search_methods(session, base_url):
    """Essayer des m√©thodes de recherche alternatives"""
    print(f"\nüîÑ M√©thodes de recherche alternatives...")
    
    # M√©thode alternative 1: Recherche par symbole local
    print(f"\nüîç Recherche par symbole local...")
    
    local_symbols = ["ESU25", "ESZ25", "ESH26", "ESM25"]  # Diff√©rentes expirations
    
    for local_symbol in local_symbols:
        print(f"   Test localSymbol: {local_symbol}")
        
        try:
            search_response = session.get(
                f"{base_url}/iserver/secdef/search",
                params={
                    "localSymbol": local_symbol,
                    "secType": "FUT"
                },
                timeout=15
            )
            
            if search_response.status_code == 200:
                contracts = search_response.json()
                if contracts:
                    print(f"     ‚úÖ Trouv√©: {len(contracts)} contrats")
                    for contract in contracts:
                        conid = contract.get('conid')
                        symbol = contract.get('symbol')
                        description = contract.get('description')
                        print(f"       ConID: {conid}, Symbol: {symbol}, Desc: {description}")
                        
                        if symbol == "ES":
                            return contract
                else:
                    print(f"     ‚ùå Aucun contrat trouv√©")
            else:
                print(f"     ‚ùå Erreur: {search_response.status_code}")
                
        except Exception as e:
            print(f"     ‚ùå Exception: {e}")
    
    return None

def main():
    """Fonction principale"""
    print("üöÄ Fix ES ConID - M√©thode Avanc√©e IBKR")
    print("="*60)
    print(f"üïê Timestamp: {datetime.now()}")
    
    # 1. Authentification
    session, base_url = authenticate_ibkr()
    if not session:
        print("‚ùå Impossible de s'authentifier")
        return
    
    # 2. Recherche ES futures avanc√©e
    contracts = search_es_futures_advanced(session, base_url)
    
    if not contracts:
        print("‚ùå Aucun contrat ES trouv√©")
        return
    
    # 3. Analyser les contrats trouv√©s
    es_futures, es_sep25_candidates = analyze_contracts_advanced(contracts)
    
    # 4. Si pas de candidats ES Sep19'25, essayer les m√©thodes alternatives
    if not es_sep25_candidates:
        print(f"\nüîÑ Aucun candidat ES Sep19'25 trouv√©, essai m√©thodes alternatives...")
        alternative_contract = try_alternative_search_methods(session, base_url)
        
        if alternative_contract:
            es_sep25_candidates = [alternative_contract]
            print(f"‚úÖ Contrat alternatif trouv√©: {alternative_contract['conid']}")
    
    # 5. Tester les candidats
    if es_sep25_candidates:
        print(f"\nüéØ {len(es_sep25_candidates)} candidats ES Sep19'25 trouv√©s!")
        
        for candidate in es_sep25_candidates:
            conid = candidate['conid']
            print(f"\n" + "="*60)
            print(f"üéØ TEST CANDIDAT ES Sep19'25 - ConID: {conid}")
            print("="*60)
            
            # R√©cup√©rer les d√©tails complets
            contract_data = get_contract_details_advanced(session, base_url, conid)
            
            # Tester les donn√©es de march√©
            prices = test_market_data_advanced(session, base_url, conid)
            
            if prices:
                print(f"\nüéâ SUCC√àS! Prix ES Sep19'25 r√©cup√©r√©s:")
                print(f"   Bid:     {prices.get('bid', 'N/A'):>10}")
                print(f"   Ask:     {prices.get('ask', 'N/A'):>10}")
                print(f"   Last:    {prices.get('last', 'N/A'):>10}")
                print(f"   Volume:  {prices.get('volume', 'N/A'):>10}")
                
                # V√©rifier la coh√©rence avec TWS
                if prices.get('bid') and prices.get('ask'):
                    bid_price = float(prices['bid'])
                    ask_price = float(prices['ask'])
                    
                    expected_bid = 6481.00
                    expected_ask = 6481.25
                    
                    bid_diff = abs(bid_price - expected_bid)
                    ask_diff = abs(ask_price - expected_ask)
                    
                    print(f"\nüìä Comparaison avec TWS:")
                    print(f"   TWS Bid/Ask: {expected_bid}/{expected_ask}")
                    print(f"   API Bid/Ask: {bid_price}/{ask_price}")
                    print(f"   Diff Bid: {bid_diff:.2f}")
                    print(f"   Diff Ask: {ask_diff:.2f}")
                    
                    if bid_diff < 1 and ask_diff < 1:
                        print(f"   üéØ Prix parfaitement coh√©rent!")
                    elif bid_diff < 10 and ask_diff < 10:
                        print(f"   ‚úÖ Prix coh√©rent")
                    else:
                        print(f"   ‚ö†Ô∏è Prix diff√©rent")
                
                return  # Succ√®s, on arr√™te
    
    # 6. Si toujours pas de succ√®s, tester tous les futures ES
    if es_futures:
        print(f"\nüîç Test de tous les {len(es_futures)} futures ES...")
        
        for contract in es_futures:
            conid = contract['conid']
            description = contract['description']
            
            print(f"\nüìã Test ConID: {conid} - {description}")
            
            # R√©cup√©rer les d√©tails complets
            contract_data = get_contract_details_advanced(session, base_url, conid)
            
            # Tester les donn√©es de march√©
            prices = test_market_data_advanced(session, base_url, conid)
            
            if prices:
                print(f"\nüéâ SUCC√àS! Prix ES r√©cup√©r√©s avec ConID: {conid}")
                return  # Succ√®s, on arr√™te
    
    print(f"\n‚ùå Aucun contrat ES avec donn√©es de march√© trouv√©")
    print(f"üîß Probl√®mes possibles:")
    print(f"  - Contrat non disponible")
    print(f"  - Heures de trading")
    print(f"  - Permissions de donn√©es de march√©")
    print(f"  - Probl√®me API IBKR")
    print(f"  - ConID incorrect dans la recherche")
    
    print(f"\nüëã Script termin√©")

if __name__ == "__main__":
    main()

