#!/usr/bin/env python3
"""
üöÄ MIA_IA_SYSTEM - DEPLOY LIVE SCRIPT
üéØ D√©ploiement Live Trading Production-Ready
Version: Production Ready v3.0
Performance: D√©ploiement s√©curis√©, monitoring int√©gr√©, rollback automatique

RESPONSABILIT√âS CRITIQUES :
1. üîç PRE-DEPLOYMENT CHECKS - Validation compl√®te syst√®me
2. üè• HEALTH VERIFICATION - Integration Health Checker complet
3. ‚öôÔ∏è ENVIRONMENT SETUP - Configuration production optimis√©e
4. üîê SECURITY VALIDATION - V√©rifications s√©curit√© multi-niveaux
5. üìä STAGED DEPLOYMENT - D√©ploiement progressif par √©tapes
6. üìà REAL-TIME MONITORING - Surveillance continue d√©ploiement
7. üîÑ ROLLBACK AUTOMATION - Retour arri√®re automatique si probl√®me
8. üìã DEPLOYMENT REPORTING - Rapports d√©taill√©s et alertes

WORKFLOW D√âPLOIEMENT :
Pre-Checks ‚Üí Environment Setup ‚Üí Components Start ‚Üí Health Verification ‚Üí 
Go-Live Decision ‚Üí Monitoring ‚Üí Success/Rollback

MODES D√âPLOIEMENT :
- VALIDATION : V√©rification syst√®me sans d√©marrage
- PAPER_TO_LIVE : Transition paper trading ‚Üí live
- COLD_START : D√©marrage √† froid syst√®me complet
- HOT_UPGRADE : Upgrade syst√®me en cours de fonctionnement
- EMERGENCY_STOP : Arr√™t d'urgence syst√®me live

INT√âGRATION SYST√àME :
- Health Checker : Orchestrateur surveillance
- Performance Tracker : M√©triques temps r√©el
- Discord Notifier : Alertes d√©ploiement
- Simple Trader : Core automation
- Battle Navale : M√©thode signature
"""

import sys
import os
import time
import json
import logging
import argparse
import subprocess
import threading
import signal
import shutil
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple, Union
from dataclasses import dataclass, field, asdict
from enum import Enum
from datetime import datetime, timedelta, timezone
from collections import defaultdict, deque
import psutil
import requests

# === THIRD-PARTY ===
import pandas as pd
import numpy as np

# === MIA_IA_SYSTEM IMPORTS ===
try:
    # Configuration syst√®me
    from config import get_trading_config, get_automation_config
    
    # Core components
    from core import (
        MarketData, TradingSignal, SignalType,
        ES_TICK_SIZE, ES_TICK_VALUE
    )
    
    # Monitoring & Health Checker (critiques pour d√©ploiement)
    from monitoring import (
        start_production_monitoring, create_health_checker,
        emergency_health_check, get_health_status
    )
    
    # Strategies (cerveau central)
    from strategies import get_signal_now, create_signal_generator
    
    SYSTEM_INTEGRATION = True
    
except ImportError as e:
    SYSTEM_INTEGRATION = False
    print(f"‚ö†Ô∏è Int√©gration MIA_IA_SYSTEM limit√©e: {e}")
    print("üîÑ Mode d√©ploiement standalone activ√©")

# Logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('logs/deploy_live.log')
    ]
)
logger = logging.getLogger(__name__)

# === DEPLOYMENT ENUMS ===

class DeploymentMode(Enum):
    """Modes de d√©ploiement"""
    VALIDATION = "validation"         # Validation seulement, pas de d√©marrage
    PAPER_TO_LIVE = "paper_to_live"   # Transition paper ‚Üí live
    COLD_START = "cold_start"         # D√©marrage √† froid complet
    HOT_UPGRADE = "hot_upgrade"       # Upgrade syst√®me running
    EMERGENCY_STOP = "emergency_stop"  # Arr√™t d'urgence

class DeploymentStage(Enum):
    """√âtapes de d√©ploiement"""
    INIT = "init"
    PRE_CHECKS = "pre_checks"
    ENVIRONMENT_SETUP = "environment_setup"
    COMPONENTS_START = "components_start"
    HEALTH_VERIFICATION = "health_verification"
    GO_LIVE = "go_live"
    MONITORING = "monitoring"
    COMPLETED = "completed"
    FAILED = "failed"
    ROLLED_BACK = "rolled_back"

class DeploymentStatus(Enum):
    """Status d√©ploiement"""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    SUCCESS = "success"
    WARNING = "warning"
    FAILED = "failed"
    ROLLED_BACK = "rolled_back"

class CheckSeverity(Enum):
    """S√©v√©rit√© des checks"""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"

# === STRUCTURES DE DONN√âES ===

@dataclass
class DeploymentCheck:
    """R√©sultat d'un check de d√©ploiement"""
    check_name: str
    status: DeploymentStatus
    severity: CheckSeverity
    message: str
    details: Dict[str, Any] = field(default_factory=dict)
    execution_time_ms: float = 0.0
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))

@dataclass
class DeploymentConfig:
    """Configuration d√©ploiement"""
    mode: DeploymentMode
    target_environment: str = "production"
    
    # Safety settings
    enable_rollback: bool = True
    max_deployment_time_minutes: int = 30
    health_check_interval_seconds: int = 30
    failure_threshold: int = 3
    
    # Capital & Risk
    max_position_size: int = 1
    daily_loss_limit: float = 500.0
    max_drawdown_percent: float = 5.0
    
    # Trading settings
    enable_live_execution: bool = False
    paper_trading_first: bool = True
    validation_trades_count: int = 10
    
    # Notifications
    discord_notifications: bool = True
    email_notifications: bool = False
    
    # Advanced
    backup_before_deployment: bool = True
    enable_circuit_breakers: bool = True
    require_manual_approval: bool = True

@dataclass
class DeploymentReport:
    """Rapport de d√©ploiement complet"""
    deployment_id: str
    start_time: datetime
    end_time: Optional[datetime] = None
    
    # Configuration
    config: DeploymentConfig = None
    target_environment: str = "production"
    
    # Status
    current_stage: DeploymentStage = DeploymentStage.INIT
    overall_status: DeploymentStatus = DeploymentStatus.PENDING
    
    # Checks
    pre_checks: List[DeploymentCheck] = field(default_factory=list)
    health_checks: List[DeploymentCheck] = field(default_factory=list)
    post_checks: List[DeploymentCheck] = field(default_factory=list)
    
    # M√©triques
    total_execution_time_seconds: float = 0.0
    components_deployed: List[str] = field(default_factory=list)
    components_failed: List[str] = field(default_factory=list)
    
    # Rollback
    rollback_triggered: bool = False
    rollback_reason: str = ""
    rollback_successful: bool = False
    
    # Monitoring post-deployment
    health_score_pre_deployment: float = 0.0
    health_score_post_deployment: float = 0.0
    trading_started: bool = False
    first_trade_timestamp: Optional[datetime] = None

# === CLASSE PRINCIPALE DEPLOYER ===

class LiveDeployer:
    """
    üöÄ LIVE DEPLOYER MIA_IA_SYSTEM
    
    Gestionnaire de d√©ploiement live trading production avec s√©curit√© maximale.
    Int√©gration compl√®te Health Checker et monitoring pour d√©ploiement s√ªr.
    """
    
    def __init__(self, config: DeploymentConfig):
        """Initialisation deployer"""
        self.config = config
        self.deployment_id = f"deploy_{int(time.time())}"
        self.start_time = datetime.now(timezone.utc)
        
        # √âtat d√©ploiement
        self.current_stage = DeploymentStage.INIT
        self.deployment_status = DeploymentStatus.PENDING
        self.is_running = False
        self.rollback_triggered = False
        
        # Composants syst√®me
        self.health_checker = None
        self.signal_generator = None
        self.simple_trader = None
        self.monitoring_system = None
        
        # Monitoring d√©ploiement
        self.deployment_thread: Optional[threading.Thread] = None
        self.monitoring_thread: Optional[threading.Thread] = None
        self.deployed_components: List[str] = []
        self.failed_components: List[str] = []
        
        # Checks et rapport
        self.pre_checks: List[DeploymentCheck] = []
        self.health_checks: List[DeploymentCheck] = []
        self.post_checks: List[DeploymentCheck] = []
        
        # Backup state
        self.backup_path: Optional[Path] = None
        self.pre_deployment_state: Dict[str, Any] = {}
        
        logger.info(f"üöÄ LiveDeployer initialis√© - ID: {self.deployment_id}")
        logger.info(f"Mode: {config.mode.value}, Environment: {config.target_environment}")
    
    # === POINT D'ENTR√âE PRINCIPAL ===
    
    def deploy(self) -> DeploymentReport:
        """
        D√âPLOIEMENT PRINCIPAL
        
        Orchestration compl√®te du d√©ploiement avec toutes les s√©curit√©s
        """
        try:
            logger.info("üöÄ D√âMARRAGE D√âPLOIEMENT LIVE MIA_IA_SYSTEM")
            logger.info("=" * 60)
            
            self.is_running = True
            self._update_stage(DeploymentStage.PRE_CHECKS)
            
            # === 1. PRE-DEPLOYMENT CHECKS ===
            if not self._run_pre_deployment_checks():
                return self._handle_deployment_failure("Pre-deployment checks failed")
            
            # === 2. ENVIRONMENT SETUP ===
            self._update_stage(DeploymentStage.ENVIRONMENT_SETUP)
            if not self._setup_deployment_environment():
                return self._handle_deployment_failure("Environment setup failed")
            
            # === 3. BACKUP (si activ√©) ===
            if self.config.backup_before_deployment:
                if not self._create_deployment_backup():
                    return self._handle_deployment_failure("Backup creation failed")
            
            # === 4. COMPONENTS DEPLOYMENT ===
            self._update_stage(DeploymentStage.COMPONENTS_START)
            if not self._deploy_system_components():
                return self._handle_deployment_failure("Components deployment failed")
            
            # === 5. HEALTH VERIFICATION ===
            self._update_stage(DeploymentStage.HEALTH_VERIFICATION)
            if not self._verify_system_health():
                return self._handle_deployment_failure("Health verification failed")
            
            # === 6. GO-LIVE DECISION ===
            self._update_stage(DeploymentStage.GO_LIVE)
            if not self._make_go_live_decision():
                return self._handle_deployment_failure("Go-live decision negative")
            
            # === 7. START MONITORING ===
            self._update_stage(DeploymentStage.MONITORING)
            self._start_deployment_monitoring()
            
            # === 8. SUCCESS ===
            self._update_stage(DeploymentStage.COMPLETED)
            self.deployment_status = DeploymentStatus.SUCCESS
            
            logger.info("‚úÖ D√âPLOIEMENT LIVE R√âUSSI!")
            return self._generate_deployment_report()
            
        except Exception as e:
            logger.error(f"‚ùå Erreur critique d√©ploiement: {e}")
            return self._handle_deployment_failure(f"Critical error: {e}")
        
        finally:
            self.is_running = False
    
    # === PRE-DEPLOYMENT CHECKS ===
    
    def _run_pre_deployment_checks(self) -> bool:
        """Ex√©cute tous les checks pr√©-d√©ploiement"""
        logger.info("üîç Ex√©cution pre-deployment checks...")
        
        checks = [
            ("system_requirements", self._check_system_requirements),
            ("python_environment", self._check_python_environment),
            ("dependencies", self._check_dependencies),
            ("configuration_files", self._check_configuration_files),
            ("data_directories", self._check_data_directories),
            ("network_connectivity", self._check_network_connectivity),
            ("broker_connectivity", self._check_broker_connectivity),
            ("disk_space", self._check_disk_space),
            ("security_settings", self._check_security_settings),
            ("existing_processes", self._check_existing_processes)
        ]
        
        all_passed = True
        
        for check_name, check_func in checks:
            check_result = self._execute_check(check_name, check_func)
            self.pre_checks.append(check_result)
            
            if check_result.status == DeploymentStatus.FAILED:
                if check_result.severity in [CheckSeverity.ERROR, CheckSeverity.CRITICAL]:
                    all_passed = False
                    logger.error(f"‚ùå Critical check failed: {check_name}")
                else:
                    logger.warning(f"‚ö†Ô∏è Check warning: {check_name}")
        
        # R√©sum√©
        passed_count = len([c for c in self.pre_checks if c.status == DeploymentStatus.SUCCESS])
        total_count = len(self.pre_checks)
        
        logger.info(f"üìä Pre-deployment checks: {passed_count}/{total_count} passed")
        
        if all_passed:
            logger.info("‚úÖ Tous les checks critiques passed")
        else:
            logger.error("‚ùå √âchec des checks critiques")
        
        return all_passed
    
    def _execute_check(self, check_name: str, check_func: callable) -> DeploymentCheck:
        """Ex√©cute un check individuel avec timing"""
        start_time = time.perf_counter()
        
        try:
            result = check_func()
            execution_time = (time.perf_counter() - start_time) * 1000
            
            if isinstance(result, tuple):
                status, severity, message, details = result
            else:
                # Assume boolean result
                status = DeploymentStatus.SUCCESS if result else DeploymentStatus.FAILED
                severity = CheckSeverity.CRITICAL if not result else CheckSeverity.INFO
                message = f"Check {check_name}: {'passed' if result else 'failed'}"
                details = {}
            
            return DeploymentCheck(
                check_name=check_name,
                status=status,
                severity=severity,
                message=message,
                details=details,
                execution_time_ms=execution_time
            )
            
        except Exception as e:
            execution_time = (time.perf_counter() - start_time) * 1000
            
            return DeploymentCheck(
                check_name=check_name,
                status=DeploymentStatus.FAILED,
                severity=CheckSeverity.CRITICAL,
                message=f"Check {check_name} error: {e}",
                details={"exception": str(e)},
                execution_time_ms=execution_time
            )
    
    def _check_system_requirements(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """V√©rifie requirements syst√®me"""
        details = {}
        
        # Python version
        python_version = sys.version_info
        details['python_version'] = f"{python_version.major}.{python_version.minor}.{python_version.micro}"
        
        if python_version < (3, 8):
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   f"Python {details['python_version']} < 3.8 required", details)
        
        # System resources
        cpu_count = psutil.cpu_count()
        memory = psutil.virtual_memory()
        disk = psutil.disk_usage('/')
        
        details.update({
            'cpu_count': cpu_count,
            'memory_total_gb': round(memory.total / (1024**3), 2),
            'memory_available_gb': round(memory.available / (1024**3), 2),
            'disk_total_gb': round(disk.total / (1024**3), 2),
            'disk_free_gb': round(disk.free / (1024**3), 2)
        })
        
        # Minimum requirements check
        warnings = []
        if cpu_count < 2:
            warnings.append("CPU count < 2")
        if memory.available < 2 * (1024**3):  # 2GB
            warnings.append("Available memory < 2GB")
        if disk.free < 10 * (1024**3):  # 10GB
            warnings.append("Free disk space < 10GB")
        
        if warnings:
            severity = CheckSeverity.WARNING
            message = f"System requirements met with warnings: {', '.join(warnings)}"
        else:
            severity = CheckSeverity.INFO
            message = "System requirements fully satisfied"
        
        return (DeploymentStatus.SUCCESS, severity, message, details)
    
    def _check_python_environment(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """V√©rifie environnement Python"""
        details = {}
        
        # Virtual environment check
        in_venv = hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix)
        details['virtual_environment'] = in_venv
        details['python_executable'] = sys.executable
        details['python_path'] = sys.path[:3]  # First 3 entries
        
        # Check if we're in project directory
        project_indicators = ['core', 'strategies', 'config', 'monitoring']
        current_dir = Path.cwd()
        has_project_structure = all((current_dir / indicator).exists() for indicator in project_indicators)
        details['project_structure_detected'] = has_project_structure
        details['current_directory'] = str(current_dir)
        
        warnings = []
        if not in_venv:
            warnings.append("Not in virtual environment")
        if not has_project_structure:
            warnings.append("Project structure not detected")
        
        if not has_project_structure:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   "Project structure not found", details)
        
        message = "Python environment OK"
        if warnings:
            message += f" (warnings: {', '.join(warnings)})"
        
        severity = CheckSeverity.WARNING if warnings else CheckSeverity.INFO
        return (DeploymentStatus.SUCCESS, severity, message, details)
    
    def _check_dependencies(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """V√©rifie d√©pendances Python"""
        details = {}
        
        required_packages = [
            'pandas', 'numpy', 'psutil', 'flask',
            'plotly', 'requests', 'tqdm'
        ]
        
        available_packages = []
        missing_packages = []
        
        for package in required_packages:
            try:
                __import__(package)
                available_packages.append(package)
            except ImportError:
                missing_packages.append(package)
        
        details['available_packages'] = available_packages
        details['missing_packages'] = missing_packages
        details['total_required'] = len(required_packages)
        details['available_count'] = len(available_packages)
        
        if missing_packages:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   f"Missing packages: {', '.join(missing_packages)}", details)
        
        # Check MIA_IA_SYSTEM integration
        details['system_integration'] = SYSTEM_INTEGRATION
        
        if not SYSTEM_INTEGRATION:
            return (DeploymentStatus.SUCCESS, CheckSeverity.WARNING,
                   "Dependencies OK but MIA_IA_SYSTEM integration limited", details)
        
        return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
               "All dependencies available", details)
    
    def _check_configuration_files(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """V√©rifie fichiers de configuration"""
        details = {}
        
        required_configs = [
            'config/trading_config.py',
            'config/__init__.py'
        ]
        
        optional_configs = [
            'config/automation_config.py',
            'config/sierra_config.py',
            '.env.live',
            '.env.production'
        ]
        
        available_required = []
        missing_required = []
        available_optional = []
        missing_optional = []
        
        for config_file in required_configs:
            if Path(config_file).exists():
                available_required.append(config_file)
            else:
                missing_required.append(config_file)
        
        for config_file in optional_configs:
            if Path(config_file).exists():
                available_optional.append(config_file)
            else:
                missing_optional.append(config_file)
        
        details.update({
            'required_available': available_required,
            'required_missing': missing_required,
            'optional_available': available_optional,
            'optional_missing': missing_optional
        })
        
        if missing_required:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   f"Missing required configs: {', '.join(missing_required)}", details)
        
        # Test configuration loading
        try:
            if SYSTEM_INTEGRATION:
                config = get_trading_config()
                details['config_loading'] = 'success'
                details['config_mode'] = getattr(config, 'trading_mode', 'unknown')
            else:
                details['config_loading'] = 'limited_integration'
        except Exception as e:
            return (DeploymentStatus.FAILED, CheckSeverity.ERROR,
                   f"Configuration loading failed: {e}", details)
        
        warnings = []
        if missing_optional:
            warnings.append(f"Missing optional configs: {', '.join(missing_optional[:3])}")
        
        message = "Configuration files OK"
        if warnings:
            message += f" ({', '.join(warnings)})"
        
        severity = CheckSeverity.WARNING if warnings else CheckSeverity.INFO
        return (DeploymentStatus.SUCCESS, severity, message, details)
    
    def _check_data_directories(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """V√©rifie structure des r√©pertoires donn√©es"""
        details = {}
        
        required_dirs = [
            'data',
            'logs',
            'config'
        ]
        
        recommended_dirs = [
            'data/snapshots',
            'data/live',
            'data/historical',
            'logs/live_trading',
            'logs/system',
            'reports'
        ]
        
        existing_required = []
        missing_required = []
        existing_recommended = []
        missing_recommended = []
        
        for dir_path in required_dirs:
            path = Path(dir_path)
            if path.exists() and path.is_dir():
                existing_required.append(dir_path)
            else:
                missing_required.append(dir_path)
        
        for dir_path in recommended_dirs:
            path = Path(dir_path)
            if path.exists() and path.is_dir():
                existing_recommended.append(dir_path)
            else:
                missing_recommended.append(dir_path)
        
        details.update({
            'required_existing': existing_required,
            'required_missing': missing_required,
            'recommended_existing': existing_recommended,
            'recommended_missing': missing_recommended
        })
        
        # Create missing required directories
        created_dirs = []
        for dir_path in missing_required:
            try:
                Path(dir_path).mkdir(parents=True, exist_ok=True)
                created_dirs.append(dir_path)
                existing_required.append(dir_path)
                missing_required.remove(dir_path)
            except Exception as e:
                details['creation_error'] = str(e)
        
        if created_dirs:
            details['created_directories'] = created_dirs
        
        if missing_required:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   f"Cannot create required directories: {', '.join(missing_required)}", details)
        
        # Check disk permissions
        try:
            test_file = Path('logs/deploy_test.tmp')
            test_file.write_text('test')
            test_file.unlink()
            details['write_permissions'] = True
        except Exception as e:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   f"No write permissions: {e}", details)
        
        warnings = []
        if missing_recommended:
            warnings.append(f"Missing recommended dirs: {len(missing_recommended)}")
        
        message = "Data directories OK"
        if created_dirs:
            message += f" (created: {len(created_dirs)})"
        if warnings:
            message += f" (warnings: {', '.join(warnings)})"
        
        severity = CheckSeverity.WARNING if warnings else CheckSeverity.INFO
        return (DeploymentStatus.SUCCESS, severity, message, details)
    
    def _check_network_connectivity(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """V√©rifie connectivit√© r√©seau"""
        details = {}
        
        # Test basic internet connectivity
        test_urls = [
            ('google.com', 80),
            ('discord.com', 443),
            ('github.com', 443)
        ]
        
        connectivity_results = {}
        successful_connections = 0
        
        for host, port in test_urls:
            try:
                import socket
                sock = socket.create_connection((host, port), timeout=5)
                sock.close()
                connectivity_results[f"{host}:{port}"] = True
                successful_connections += 1
            except Exception as e:
                connectivity_results[f"{host}:{port}"] = False
                details[f"{host}_error"] = str(e)
        
        details['connectivity_tests'] = connectivity_results
        details['successful_connections'] = successful_connections
        details['total_tests'] = len(test_urls)
        
        if successful_connections == 0:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   "No internet connectivity", details)
        elif successful_connections < len(test_urls):
            return (DeploymentStatus.SUCCESS, CheckSeverity.WARNING,
                   f"Partial connectivity: {successful_connections}/{len(test_urls)}", details)
        else:
            return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
                   "Full internet connectivity", details)
    
    def _check_broker_connectivity(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """V√©rifie connectivit√© broker (simul√©)"""
        details = {}
        
        # Note: En production, ici on testerait vraiment IBKR/Sierra Chart
        # Pour l'instant, simulation
        
        if self.config.mode == DeploymentMode.VALIDATION:
            details['broker_check'] = 'skipped_validation_mode'
            return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
                   "Broker connectivity skipped (validation mode)", details)
        
        # Simulation test IBKR
        try:
            # Simulation: v√©rifier si IBKR gateway possible
            details['ibkr_gateway_port'] = 7497  # TWS port
            details['ibkr_test'] = 'simulated'
            
            # En production : test connexion r√©elle
            # if SYSTEM_INTEGRATION:
            #     from core.ibkr_connector import IBKRConnector
            #     connector = IBKRConnector()
            #     connection_result = connector.test_connection()
            
            return (DeploymentStatus.SUCCESS, CheckSeverity.WARNING,
                   "Broker connectivity simulated (not tested)", details)
            
        except Exception as e:
            details['broker_error'] = str(e)
            return (DeploymentStatus.FAILED, CheckSeverity.ERROR,
                   f"Broker connectivity test failed: {e}", details)
    
    def _check_disk_space(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """V√©rifie espace disque disponible"""
        details = {}
        
        # Check current directory disk usage
        disk_usage = psutil.disk_usage('.')
        
        total_gb = disk_usage.total / (1024**3)
        free_gb = disk_usage.free / (1024**3)
        used_gb = disk_usage.used / (1024**3)
        usage_percent = (used_gb / total_gb) * 100
        
        details.update({
            'total_gb': round(total_gb, 2),
            'free_gb': round(free_gb, 2),
            'used_gb': round(used_gb, 2),
            'usage_percent': round(usage_percent, 2)
        })
        
        # Minimum requirements
        min_free_gb = 5.0  # 5GB minimum
        warning_threshold = 85  # 85% usage warning
        critical_threshold = 95  # 95% usage critical
        
        if free_gb < min_free_gb:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   f"Insufficient disk space: {free_gb:.1f}GB < {min_free_gb}GB required", details)
        
        if usage_percent >= critical_threshold:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   f"Disk usage critical: {usage_percent:.1f}% >= {critical_threshold}%", details)
        
        if usage_percent >= warning_threshold:
            return (DeploymentStatus.SUCCESS, CheckSeverity.WARNING,
                   f"Disk usage high: {usage_percent:.1f}%", details)
        
        return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
               f"Disk space OK: {free_gb:.1f}GB free ({usage_percent:.1f}% used)", details)
    
    def _check_security_settings(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """V√©rifie param√®tres de s√©curit√©"""
        details = {}
        
        # Check environment variables for sensitive data
        sensitive_vars = ['IBKR_USERNAME', 'IBKR_PASSWORD', 'DISCORD_TOKEN', 'EMAIL_PASSWORD']
        env_vars_present = {}
        
        for var in sensitive_vars:
            env_vars_present[var] = var in os.environ
        
        details['environment_variables'] = env_vars_present
        
        # Check .env files
        env_files = ['.env', '.env.live', '.env.production']
        env_files_present = {}
        
        for env_file in env_files:
            env_files_present[env_file] = Path(env_file).exists()
        
        details['env_files'] = env_files_present
        
        # Security recommendations
        warnings = []
        
        # Check if running as root (dangerous)
        if os.getuid() == 0:  # Unix only
            warnings.append("Running as root user")
        
        # Check file permissions on sensitive files
        sensitive_files = ['config/trading_config.py', '.env.live']
        for file_path in sensitive_files:
            path = Path(file_path)
            if path.exists():
                # Unix permissions check
                try:
                    stat = path.stat()
                    permissions = oct(stat.st_mode)[-3:]
                    if permissions != '600':  # Should be readable only by owner
                        warnings.append(f"{file_path} permissions not secure: {permissions}")
                except:
                    pass
        
        # Risk parameters validation for live trading
        if self.config.mode != DeploymentMode.VALIDATION:
            if self.config.daily_loss_limit > 1000:
                warnings.append(f"Daily loss limit high: ${self.config.daily_loss_limit}")
            
            if self.config.max_position_size > 2:
                warnings.append(f"Max position size high: {self.config.max_position_size}")
        
        details['security_warnings'] = warnings
        
        message = "Security settings checked"
        if warnings:
            message += f" ({len(warnings)} warnings)"
        
        severity = CheckSeverity.WARNING if warnings else CheckSeverity.INFO
        return (DeploymentStatus.SUCCESS, severity, message, details)
    
    def _check_existing_processes(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """V√©rifie processus existants"""
        details = {}
        
        # Look for existing MIA_IA_SYSTEM processes
        current_pid = os.getpid()
        python_processes = []
        
        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                if proc.info['name'] and 'python' in proc.info['name'].lower():
                    if proc.info['cmdline']:
                        cmdline = ' '.join(proc.info['cmdline'])
                        if any(keyword in cmdline.lower() for keyword in ['automation_main', 'deploy_live', 'mia_ia']):
                            if proc.info['pid'] != current_pid:
                                python_processes.append({
                                    'pid': proc.info['pid'],
                                    'cmdline': cmdline[:100]  # Truncate
                                })
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                pass
        
        details['existing_processes'] = python_processes
        details['current_pid'] = current_pid
        
        if python_processes:
            if self.config.mode == DeploymentMode.HOT_UPGRADE:
                return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
                       f"Found {len(python_processes)} existing processes (hot upgrade mode)", details)
            else:
                return (DeploymentStatus.SUCCESS, CheckSeverity.WARNING,
                       f"Found {len(python_processes)} existing processes", details)
        
        return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
               "No conflicting processes found", details)
    
    # === ENVIRONMENT SETUP ===
    
    def _setup_deployment_environment(self) -> bool:
        """Configure l'environnement pour le d√©ploiement"""
        logger.info("‚öôÔ∏è Configuration environnement d√©ploiement...")
        
        try:
            # 1. Set environment variables
            os.environ['MIA_TRADING_ENV'] = self.config.target_environment
            os.environ['MIA_DEPLOYMENT_ID'] = self.deployment_id
            os.environ['MIA_DEPLOYMENT_MODE'] = self.config.mode.value
            
            # 2. Create necessary directories
            directories = [
                'logs/live_trading',
                'data/snapshots/daily',
                'data/live/current_session',
                'reports/deployment',
                'backups'
            ]
            
            for directory in directories:
                Path(directory).mkdir(parents=True, exist_ok=True)
            
            # 3. Setup logging for deployment
            self._setup_deployment_logging()
            
            # 4. Load and validate configuration
            if SYSTEM_INTEGRATION:
                self._load_trading_configuration()
            
            logger.info("‚úÖ Environnement configur√© avec succ√®s")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erreur configuration environnement: {e}")
            return False
    
    def _setup_deployment_logging(self):
        """Configure logging sp√©cifique au d√©ploiement"""
        log_file = Path(f"logs/live_trading/deployment_{self.deployment_id}.log")
        
        # Add deployment-specific handler
        handler = logging.FileHandler(log_file)
        handler.setFormatter(logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        ))
        
        # Add to all loggers
        logging.getLogger().addHandler(handler)
        
        logger.info(f"üìã Deployment logging configur√©: {log_file}")
    
    def _load_trading_configuration(self):
        """Charge et valide la configuration trading"""
        try:
            trading_config = get_trading_config()
            
            # Validate configuration for live trading
            if self.config.enable_live_execution:
                # Additional validation for live trading
                if not hasattr(trading_config, 'max_position_size'):
                    raise ValueError("max_position_size not configured")
                
                if trading_config.max_position_size > self.config.max_position_size:
                    logger.warning(f"Adjusting position size: {trading_config.max_position_size} ‚Üí {self.config.max_position_size}")
            
            logger.info("‚úÖ Configuration trading valid√©e")
            
        except Exception as e:
            logger.error(f"‚ùå Erreur configuration trading: {e}")
            raise
    
    # === BACKUP ===
    
    def _create_deployment_backup(self) -> bool:
        """Cr√©e backup avant d√©ploiement"""
        logger.info("üíæ Cr√©ation backup pr√©-d√©ploiement...")
        
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            self.backup_path = Path(f"backups/pre_deployment_{timestamp}")
            self.backup_path.mkdir(parents=True, exist_ok=True)
            
            # Backup critical files
            files_to_backup = [
                'config/',
                'logs/system/',
                'data/snapshots/',
                '.env*'
            ]
            
            for item in files_to_backup:
                source_path = Path(item)
                if source_path.exists():
                    if source_path.is_dir():
                        shutil.copytree(source_path, self.backup_path / source_path.name, dirs_exist_ok=True)
                    else:
                        shutil.copy2(source_path, self.backup_path)
            
            # Store current system state
            self.pre_deployment_state = {
                'timestamp': datetime.now(timezone.utc).isoformat(),
                'deployment_id': self.deployment_id,
                'system_health': self._get_current_health_score(),
                'running_processes': len(list(psutil.process_iter())),
                'memory_usage': psutil.virtual_memory().percent,
                'cpu_usage': psutil.cpu_percent(interval=1)
            }
            
            # Save state to backup
            state_file = self.backup_path / 'pre_deployment_state.json'
            with open(state_file, 'w') as f:
                json.dump(self.pre_deployment_state, f, indent=2)
            
            logger.info(f"‚úÖ Backup cr√©√©: {self.backup_path}")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erreur cr√©ation backup: {e}")
            return False
    
    # === COMPONENTS DEPLOYMENT ===
    
    def _deploy_system_components(self) -> bool:
        """D√©ploie les composants syst√®me dans l'ordre"""
        logger.info("üîß D√©ploiement composants syst√®me...")
        
        # Ordre critique de d√©ploiement
        components = [
            ("health_checker", self._deploy_health_checker),
            ("signal_generator", self._deploy_signal_generator),
            ("monitoring_system", self._deploy_monitoring_system),
            ("simple_trader", self._deploy_simple_trader)
        ]
        
        for component_name, deploy_func in components:
            logger.info(f"üîß D√©ploiement {component_name}...")
            
            try:
                success = deploy_func()
                if success:
                    self.deployed_components.append(component_name)
                    logger.info(f"‚úÖ {component_name} d√©ploy√©")
                else:
                    self.failed_components.append(component_name)
                    logger.error(f"‚ùå √âchec d√©ploiement {component_name}")
                    return False
                    
            except Exception as e:
                logger.error(f"‚ùå Erreur d√©ploiement {component_name}: {e}")
                self.failed_components.append(component_name)
                return False
        
        logger.info(f"‚úÖ Tous les composants d√©ploy√©s: {len(self.deployed_components)}")
        return True
    
    def _deploy_health_checker(self) -> bool:
        """D√©ploie Health Checker (priorit√© absolue)"""
        try:
            if not SYSTEM_INTEGRATION:
                logger.warning("Health Checker non disponible - mode standalone")
                return True
            
            self.health_checker = create_health_checker({
                'auto_recovery_enabled': True,
                'dashboard_enabled': True,
                'dashboard_port': 8080,
                'emergency_alert_threshold': 2
            })
            
            # D√©marrage Health Checker
            self.health_checker.start()
            
            # Wait for startup
            time.sleep(5)
            
            # Verify health checker is running
            if self.health_checker.is_running:
                logger.info("‚úÖ Health Checker op√©rationnel")
                return True
            else:
                logger.error("‚ùå Health Checker non d√©marr√©")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erreur Health Checker: {e}")
            return False
    
    def _deploy_signal_generator(self) -> bool:
        """D√©ploie Signal Generator (cerveau central)"""
        try:
            if not SYSTEM_INTEGRATION:
                logger.warning("Signal Generator non disponible - mode standalone")
                return True
            
            self.signal_generator = create_signal_generator()
            
            # Test signal generation
            test_data = MarketData(
                timestamp=pd.Timestamp.now(),
                symbol="ES",
                close=4500.0,
                open=4500.0,
                high=4502.0,
                low=4498.0,
                volume=1000
            )
            
            signal = get_signal_now(test_data)
            if signal is not None:
                logger.info("‚úÖ Signal Generator op√©rationnel")
                return True
            else:
                logger.warning("‚ö†Ô∏è Signal Generator retourne None - config possible")
                return True  # Not critical for deployment
                
        except Exception as e:
            logger.error(f"‚ùå Erreur Signal Generator: {e}")
            return False
    
    def _deploy_monitoring_system(self) -> bool:
        """D√©ploie syst√®me monitoring complet"""
        try:
            if not SYSTEM_INTEGRATION:
                logger.warning("Monitoring system non disponible - mode standalone")
                return True
            
            self.monitoring_system = start_production_monitoring({
                'auto_start_health_monitoring': False,  # D√©j√† d√©marr√©
                'dashboard_enabled': True,
                'dashboard_port': 8081  # Port diff√©rent du Health Checker
            })
            
            if self.monitoring_system:
                logger.info("‚úÖ Monitoring system op√©rationnel")
                return True
            else:
                logger.warning("‚ö†Ô∏è Monitoring system partiellement disponible")
                return True  # Not critical
                
        except Exception as e:
            logger.error(f"‚ùå Erreur monitoring system: {e}")
            return False
    
    def _deploy_simple_trader(self) -> bool:
        """D√©ploie Simple Trader (automation core)"""
        try:
            # Note: En production, ici on d√©marrerait vraiment SimpleBattleNavaleTrader
            # Pour l'instant, simulation du d√©ploiement
            
            if self.config.mode == DeploymentMode.VALIDATION:
                logger.info("‚úÖ Simple Trader valid√© (mode validation)")
                return True
            
            # Simulation d√©ploiement
            logger.info("üîß D√©ploiement Simple Trader...")
            time.sleep(2)  # Simulation startup time
            
            # En production:
            # from execution.simple_trader import SimpleBattleNavaleTrader
            # self.simple_trader = SimpleBattleNavaleTrader(mode="LIVE" if self.config.enable_live_execution else "PAPER")
            # self.simple_trader.start()
            
            logger.info("‚úÖ Simple Trader d√©ploy√© (simul√©)")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erreur Simple Trader: {e}")
            return False
    
    # === HEALTH VERIFICATION ===
    
    def _verify_system_health(self) -> bool:
        """V√©rifie la sant√© compl√®te du syst√®me apr√®s d√©ploiement"""
        logger.info("üè• V√©rification sant√© syst√®me...")
        
        health_checks = [
            ("system_resources", self._health_check_system_resources),
            ("components_status", self._health_check_components_status),
            ("signal_generation", self._health_check_signal_generation),
            ("data_flow", self._health_check_data_flow),
            ("monitoring", self._health_check_monitoring)
        ]
        
        all_healthy = True
        
        for check_name, check_func in health_checks:
            health_result = self._execute_check(check_name, check_func)
            self.health_checks.append(health_result)
            
            if health_result.status == DeploymentStatus.FAILED:
                if health_result.severity in [CheckSeverity.ERROR, CheckSeverity.CRITICAL]:
                    all_healthy = False
                    logger.error(f"‚ùå Health check failed: {check_name}")
        
        # Integration avec Health Checker si disponible
        if self.health_checker:
            try:
                health_status = self.health_checker.get_health_status()
                overall_health = health_status['overall_health']
                
                logger.info(f"üè• Health Checker score: {overall_health:.1f}%")
                
                if overall_health < 70:
                    logger.error(f"‚ùå Health score trop bas: {overall_health:.1f}%")
                    all_healthy = False
                elif overall_health < 85:
                    logger.warning(f"‚ö†Ô∏è Health score mod√©r√©: {overall_health:.1f}%")
                else:
                    logger.info(f"‚úÖ Health score excellent: {overall_health:.1f}%")
                
            except Exception as e:
                logger.error(f"‚ùå Erreur Health Checker verification: {e}")
                all_healthy = False
        
        logger.info(f"üè• Health verification: {'‚úÖ PASSED' if all_healthy else '‚ùå FAILED'}")
        return all_healthy
    
    def _health_check_system_resources(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """Health check ressources syst√®me"""
        details = {}
        
        # CPU usage
        cpu_percent = psutil.cpu_percent(interval=1)
        memory = psutil.virtual_memory()
        
        details.update({
            'cpu_percent': cpu_percent,
            'memory_percent': memory.percent,
            'memory_available_gb': round(memory.available / (1024**3), 2)
        })
        
        if cpu_percent > 90:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   f"CPU usage critical: {cpu_percent}%", details)
        
        if memory.percent > 90:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   f"Memory usage critical: {memory.percent}%", details)
        
        if cpu_percent > 70 or memory.percent > 70:
            return (DeploymentStatus.SUCCESS, CheckSeverity.WARNING,
                   f"Resources moderate: CPU {cpu_percent}%, Memory {memory.percent}%", details)
        
        return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
               f"Resources optimal: CPU {cpu_percent}%, Memory {memory.percent}%", details)
    
    def _health_check_components_status(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """Health check status des composants"""
        details = {
            'deployed_components': self.deployed_components,
            'failed_components': self.failed_components
        }
        
        if self.failed_components:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   f"Failed components: {', '.join(self.failed_components)}", details)
        
        if len(self.deployed_components) < 2:
            return (DeploymentStatus.FAILED, CheckSeverity.ERROR,
                   f"Insufficient components deployed: {len(self.deployed_components)}", details)
        
        return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
               f"All {len(self.deployed_components)} components healthy", details)
    
    def _health_check_signal_generation(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """Health check g√©n√©ration de signaux"""
        details = {}
        
        if not SYSTEM_INTEGRATION:
            details['integration'] = 'limited'
            return (DeploymentStatus.SUCCESS, CheckSeverity.WARNING,
                   "Signal generation not tested (limited integration)", details)
        
        try:
            # Test signal generation avec donn√©es simul√©es
            test_data = MarketData(
                timestamp=pd.Timestamp.now(),
                symbol="ES",
                close=4500.0 + np.random.normal(0, 2),
                open=4499.0,
                high=4503.0,
                low=4497.0,
                volume=1500
            )
            
            start_time = time.perf_counter()
            signal = get_signal_now(test_data)
            generation_time_ms = (time.perf_counter() - start_time) * 1000
            
            details.update({
                'signal_generated': signal is not None,
                'generation_time_ms': round(generation_time_ms, 2),
                'signal_type': signal.signal_type.value if signal else None
            })
            
            if generation_time_ms > 100:  # >100ms est lent
                return (DeploymentStatus.SUCCESS, CheckSeverity.WARNING,
                       f"Signal generation slow: {generation_time_ms:.1f}ms", details)
            
            if signal is None:
                return (DeploymentStatus.SUCCESS, CheckSeverity.WARNING,
                       "Signal generation returns None (expected with random data)", details)
            
            return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
                   f"Signal generation OK: {generation_time_ms:.1f}ms", details)
            
        except Exception as e:
            details['error'] = str(e)
            return (DeploymentStatus.FAILED, CheckSeverity.ERROR,
                   f"Signal generation failed: {e}", details)
    
    def _health_check_data_flow(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """Health check flux de donn√©es"""
        details = {}
        
        # Check data directories accessibility
        data_dirs = ['data', 'logs', 'data/snapshots']
        accessible_dirs = []
        
        for dir_path in data_dirs:
            path = Path(dir_path)
            if path.exists() and path.is_dir():
                try:
                    # Test write access
                    test_file = path / 'health_check_test.tmp'
                    test_file.write_text('test')
                    test_file.unlink()
                    accessible_dirs.append(dir_path)
                except:
                    pass
        
        details.update({
            'data_directories_accessible': accessible_dirs,
            'total_directories': len(data_dirs)
        })
        
        if len(accessible_dirs) < len(data_dirs):
            return (DeploymentStatus.FAILED, CheckSeverity.ERROR,
                   f"Data directories not accessible: {len(accessible_dirs)}/{len(data_dirs)}", details)
        
        return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
               "Data flow paths verified", details)
    
    def _health_check_monitoring(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """Health check syst√®me monitoring"""
        details = {}
        
        if self.health_checker:
            try:
                health_status = self.health_checker.get_health_status()
                details['health_checker_available'] = True
                details['overall_health'] = health_status['overall_health']
                details['components_total'] = health_status['components_total']
                
                if health_status['overall_health'] < 70:
                    return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                           f"Health Checker reports low health: {health_status['overall_health']:.1f}%", details)
                
                return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
                       f"Monitoring operational: {health_status['overall_health']:.1f}% health", details)
                
            except Exception as e:
                details['health_checker_error'] = str(e)
                return (DeploymentStatus.FAILED, CheckSeverity.ERROR,
                       f"Health Checker error: {e}", details)
        else:
            details['health_checker_available'] = False
            return (DeploymentStatus.SUCCESS, CheckSeverity.WARNING,
                   "Health Checker not available", details)
    
    # === GO-LIVE DECISION ===
    
    def _make_go_live_decision(self) -> bool:
        """Prend la d√©cision de go-live"""
        logger.info("üéØ Prise de d√©cision go-live...")
        
        # Analyse des r√©sultats de checks
        critical_failures = len([c for c in self.health_checks 
                               if c.status == DeploymentStatus.FAILED and 
                               c.severity == CheckSeverity.CRITICAL])
        
        total_health_checks = len(self.health_checks)
        success_rate = len([c for c in self.health_checks 
                           if c.status == DeploymentStatus.SUCCESS]) / total_health_checks if total_health_checks > 0 else 0
        
        logger.info(f"üìä Health checks success rate: {success_rate:.1%}")
        logger.info(f"üö® Critical failures: {critical_failures}")
        
        # Crit√®res de d√©cision
        go_live_criteria = {
            'no_critical_failures': critical_failures == 0,
            'success_rate_sufficient': success_rate >= 0.8,
            'all_components_deployed': len(self.failed_components) == 0,
            'health_score_acceptable': self._get_current_health_score() >= 70
        }
        
        logger.info("üìã Go-live criteria:")
        for criterion, met in go_live_criteria.items():
            status = "‚úÖ" if met else "‚ùå"
            logger.info(f"   {status} {criterion}: {met}")
        
        # D√©cision
        all_criteria_met = all(go_live_criteria.values())
        
        if all_criteria_met:
            logger.info("‚úÖ GO-LIVE APPROUV√â - Tous les crit√®res satisfaits")
            
            # Manual approval si requis
            if self.config.require_manual_approval and self.config.mode != DeploymentMode.VALIDATION:
                approval = self._request_manual_approval()
                if not approval:
                    logger.warning("‚ùå GO-LIVE REFUS√â - Approbation manuelle refus√©e")
                    return False
            
            return True
        else:
            failed_criteria = [k for k, v in go_live_criteria.items() if not v]
            logger.error(f"‚ùå GO-LIVE REFUS√â - Crit√®res √©chou√©s: {', '.join(failed_criteria)}")
            return False
    
    def _request_manual_approval(self) -> bool:
        """Demande approbation manuelle"""
        if self.config.mode == DeploymentMode.VALIDATION:
            return True
        
        logger.info("‚è≥ Approbation manuelle requise pour go-live...")
        
        try:
            # En production, ici on pourrait envoyer notification Discord
            # et attendre approbation, ou utiliser une interface web
            
            print("\n" + "="*60)
            print("üö® MANUAL APPROVAL REQUIRED FOR LIVE TRADING")
            print("="*60)
            print(f"Deployment ID: {self.deployment_id}")
            print(f"Mode: {self.config.mode.value}")
            print(f"Max Position Size: {self.config.max_position_size}")
            print(f"Daily Loss Limit: ${self.config.daily_loss_limit}")
            print(f"Live Execution: {self.config.enable_live_execution}")
            print("="*60)
            
            if self.config.enable_live_execution:
                print("‚ö†Ô∏è  WARNING: LIVE TRADING WITH REAL MONEY")
                print("‚ö†Ô∏è  VERIFY ALL SETTINGS BEFORE APPROVAL")
                print("="*60)
            
            response = input("Approve deployment? (YES/no): ").strip()
            
            if response.upper() == "YES":
                logger.info("‚úÖ Approbation manuelle accord√©e")
                return True
            else:
                logger.warning("‚ùå Approbation manuelle refus√©e")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erreur approbation manuelle: {e}")
            return False
    
    # === MONITORING ===
    
    def _start_deployment_monitoring(self):
        """D√©marre monitoring post-d√©ploiement"""
        logger.info("üìä D√©marrage monitoring post-d√©ploiement...")
        
        self.monitoring_thread = threading.Thread(
            target=self._deployment_monitoring_loop,
            daemon=True
        )
        self.monitoring_thread.start()
        
        logger.info("‚úÖ Monitoring post-d√©ploiement d√©marr√©")
    
    def _deployment_monitoring_loop(self):
        """Loop monitoring post-d√©ploiement"""
        logger.info("üîÑ Loop monitoring post-d√©ploiement actif")
        
        monitoring_start = time.time()
        max_monitoring_time = self.config.max_deployment_time_minutes * 60
        
        while self.is_running and (time.time() - monitoring_start) < max_monitoring_time:
            try:
                # Health check p√©riodique
                current_health = self._get_current_health_score()
                
                if current_health < 50:
                    logger.error(f"üö® Health critique d√©tect√©e: {current_health:.1f}%")
                    self._trigger_emergency_rollback("Critical health degradation")
                    break
                
                # Check composants
                if self.health_checker and not self.health_checker.is_running:
                    logger.error("üö® Health Checker arr√™t√©")
                    self._trigger_emergency_rollback("Health Checker stopped")
                    break
                
                # Log status
                if int(time.time()) % 300 == 0:  # Tous les 5 minutes
                    logger.info(f"üìä Monitoring: Health {current_health:.1f}%, Uptime {int(time.time() - monitoring_start)}s")
                
                time.sleep(self.config.health_check_interval_seconds)
                
            except Exception as e:
                logger.error(f"‚ùå Erreur monitoring loop: {e}")
                time.sleep(30)
    
    # === ROLLBACK ===
    
    def _trigger_emergency_rollback(self, reason: str):
        """D√©clenche rollback d'urgence"""
        logger.error(f"üö® D√âCLENCHEMENT ROLLBACK D'URGENCE: {reason}")
        
        self.rollback_triggered = True
        self.deployment_status = DeploymentStatus.FAILED
        
        try:
            if self.config.enable_rollback:
                success = self._execute_rollback(reason)
                if success:
                    self.deployment_status = DeploymentStatus.ROLLED_BACK
                    logger.info("‚úÖ Rollback ex√©cut√© avec succ√®s")
                else:
                    logger.error("‚ùå √âchec rollback - intervention manuelle requise")
            else:
                logger.warning("‚ö†Ô∏è Rollback d√©sactiv√© - arr√™t syst√®me")
                self._emergency_shutdown()
                
        except Exception as e:
            logger.error(f"‚ùå Erreur critique rollback: {e}")
            self._emergency_shutdown()
    
    def _execute_rollback(self, reason: str) -> bool:
        """Ex√©cute proc√©dure de rollback"""
        logger.info(f"üîÑ Ex√©cution rollback: {reason}")
        
        try:
            # 1. Stop tous les composants d√©ploy√©s
            self._stop_deployed_components()
            
            # 2. Restore backup si disponible
            if self.backup_path and self.backup_path.exists():
                self._restore_from_backup()
            
            # 3. Cleanup
            self._cleanup_deployment()
            
            logger.info("‚úÖ Rollback termin√©")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erreur rollback: {e}")
            return False
    
    def _stop_deployed_components(self):
        """Arr√™te tous les composants d√©ploy√©s"""
        logger.info("üõë Arr√™t composants d√©ploy√©s...")
        
        # Arr√™t dans l'ordre inverse du d√©ploiement
        if self.simple_trader:
            try:
                # self.simple_trader.stop()
                logger.info("‚úÖ Simple Trader arr√™t√©")
            except Exception as e:
                logger.error(f"‚ùå Erreur arr√™t Simple Trader: {e}")
        
        if self.health_checker:
            try:
                self.health_checker.stop()
                logger.info("‚úÖ Health Checker arr√™t√©")
            except Exception as e:
                logger.error(f"‚ùå Erreur arr√™t Health Checker: {e}")
        
        logger.info("‚úÖ Composants arr√™t√©s")
    
    def _restore_from_backup(self):
        """Restore depuis backup"""
        logger.info(f"üì¶ Restoration depuis backup: {self.backup_path}")
        
        try:
            # Restore critical directories
            backup_dirs = ['config', 'logs/system']
            
            for dir_name in backup_dirs:
                backup_dir = self.backup_path / dir_name
                target_dir = Path(dir_name)
                
                if backup_dir.exists():
                    if target_dir.exists():
                        shutil.rmtree(target_dir)
                    shutil.copytree(backup_dir, target_dir)
                    logger.info(f"‚úÖ Restored {dir_name}")
            
            logger.info("‚úÖ Backup restoration termin√©e")
            
        except Exception as e:
            logger.error(f"‚ùå Erreur restoration backup: {e}")
    
    def _cleanup_deployment(self):
        """Nettoie artifacts de d√©ploiement"""
        logger.info("üßπ Cleanup deployment...")
        
        try:
            # Remove temporary files
            temp_files = Path('.').glob('*.tmp')
            for temp_file in temp_files:
                temp_file.unlink()
            
            # Reset environment variables
            env_vars = ['MIA_DEPLOYMENT_ID', 'MIA_DEPLOYMENT_MODE']
            for var in env_vars:
                os.environ.pop(var, None)
            
            logger.info("‚úÖ Cleanup termin√©")
            
        except Exception as e:
            logger.error(f"‚ùå Erreur cleanup: {e}")
    
    def _emergency_shutdown(self):
        """Arr√™t d'urgence complet"""
        logger.error("üö® ARR√äT D'URGENCE SYST√àME")
        
        try:
            self._stop_deployed_components()
            self.is_running = False
            
            # Kill all related processes if necessary
            # En production, ici on pourrait forcer l'arr√™t de processus
            
            logger.error("üõë Arr√™t d'urgence termin√©")
            
        except Exception as e:
            logger.error(f"‚ùå Erreur arr√™t d'urgence: {e}")
    
    # === FAILURE HANDLING ===
    
    def _handle_deployment_failure(self, reason: str) -> DeploymentReport:
        """G√®re √©chec de d√©ploiement"""
        logger.error(f"‚ùå √âCHEC D√âPLOIEMENT: {reason}")
        
        self.deployment_status = DeploymentStatus.FAILED
        self._update_stage(DeploymentStage.FAILED)
        
        # Rollback automatique si activ√©
        if self.config.enable_rollback and not self.rollback_triggered:
            self._trigger_emergency_rollback(f"Deployment failure: {reason}")
        
        return self._generate_deployment_report()
    
    # === UTILITIES ===
    
    def _update_stage(self, stage: DeploymentStage):
        """Met √† jour l'√©tape actuelle"""
        self.current_stage = stage
        logger.info(f"üìç Stage: {stage.value.upper()}")
    
    def _get_current_health_score(self) -> float:
        """Obtient score de sant√© actuel"""
        try:
            if self.health_checker:
                health_status = self.health_checker.get_health_status()
                return health_status['overall_health']
            else:
                # Fallback: calcul simplifi√©
                return 80.0  # Assume reasonable health
                
        except Exception as e:
            logger.error(f"‚ùå Erreur health score: {e}")
            return 50.0  # Conservative fallback
    
    def _generate_deployment_report(self) -> DeploymentReport:
        """G√©n√®re rapport de d√©ploiement complet"""
        end_time = datetime.now(timezone.utc)
        total_time = (end_time - self.start_time).total_seconds()
        
        report = DeploymentReport(
            deployment_id=self.deployment_id,
            start_time=self.start_time,
            end_time=end_time,
            config=self.config,
            target_environment=self.config.target_environment,
            current_stage=self.current_stage,
            overall_status=self.deployment_status,
            pre_checks=self.pre_checks,
            health_checks=self.health_checks,
            post_checks=self.post_checks,
            total_execution_time_seconds=total_time,
            components_deployed=self.deployed_components,
            components_failed=self.failed_components,
            rollback_triggered=self.rollback_triggered,
            health_score_pre_deployment=self.pre_deployment_state.get('system_health', 0),
            health_score_post_deployment=self._get_current_health_score()
        )
        
        # Sauvegarde rapport
        self._save_deployment_report(report)
        
        return report
    
    def _save_deployment_report(self, report: DeploymentReport):
        """Sauvegarde rapport de d√©ploiement"""
        try:
            reports_dir = Path("reports/deployment")
            reports_dir.mkdir(parents=True, exist_ok=True)
            
            report_file = reports_dir / f"deployment_report_{self.deployment_id}.json"
            
            # Convert to dict for JSON serialization
            report_dict = asdict(report)
            
            # Convert datetime objects to ISO strings
            for key, value in report_dict.items():
                if isinstance(value, datetime):
                    report_dict[key] = value.isoformat()
            
            # Convert nested datetime objects
            for check_list_name in ['pre_checks', 'health_checks', 'post_checks']:
                for check in report_dict.get(check_list_name, []):
                    if 'timestamp' in check and isinstance(check['timestamp'], datetime):
                        check['timestamp'] = check['timestamp'].isoformat()
            
            with open(report_file, 'w') as f:
                json.dump(report_dict, f, indent=2, default=str)
            
            logger.info(f"üìã Rapport sauvegard√©: {report_file}")
            
        except Exception as e:
            logger.error(f"‚ùå Erreur sauvegarde rapport: {e}")

# === FACTORY FUNCTIONS ===

def create_deployment_config(mode: str, **kwargs) -> DeploymentConfig:
    """Factory pour configuration d√©ploiement"""
    mode_enum = DeploymentMode(mode)
    return DeploymentConfig(mode=mode_enum, **kwargs)

def deploy_validation_only() -> DeploymentReport:
    """D√©ploiement validation seulement"""
    config = create_deployment_config(
        mode="validation",
        enable_live_execution=False,
        require_manual_approval=False
    )
    
    deployer = LiveDeployer(config)
    return deployer.deploy()

def deploy_paper_to_live(max_position_size: int = 1, daily_loss_limit: float = 500.0) -> DeploymentReport:
    """D√©ploiement transition paper ‚Üí live"""
    config = create_deployment_config(
        mode="paper_to_live",
        max_position_size=max_position_size,
        daily_loss_limit=daily_loss_limit,
        enable_live_execution=True,
        require_manual_approval=True,
        paper_trading_first=True
    )
    
    deployer = LiveDeployer(config)
    return deployer.deploy()

def deploy_cold_start() -> DeploymentReport:
    """D√©ploiement √† froid complet"""
    config = create_deployment_config(
        mode="cold_start",
        backup_before_deployment=True,
        enable_circuit_breakers=True
    )
    
    deployer = LiveDeployer(config)
    return deployer.deploy()

def emergency_stop_all() -> bool:
    """Arr√™t d'urgence tous syst√®mes"""
    logger.error("üö® EMERGENCY STOP TRIGGERED")
    
    try:
        # Kill processus MIA_IA_SYSTEM
        current_pid = os.getpid()
        
        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                if proc.info['cmdline']:
                    cmdline = ' '.join(proc.info['cmdline'])
                    if any(keyword in cmdline.lower() for keyword in ['automation_main', 'simple_trader', 'mia_ia']):
                        if proc.info['pid'] != current_pid:
                            logger.warning(f"üî™ Killing process {proc.info['pid']}: {cmdline[:50]}")
                            proc.terminate()
                            
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                pass
        
        # Health check d'urgence
        if SYSTEM_INTEGRATION:
            emergency_health_check()
        
        logger.info("‚úÖ Emergency stop completed")
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Emergency stop error: {e}")
        return False

# === INTERFACE LIGNE DE COMMANDE ===

def main():
    """Interface ligne de commande"""
    parser = argparse.ArgumentParser(
        description="üöÄ MIA_IA_SYSTEM Live Deployment",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Exemples d'utilisation:

  # Validation compl√®te sans d√©ploiement
  python scripts/deploy_live.py --mode validation

  # D√©ploiement paper trading ‚Üí live trading
  python scripts/deploy_live.py --mode paper_to_live --position-size 1 --daily-limit 500

  # D√©ploiement √† froid complet
  python scripts/deploy_live.py --mode cold_start --live --backup

  # Arr√™t d'urgence tous syst√®mes
  python scripts/deploy_live.py --emergency-stop

  # Status health check rapide
  python scripts/deploy_live.py --health-check
        """
    )
    
    # Mode de d√©ploiement
    parser.add_argument('--mode', choices=['validation', 'paper_to_live', 'cold_start', 'hot_upgrade'],
                       default='validation', help='Mode de d√©ploiement')
    
    # Configuration
    parser.add_argument('--live', action='store_true', help='Enable live execution (REAL MONEY)')
    parser.add_argument('--position-size', type=int, default=1, help='Max position size')
    parser.add_argument('--daily-limit', type=float, default=500.0, help='Daily loss limit ($)')
    parser.add_argument('--no-approval', action='store_true', help='Skip manual approval')
    parser.add_argument('--no-backup', action='store_true', help='Skip backup creation')
    parser.add_argument('--no-rollback', action='store_true', help='Disable automatic rollback')
    
    # Actions sp√©ciales
    parser.add_argument('--emergency-stop', action='store_true', help='Emergency stop all systems')
    parser.add_argument('--health-check', action='store_true', help='Run health check only')
    parser.add_argument('--report', help='Show deployment report (ID)')
    
    # Options avanc√©es
    parser.add_argument('--timeout', type=int, default=30, help='Deployment timeout (minutes)')
    parser.add_argument('--config-file', help='Custom configuration file')
    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose logging')
    
    args = parser.parse_args()
    
    # Configure logging
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    try:
        print("üöÄ MIA_IA_SYSTEM LIVE DEPLOYMENT SYSTEM")
        print("=" * 60)
        
        # Actions sp√©ciales
        if args.emergency_stop:
            print("üö® EMERGENCY STOP REQUESTED")
            success = emergency_stop_all()
            return 0 if success else 1
        
        if args.health_check:
            print("üè• HEALTH CHECK RAPIDE")
            if SYSTEM_INTEGRATION:
                is_safe = emergency_health_check()
                return 0 if is_safe else 1
            else:
                print("‚ö†Ô∏è Health check non disponible (int√©gration limit√©e)")
                return 1
        
        if args.report:
            print(f"üìã DEPLOYMENT REPORT: {args.report}")
            report_file = Path(f"reports/deployment/deployment_report_{args.report}.json")
            if report_file.exists():
                with open(report_file) as f:
                    report_data = json.load(f)
                print(json.dumps(report_data, indent=2))
                return 0
            else:
                print(f"‚ùå Report not found: {report_file}")
                return 1
        
        # Configuration d√©ploiement
        config = DeploymentConfig(
            mode=DeploymentMode(args.mode),
            enable_live_execution=args.live,
            max_position_size=args.position_size,
            daily_loss_limit=args.daily_limit,
            require_manual_approval=not args.no_approval,
            backup_before_deployment=not args.no_backup,
            enable_rollback=not args.no_rollback,
            max_deployment_time_minutes=args.timeout
        )
        
        # Warnings pour live trading
        if args.live:
            print("‚ö†Ô∏è" * 20)
            print("üö® LIVE TRADING MODE - REAL MONEY AT RISK")
            print("‚ö†Ô∏è" * 20)
            print(f"Max Position Size: {args.position_size}")
            print(f"Daily Loss Limit: ${args.daily_limit}")
            print("‚ö†Ô∏è" * 20)
            
            if not args.no_approval:
                confirmation = input("Type 'I UNDERSTAND THE RISKS' to continue: ")
                if confirmation != "I UNDERSTAND THE RISKS":
                    print("‚ùå Deployment cancelled")
                    return 1
        
        # Ex√©cution d√©ploiement
        print(f"üöÄ Starting deployment: {args.mode}")
        print(f"Target: {'LIVE TRADING' if args.live else 'PAPER TRADING'}")
        print("=" * 60)
        
        deployer = LiveDeployer(config)
        report = deployer.deploy()
        
        # Affichage r√©sultats
        print("\n" + "=" * 60)
        print("üìä DEPLOYMENT RESULTS")
        print("=" * 60)
        print(f"Status: {report.overall_status.value.upper()}")
        print(f"Duration: {report.total_execution_time_seconds:.1f}s")
        print(f"Components Deployed: {len(report.components_deployed)}")
        print(f"Components Failed: {len(report.components_failed)}")
        print(f"Health Score: {report.health_score_post_deployment:.1f}%")
        print(f"Rollback Triggered: {report.rollback_triggered}")
        
        if report.components_deployed:
            print(f"‚úÖ Deployed: {', '.join(report.components_deployed)}")
        
        if report.components_failed:
            print(f"‚ùå Failed: {', '.join(report.components_failed)}")
        
        # Checks summary
        total_checks = len(report.pre_checks) + len(report.health_checks)
        passed_checks = len([c for c in report.pre_checks + report.health_checks 
                           if c.status == DeploymentStatus.SUCCESS])
        
        print(f"üìã Checks: {passed_checks}/{total_checks} passed")
        
        if report.overall_status == DeploymentStatus.SUCCESS:
            print("\nüéâ DEPLOYMENT SUCCESSFUL!")
            if SYSTEM_INTEGRATION and not args.live:
                print("üåê Health Dashboard: http://127.0.0.1:8080")
            
            return 0
        else:
            print(f"\n‚ùå DEPLOYMENT FAILED: {report.overall_status.value}")
            return 1
        
    except KeyboardInterrupt:
        print("\nüõë Deployment cancelled by user")
        return 1
    except Exception as e:
        print(f"\n‚ùå Deployment error: {e}")
        logger.exception("Deployment exception:")
        return 1

if __name__ == "__main__":
    sys.exit(main())