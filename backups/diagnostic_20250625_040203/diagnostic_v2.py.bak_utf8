#!/usr/bin/env python3
"""
MIA_IA_SYSTEM - Diagnostic Complet et Correction Automatique v2.0
Scanner exhaustif avec correction automatique de tous les probl√®mes
"""

import os
import sys
import re
import ast
import json
import shutil
import subprocess
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Set, Tuple, Optional, Any
import importlib.util
import logging

# Configure logging
logger = logging.getLogger(__name__)


class CompleteProjectDiagnostic:
    """Diagnostic exhaustif et correction automatique du projet"""
    
    def __init__(self, project_root: str = "D:\\MIA_IA_system"):
        self.project_root = Path(project_root)
        self.errors = []
        self.warnings = []
        self.fixes_applied = []
        self.backup_dir = self.project_root / "backups" / f"diagnostic_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        # Configuration des corrections connues
        self.import_fixes = {
            'StructureData': {
                'correct_import': 'from core.structure_data import StructureData',
                'wrong_patterns': [
                    r"from core\.base_types import.*StructureData",
                    r"from core import.*StructureData"
                ]
            },
            'ValidationMethod': {
                'correct_import': 'from ml.model_validator import ValidationMethod',
                'files_needing': ['ml_config.py']
            },
            'SignalDecision': {
                'correct_import': 'from strategies.signal_generator import SignalDecision',
                'alternative': 'from core.base_types import TradingDecision'
            }
        }
        
        # Classes √† cr√©er si manquantes
        self.missing_classes = {
            'ContractConfig': {
                'file': 'config/sierra_config.py',
                'code': '''
@dataclass
class ContractConfig:
    """Configuration contrat trading"""
    symbol: str = "ES"
    exchange: str = "CME"
    multiplier: float = 50.0
    tick_size: float = 0.25
    tick_value: float = 12.50
    trading_hours: str = "17:00-16:00"
    timezone: str = "America/Chicago"
'''
            },
            'DataCollectionConfig': {
                'file': 'config/automation_config.py',
                'code': '''
@dataclass
class DataCollectionConfig:
    """Configuration collecte donn√©es"""
    enabled: bool = True
    symbols: List[str] = field(default_factory=lambda: ["ES", "NQ"])
    save_snapshots: bool = True
    snapshot_interval: int = 60
    max_snapshots_per_day: int = 1000
    compress_old_data: bool = True
    retention_days: int = 30
'''
            },
            'PatternsDetector': {
                'file': 'core/patterns_detector.py',
                'code': '''
class PatternsDetector:
    """D√©tecteur de patterns trading"""
    
    def __init__(self):
        self.patterns = ["battle_navale", "gamma_pin", "headfake", "microstructure", "confluence"]
        self.min_confidence = 0.7
        
    def detect_patterns(self, market_data, structure_data=None):
        """D√©tecte les patterns dans les donn√©es"""
        detected = []
        # Logique de d√©tection basique
        return detected
        
    def get_pattern_confidence(self, pattern_name: str) -> float:
        """Retourne la confiance d'un pattern"""
        return 0.8  # Valeur par d√©faut
'''
            }
        }
        
        # Modules Python requis
        self.required_packages = [
            'schedule', 'pandas', 'numpy', 'scipy', 'scikit-learn',
            'matplotlib', 'seaborn', 'discord.py', 'python-dotenv',
            'requests', 'websocket-client', 'joblib'
        ]
        
    def run_complete_diagnostic(self):
        """Lance le diagnostic complet avec toutes les v√©rifications"""
        print("\n" + "="*80)
        logger.debug("DIAGNOSTIC COMPLET MIA_IA_SYSTEM v2.0")
        print("="*80)
        
        # 1. Cr√©er backup complet
        logger.info("\nüì¶ √âTAPE 1: Cr√©ation du backup...")
        self.create_complete_backup()
        
        # 2. V√©rifier environnement Python
        logger.info("\nüêç √âTAPE 2: V√©rification environnement Python...")
        self.check_python_environment()
        
        # 3. V√©rifier et installer packages
        logger.info("\nüì¶ √âTAPE 3: V√©rification des packages...")
        self.check_and_install_packages()
        
        # 4. Scanner structure du projet
        logger.info("\nüìÅ √âTAPE 4: V√©rification structure du projet...")
        self.check_project_structure()
        
        # 5. Scanner tous les fichiers Python
        logger.info("\nüîç √âTAPE 5: Scan de tous les fichiers Python...")
        self.scan_all_python_files()
        
        # 6. V√©rifier les imports circulaires
        logger.info("\nüîÑ √âTAPE 6: D√©tection imports circulaires...")
        self.check_circular_imports()
        
        # 7. Corriger tous les probl√®mes
        logger.info("\nüîß √âTAPE 7: Application des corrections...")
        self.apply_all_fixes()
        
        # 8. V√©rifier les fichiers de configuration
        logger.info("\n‚öôÔ∏è √âTAPE 8: V√©rification fichiers config...")
        self.check_config_files()
        
        # 9. Test d'import de tous les modules
        logger.info("\n‚úÖ √âTAPE 9: Test imports modules...")
        self.test_all_imports()
        
        # 10. G√©n√©rer rapport complet
        logger.info("\nüìä √âTAPE 10: G√©n√©ration du rapport...")
        self.generate_complete_report()
        
    def create_complete_backup(self):
        """Cr√©e un backup complet du projet"""
        try:
            self.backup_dir.mkdir(parents=True, exist_ok=True)
            
            # Copier tous les fichiers importants
            extensions = ['.py', '.json', '.txt', '.md', '.env']
            files_backed_up = 0
            
            for ext in extensions:
                for file in self.project_root.rglob(f"*{ext}"):
                    if any(skip in str(file) for skip in ['backup', '__pycache__', '.git', 'venv']):
                        continue
                    
                    relative_path = file.relative_to(self.project_root)
                    backup_path = self.backup_dir / relative_path
                    backup_path.parent.mkdir(parents=True, exist_ok=True)
                    shutil.copy2(file, backup_path)
                    files_backed_up += 1
            
            logger.info("Backup cr√©√©: {self.backup_dir}")
            logger.info("   {files_backed_up} fichiers sauvegard√©s")
            
        except Exception as e:
            logger.error("Erreur backup: {e}")
            
    def check_python_environment(self):
        """V√©rifie l'environnement Python"""
        logger.info("Python version: {sys.version}")
        logger.info("Python path: {sys.executable}")
        
        # V√©rifier encoding par d√©faut
        if sys.platform == "win32":
            logger.info("Encoding par d√©faut: {sys.getdefaultencoding()}")
            logger.warning("Windows d√©tect√© - Configuration UTF-8 n√©cessaire")
            
    def check_and_install_packages(self):
        """V√©rifie et installe les packages manquants"""
        missing_packages = []
        
        for package in self.required_packages:
            try:
                if package == 'discord.py':
                    importlib.import_module('discord')
                else:
                    importlib.import_module(package.replace('-', '_'))
                logger.info("{package}")
            except ImportError:
                missing_packages.append(package)
                logger.error("{package} - MANQUANT")
                
        if missing_packages:
            logger.info("\nüì¶ Installation de {len(missing_packages)} packages...")
            for package in missing_packages:
                try:
                    subprocess.check_call([sys.executable, "-m", "pip", "install", package])
                    logger.info("{package} install√©")
                except:
                    self.errors.append(f"Impossible d'installer {package}")
                    
    def check_project_structure(self):
        """V√©rifie que tous les dossiers existent"""
        required_dirs = [
            'config', 'core', 'features', 'strategies', 'execution',
            'monitoring', 'data', 'ml', 'performance', 'config_files',
            'logs', 'tests', 'docs', 'scripts',
            'data/snapshots/daily', 'data/snapshots/weekly', 'data/snapshots/archive',
            'data/models/trained', 'data/models/experimental', 'data/models/backup',
            'logs/trades/daily', 'logs/system/automation', 'logs/performance'
        ]
        
        for dir_path in required_dirs:
            full_path = self.project_root / dir_path
            if not full_path.exists():
                full_path.mkdir(parents=True, exist_ok=True)
                logger.info("Cr√©√©: {dir_path}")
                
    def scan_all_python_files(self):
        """Scanne tous les fichiers Python du projet"""
        python_files = list(self.project_root.rglob("*.py"))
        total_files = len(python_files)
        
        logger.info("\nüìÑ Scan de {total_files} fichiers Python...")
        
        for i, file_path in enumerate(python_files, 1):
            if any(skip in str(file_path) for skip in ['backup', '__pycache__', 'venv']):
                continue
                
            print(f"\r[{i}/{total_files}] {file_path.name}...", end='', flush=True)
            self.scan_python_file(file_path)
            
        logger.info("\n‚úÖ Scan termin√©: {len(self.errors)} erreurs, {len(self.warnings)} warnings")
        
    def scan_python_file(self, file_path: Path):
        """Scanne un fichier Python pour tous les probl√®mes"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            # 1. V√©rifier syntaxe
            self.check_syntax(file_path, content)
            
            # 2. V√©rifier imports
            self.check_imports(file_path, content)
            
            # 3. V√©rifier classes/fonctions manquantes
            self.check_missing_definitions(file_path, content)
            
            # 4. V√©rifier probl√®mes d'encodage
            self.check_encoding_issues(file_path, content)
            
            # 5. V√©rifier structure sp√©cifique
            self.check_specific_patterns(file_path, content)
            
        except Exception as e:
            self.errors.append({
                'file': str(file_path),
                'type': 'file_error',
                'error': str(e)
            })
            
    def check_syntax(self, file_path: Path, content: str):
        """V√©rifie la syntaxe du fichier"""
        try:
            ast.parse(content)
        except SyntaxError as e:
            self.errors.append({
                'file': str(file_path),
                'type': 'syntax_error',
                'line': e.lineno,
                'error': e.msg
            })
            
    def check_imports(self, file_path: Path, content: str):
        """V√©rifie tous les imports"""
        # V√©rifier StructureData
        if 'StructureData' in content:
            for pattern in self.import_fixes['StructureData']['wrong_patterns']:
                if re.search(pattern, content):
                    self.errors.append({
                        'file': str(file_path),
                        'type': 'wrong_import',
                        'fix_type': 'StructureData',
                        'error': 'Import incorrect de StructureData'
                    })
                    
        # V√©rifier ValidationMethod dans ml_config.py
        if file_path.name == 'ml_config.py' and 'ValidationMethod' in content:
            if 'from ml.model_validator import ValidationMethod' not in content:
                self.errors.append({
                    'file': str(file_path),
                    'type': 'missing_import',
                    'fix_type': 'ValidationMethod',
                    'error': 'Import manquant: ValidationMethod'
                })
                
        # V√©rifier set_sierra_config
        if 'set_sierra_config' in content and 'def set_sierra_config' not in content:
            self.errors.append({
                'file': str(file_path),
                'type': 'undefined_function',
                'function': 'set_sierra_config',
                'error': 'Utilisation de set_sierra_config non d√©finie'
            })
            
    def check_missing_definitions(self, file_path: Path, content: str):
        """V√©rifie les classes/fonctions manquantes"""
        for class_name, info in self.missing_classes.items():
            if file_path.name == Path(info['file']).name:
                if f"class {class_name}" not in content:
                    self.errors.append({
                        'file': str(file_path),
                        'type': 'missing_class',
                        'class': class_name,
                        'error': f'Classe {class_name} manquante'
                    })
                    
    def check_encoding_issues(self, file_path: Path, content: str):
        """V√©rifie les probl√®mes d'encodage"""
        # D√©tecter les emojis dans les logs
        emoji_pattern = r'[\U0001F000-\U0001FFFF]'
        if re.search(emoji_pattern, content) and 'sys.stdout = io.TextIOWrapper' not in content:
            if file_path.name in ['automation_main.py', '__init__.py', 'main.py']:
                self.warnings.append({
                    'file': str(file_path),
                    'type': 'encoding_issue',
                    'warning': 'Emojis d√©tect√©s sans configuration UTF-8'
                })
                
    def check_specific_patterns(self, file_path: Path, content: str):
        """V√©rifie des patterns sp√©cifiques"""
        # V√©rifier les TODO/FIXME
        todos = re.findall(r'#\s*(TODO|FIXME).*', content)
        if todos:
            self.warnings.append({
                'file': str(file_path),
                'type': 'todo',
                'count': len(todos),
                'items': todos[:3]  # Premiers 3 seulement
            })
            
    def check_circular_imports(self):
        """D√©tecte les imports circulaires"""
        import_graph = {}
        
        # Construire le graphe des imports
        for py_file in self.project_root.rglob("*.py"):
            if any(skip in str(py_file) for skip in ['backup', '__pycache__', 'venv']):
                continue
                
            try:
                with open(py_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                    
                # Extraire les imports
                imports = re.findall(r'from\s+([\w.]+)\s+import', content)
                imports.extend(re.findall(r'import\s+([\w.]+)', content))
                
                module_name = str(py_file.relative_to(self.project_root)).replace('\\', '.').replace('/', '.')[:-3]
                import_graph[module_name] = imports
                
            except:
                pass
                
        # D√©tecter les cycles (simplifi√©e)
        # Note: Une vraie d√©tection de cycles n√©cessiterait un algorithme plus complexe
        logger.info("V√©rification basique des imports circulaires effectu√©e")
        
    def apply_all_fixes(self):
        """Applique toutes les corrections automatiques"""
        logger.info("\nüîß Application de {len(self.errors)} corrections...")
        
        for error in self.errors:
            try:
                if error['type'] == 'wrong_import':
                    self.fix_wrong_import(error)
                elif error['type'] == 'missing_import':
                    self.fix_missing_import(error)
                elif error['type'] == 'undefined_function':
                    self.fix_undefined_function(error)
                elif error['type'] == 'missing_class':
                    self.fix_missing_class(error)
            except Exception as e:
                logger.error("Erreur correction {error['file']}: {e}")
                
        # Corriger les warnings d'encodage
        for warning in self.warnings:
            if warning['type'] == 'encoding_issue':
                self.fix_encoding_issue(warning)
                
    def fix_wrong_import(self, error: Dict):
        """Corrige un import incorrect"""
        file_path = Path(error['file'])
        
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
            
        if error['fix_type'] == 'StructureData':
            # Remplacer les patterns incorrects
            for pattern in self.import_fixes['StructureData']['wrong_patterns']:
                content = re.sub(pattern, self.import_fixes['StructureData']['correct_import'], content)
                
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
            
        self.fixes_applied.append(f"‚úÖ {file_path.name}: Import StructureData corrig√©")
        
    def fix_missing_import(self, error: Dict):
        """Ajoute un import manquant"""
        file_path = Path(error['file'])
        
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
            
        if error['fix_type'] == 'ValidationMethod':
            # Trouver o√π ins√©rer l'import
            import_pos = content.rfind('import')
            if import_pos != -1:
                line_end = content.find('\n', import_pos)
                new_content = (
                    content[:line_end + 1] +
                    "\n# Import ajout√© automatiquement\n" +
                    "from ml.model_validator import ValidationMethod\n" +
                    content[line_end + 1:]
                )
                
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(new_content)
                    
                self.fixes_applied.append(f"‚úÖ {file_path.name}: Import ValidationMethod ajout√©")
                
    def fix_undefined_function(self, error: Dict):
        """Corrige les fonctions non d√©finies"""
        if error['function'] == 'set_sierra_config':
            file_path = Path(error['file'])
            
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            # Retirer set_sierra_config des imports
            content = re.sub(r',\s*set_sierra_config', '', content)
            content = re.sub(r'set_sierra_config\s*,', '', content)
            
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
                
            self.fixes_applied.append(f"‚úÖ {file_path.name}: set_sierra_config retir√©")
            
    def fix_missing_class(self, error: Dict):
        """Ajoute une classe manquante"""
        file_path = Path(error['file'])
        class_name = error['class']
        
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
            
        # V√©rifier les imports n√©cessaires
        if 'from dataclasses import dataclass' not in content and '@dataclass' in self.missing_classes[class_name]['code']:
            content = "from dataclasses import dataclass, field\nfrom typing import List\n\n" + content
            
        # Ajouter la classe
        content += f"\n\n{self.missing_classes[class_name]['code']}\n"
        
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
            
        self.fixes_applied.append(f"‚úÖ {file_path.name}: Classe {class_name} ajout√©e")
        
    def fix_encoding_issue(self, warning: Dict):
        """Corrige les probl√®mes d'encodage"""
        file_path = Path(warning['file'])
        
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
            
        # Ajouter configuration UTF-8
        if 'import sys' not in content:
            utf8_config = """# Configuration encodage UTF-8
import sys
import io
import codecs

# Configuration plus robuste de l'encodage UTF-8
if sys.platform == "win32":
    # √âviter de reconfigurer si d√©j√† fait
    if hasattr(sys.stdout, 'reconfigure'):
        sys.stdout.reconfigure(encoding='utf-8')
        sys.stderr.reconfigure(encoding='utf-8')
    else:
        # Fallback pour Python < 3.7
        try:
            sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'strict')
            sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'strict')
        except:
            # Si erreur, ne rien faire (√©viter le crash)
            pass

"""
            # Ins√©rer apr√®s les imports
            import_end = content.find('\n\n')
            if import_end != -1:
                content = content[:import_end] + '\n' + utf8_config + content[import_end:]
            else:
                content = utf8_config + content
                
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
                
            self.fixes_applied.append(f"‚úÖ {file_path.name}: Configuration UTF-8 ajout√©e")
            
    def check_config_files(self):
        """V√©rifie tous les fichiers de configuration JSON"""
        config_dir = self.project_root / 'config_files'
        
        for json_file in config_dir.glob("*.json"):
            try:
                with open(json_file, 'r', encoding='utf-8') as f:
                    json.load(f)
                logger.info("{json_file.name}")
            except json.JSONDecodeError as e:
                self.errors.append({
                    'file': str(json_file),
                    'type': 'json_error',
                    'error': str(e)
                })
                logger.error("{json_file.name}: Erreur JSON")
                
    def test_all_imports(self):
        """Teste l'import de tous les modules principaux"""
        modules_to_test = [
            'config', 'core', 'features', 'strategies',
            'execution', 'monitoring', 'data', 'ml', 'performance'
        ]
        
        logger.info("\nüß™ Test des imports principaux...")
        
        for module in modules_to_test:
            try:
                spec = importlib.util.spec_from_file_location(
                    module,
                    self.project_root / module / "__init__.py"
                )
                if spec and spec.loader:
                    module_obj = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module_obj)
                    logger.info("{module}")
            except Exception as e:
                logger.error("{module}: {type(e).__name__}")
                self.errors.append({
                    'module': module,
                    'type': 'import_error',
                    'error': str(e)
                })
                
    def generate_complete_report(self):
        """G√©n√®re un rapport complet du diagnostic"""
        report = {
            'timestamp': datetime.now().isoformat(),
            'project_root': str(self.project_root),
            'backup_location': str(self.backup_dir),
            'python_version': sys.version,
            'total_files_scanned': len(list(self.project_root.rglob("*.py"))),
            'errors': self.errors,
            'warnings': self.warnings,
            'fixes_applied': self.fixes_applied,
            'summary': {
                'total_errors': len(self.errors),
                'total_warnings': len(self.warnings),
                'total_fixes': len(self.fixes_applied),
                'errors_by_type': self._count_by_type(self.errors),
                'warnings_by_type': self._count_by_type(self.warnings, 'type')
            }
        }
        
        # Sauvegarder le rapport
        report_file = self.project_root / f"diagnostic_complet_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
            
        # Afficher le r√©sum√©
        print("\n" + "="*80)
        logger.info("üìä R√âSUM√â DU DIAGNOSTIC")
        print("="*80)
        logger.info("\nüìÅ Projet: {self.project_root}")
        logger.info("üì¶ Backup: {self.backup_dir}")
        logger.info("\nüîç Fichiers scann√©s: {report['total_files_scanned']}")
        logger.error("Erreurs trouv√©es: {len(self.errors)}")
        logger.warning("Warnings: {len(self.warnings)}")
        logger.info("Corrections appliqu√©es: {len(self.fixes_applied)}")
        
        if self.errors:
            logger.info("\n‚ùå Erreurs par type:")
            for error_type, count in report['summary']['errors_by_type'].items():
                logger.info("   - {error_type}: {count}")
                
        if self.fixes_applied:
            logger.info("\n‚úÖ Corrections appliqu√©es:")
            for fix in self.fixes_applied[:10]:  # Afficher max 10
                logger.info("   {fix}")
            if len(self.fixes_applied) > 10:
                logger.info("   ... et {len(self.fixes_applied) - 10} autres")
                
        logger.info("\nüìÑ Rapport d√©taill√© sauvegard√©: {report_file.name}")
        
        # Instructions finales
        print("\n" + "="*80)
        logger.info("üéØ PROCHAINES √âTAPES:")
        print("="*80)
        logger.info("1. V√©rifier le rapport d√©taill√© pour les erreurs restantes")
        logger.info("2. Relancer: python automation_main.py")
        logger.info("3. Si erreurs persistent, ex√©cuter ce diagnostic √† nouveau")
        logger.info("4. Backup disponible dans: {self.backup_dir}")
        
    def _count_by_type(self, items: List[Dict], key: str = 'type') -> Dict[str, int]:
        """Compte les √©l√©ments par type"""
        counts = {}
        for item in items:
            item_type = item.get(key, 'unknown')
            counts[item_type] = counts.get(item_type, 0) + 1
        return counts


def main():
    """Point d'entr√©e principal"""
    logger.info("üöÄ MIA_IA_SYSTEM - DIAGNOSTIC COMPLET v2.0")
    print("="*80)
    
    # Configuration
    project_root = input("Chemin du projet (Enter pour D:\\MIA_IA_system): ").strip()
    if not project_root:
        project_root = "D:\\MIA_IA_system"
        
    if not Path(project_root).exists():
        logger.error("Le chemin {project_root} n'existe pas!")
        return
        
    # Confirmation
    logger.info("\nüìÅ Projet √† diagnostiquer: {project_root}")
    response = input("‚ö†Ô∏è  Un backup complet sera cr√©√©. Continuer? (o/n): ")
    
    if response.lower() != 'o':
        logger.error("Diagnostic annul√©")
        return
        
    # Lancer le diagnostic
    diagnostic = CompleteProjectDiagnostic(project_root)
    diagnostic.run_complete_diagnostic()


if __name__ == "__main__":
    main()