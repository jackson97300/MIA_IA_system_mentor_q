"""
MIA_IA_SYSTEM - Structure Updater
Script NON DESTRUCTEUR pour mise à jour structure Phase 3
Version: Safe & Intelligent
Performance: Détection automatique + Backup
"""

import os
import sys
import json
import shutil
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Tuple, Optional
import logging

class ProjectStructureUpdater:
    """Mise à jour non destructrice structure projet"""
    
    def __init__(self, project_root: str = "."):
        self.project_root = Path(project_root).absolute()
        self.backup_dir = self.project_root / "backup_structure"
        self.dry_run = False
        
        # Setup logging
        self.setup_logging()
        
        # Validation projet
        if not self.is_mia_project():
            raise ValueError("❌ Ce n'est pas un projet MIA_IA_SYSTEM valide")
        
        self.logger.info(f"✅ Projet MIA détecté: {self.project_root}")
    
    def setup_logging(self):
        """Setup logging pour traçabilité"""
        log_file = self.project_root / "structure_update.log"
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file),
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def is_mia_project(self) -> bool:
        """Vérification que c'est bien le projet MIA"""
        required_markers = [
            "core/battle_navale.py",
            "config/trading_config.py",
            "features/feature_calculator.py"
        ]
        
        for marker in required_markers:
            if not (self.project_root / marker).exists():
                return False
        
        return True
    
    def create_backup(self):
        """Backup structure actuelle par sécurité"""
        if self.dry_run:
            self.logger.info("🔍 [DRY RUN] Backup serait créé")
            return
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = self.backup_dir / f"backup_{timestamp}"
        
        try:
            # Créer dossier backup
            backup_path.mkdir(parents=True, exist_ok=True)
            
            # Copier structure actuelle (sans les gros fichiers)
            for item in self.project_root.iterdir():
                if item.name in ['.git', '__pycache__', 'backup_structure', '.env']:
                    continue
                
                if item.is_dir():
                    shutil.copytree(item, backup_path / item.name, 
                                  ignore=shutil.ignore_patterns('*.pyc', '__pycache__'))
                elif item.suffix in ['.py', '.json', '.md', '.txt']:
                    shutil.copy2(item, backup_path / item.name)
            
            self.logger.info(f"✅ Backup créé: {backup_path}")
            return backup_path
            
        except Exception as e:
            self.logger.error(f"❌ Erreur backup: {e}")
            return None
    
    def get_new_structure(self) -> Dict[str, List[str]]:
        """Définition nouvelle structure Phase 3"""
        return {
            # Nouveaux dossiers
            "monitoring": [
                "__init__.py",
                "live_monitor.py",
                "performance_tracker.py", 
                "alert_system.py"
            ],
            "docs": [
                "__init__.py",
                "architecture.md",
                "automation_guide.md",
                "data_collection_guide.md",
                "ml_strategy.md",
                "deployment_guide.md"
            ],
            "scripts": [
                "__init__.py",
                "start_automation.py",
                "backup_data.py",
                "analyze_performance.py",
                "train_models.py",
                "deploy_live.py"
            ],
            
            # Enrichissement dossiers existants
            "execution": [
                "simple_trader.py",
                "trade_snapshotter.py"
            ],
            "data": [
                "data_collector.py",
                "market_data_feed.py"
            ],
            "ml": [
                "data_processor.py",
                "model_validator.py"
            ],
            "config": [
                "automation_config.py",
                "ml_config.py"
            ],
            "performance": [
                "automation_metrics.py"
            ],
            
            # Nouveaux sous-dossiers
            "data/snapshots": [],
            "data/snapshots/daily": [],
            "data/snapshots/archive": [],
            "data/live": [],
            "data/live/current_session": [],
            "data/live/daily_archives": [],
            "data/live/performance_data": [],
            "logs/live_trading": [],
            "logs/live_trading/execution": [],
            "logs/live_trading/risk_management": [],
            "logs/live_trading/alerts": [],
            "logs/trades/snapshots": [],
            "logs/system/automation": [],
            "logs/system/monitoring": [],
            "tests/test_execution": [
                "__init__.py",
                "test_simple_trader.py",
                "test_trade_snapshotter.py"
            ],
            "tests/test_monitoring": [
                "__init__.py", 
                "test_live_monitor.py",
                "test_performance_tracker.py",
                "test_alert_system.py"
            ],
            "tests/test_ml": [
                "__init__.py",
                "test_simple_model.py",
                "test_data_processor.py",
                "test_model_validator.py"
            ],
            "config_files": [
                "automation_params.json",
                "ml_training_config.json",
                "monitoring_config.json"
            ]
        }
    
    def create_directory_structure(self) -> Dict[str, int]:
        """Création structure dossiers"""
        structure = self.get_new_structure()
        stats = {"directories_created": 0, "files_created": 0, "skipped": 0}
        
        for dir_path, files in structure.items():
            full_dir_path = self.project_root / dir_path
            
            # Créer dossier si n'existe pas
            if not full_dir_path.exists():
                if not self.dry_run:
                    full_dir_path.mkdir(parents=True, exist_ok=True)
                    self.logger.info(f"📁 Créé dossier: {dir_path}")
                    stats["directories_created"] += 1
                else:
                    self.logger.info(f"🔍 [DRY RUN] Créerait dossier: {dir_path}")
            else:
                self.logger.info(f"✅ Dossier existe: {dir_path}")
                stats["skipped"] += 1
            
            # Créer fichiers dans le dossier
            for file_name in files:
                file_path = full_dir_path / file_name
                
                if not file_path.exists():
                    if not self.dry_run:
                        self.create_file_template(file_path)
                        stats["files_created"] += 1
                    else:
                        self.logger.info(f"🔍 [DRY RUN] Créerait fichier: {dir_path}/{file_name}")
                else:
                    self.logger.info(f"✅ Fichier existe: {dir_path}/{file_name}")
                    stats["skipped"] += 1
        
        return stats
    
    def create_file_template(self, file_path: Path):
        """Création template pour nouveaux fichiers"""
        file_name = file_path.name
        
        # Templates par type de fichier
        if file_name == "__init__.py":
            content = self.get_init_template(file_path.parent.name)
        elif file_name.endswith(".py"):
            content = self.get_python_template(file_name, file_path.parent.name)
        elif file_name.endswith(".json"):
            content = self.get_json_template(file_name)
        elif file_name.endswith(".md"):
            content = self.get_markdown_template(file_name)
        else:
            content = f"# {file_name}\n# Created by structure updater\n"
        
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            self.logger.info(f"📄 Créé fichier: {file_path.relative_to(self.project_root)}")
        except Exception as e:
            self.logger.error(f"❌ Erreur création {file_path}: {e}")
    
    def get_init_template(self, package_name: str) -> str:
        """Template __init__.py selon package"""
        templates = {
            "monitoring": '''"""
MIA_IA_SYSTEM - Monitoring Package
Surveillance temps réel et alertes système
"""

from .live_monitor import LiveMonitor
from .performance_tracker import PerformanceTracker
from .alert_system import AlertSystem

__all__ = ['LiveMonitor', 'PerformanceTracker', 'AlertSystem']
''',
            "docs": '''"""
MIA_IA_SYSTEM - Documentation Package
Documentation structurée du projet
"""

__version__ = "1.0.0"
''',
            "scripts": '''"""
MIA_IA_SYSTEM - Scripts Utilitaires
Scripts automation et maintenance
"""

__version__ = "1.0.0"
'''
        }
        
        return templates.get(package_name, f'''"""
MIA_IA_SYSTEM - {package_name.title()} Package
Package créé automatiquement
"""

__version__ = "1.0.0"
''')
    
    def get_python_template(self, file_name: str, package_name: str) -> str:
        """Template fichiers Python"""
        class_name = ''.join(word.capitalize() for word in file_name[:-3].split('_'))
        
        return f'''"""
MIA_IA_SYSTEM - {file_name}
{class_name} - Phase 3 Implementation
Version: Initial Template
Performance: À optimiser
"""

import time
import logging
from typing import Dict, List, Optional, Any
from dataclasses import dataclass

logger = logging.getLogger(__name__)

class {class_name}:
    """
    {class_name} - Template initial
    
    TODO Phase 3:
    - Implémenter logique métier
    - Ajouter tests unitaires
    - Optimiser performance
    - Ajouter monitoring
    """
    
    def __init__(self):
        self.initialized = False
        self.stats = {{"operations": 0, "errors": 0}}
        logger.info(f"{{self.__class__.__name__}} initialisé")
    
    def initialize(self):
        """Initialisation composant"""
        try:
            # TODO: Implémenter initialisation
            self.initialized = True
            logger.info(f"{{self.__class__.__name__}} prêt")
            return True
        except Exception as e:
            logger.error(f"Erreur initialisation {{self.__class__.__name__}}: {{e}}")
            return False
    
    def process(self, data: Any) -> Optional[Any]:
        """Traitement principal"""
        if not self.initialized:
            logger.warning("Composant non initialisé")
            return None
        
        try:
            # TODO: Implémenter logique
            self.stats["operations"] += 1
            return data
        except Exception as e:
            self.stats["errors"] += 1
            logger.error(f"Erreur traitement: {{e}}")
            return None
    
    def get_stats(self) -> Dict[str, Any]:
        """Statistiques composant"""
        return self.stats.copy()

# Factory function
def create_{file_name[:-3]}() -> {class_name}:
    """Factory pour {class_name}"""
    instance = {class_name}()
    instance.initialize()
    return instance

# Tests basiques
def test_{file_name[:-3]}():
    """Test basique composant"""
    print(f"🔍 Test {{'{class_name}'}}...")
    
    # Test création
    component = create_{file_name[:-3]}()
    assert component.initialized, "Initialisation échouée"
    
    # Test traitement
    result = component.process("test_data")
    assert result is not None, "Traitement échoué"
    
    # Test stats
    stats = component.get_stats()
    assert stats["operations"] > 0, "Stats incorrectes"
    
    print(f"✅ {{'{class_name}'}} test OK")
    return True

if __name__ == "__main__":
    test_{file_name[:-3]}()
'''
    
    def get_json_template(self, file_name: str) -> str:
        """Template fichiers JSON"""
        templates = {
            "automation_params.json": json.dumps({
                "automation": {
                    "enabled": False,
                    "mode": "paper_trading",
                    "max_position_size": 2,
                    "daily_loss_limit": 500.0,
                    "session_start_hour": 9,
                    "session_end_hour": 16
                },
                "risk_management": {
                    "emergency_stop_enabled": True,
                    "max_drawdown_percent": 15.0,
                    "position_sizing_method": "fixed"
                }
            }, indent=2),
            
            "ml_training_config.json": json.dumps({
                "model": {
                    "type": "linear",
                    "retrain_frequency": 50,
                    "min_training_samples": 100
                },
                "features": {
                    "scaling": True,
                    "selection": False,
                    "max_features": 8
                },
                "validation": {
                    "split": 0.2,
                    "cross_validation_folds": 5
                }
            }, indent=2),
            
            "monitoring_config.json": json.dumps({
                "monitoring": {
                    "enabled": True,
                    "update_frequency_seconds": 5,
                    "metrics_retention_days": 30
                },
                "alerts": {
                    "enabled": True,
                    "email_notifications": False,
                    "daily_loss_threshold": 400.0,
                    "system_error_threshold": 3
                }
            }, indent=2)
        }
        
        return templates.get(file_name, '{\n  "created_by": "structure_updater",\n  "timestamp": "' + datetime.now().isoformat() + '"\n}')
    
    def get_markdown_template(self, file_name: str) -> str:
        """Template fichiers Markdown"""
        title = file_name[:-3].replace('_', ' ').title()
        
        return f'''# {title}

**MIA_IA_SYSTEM - Phase 3 Documentation**

## Overview

Documentation pour {title} du système MIA_IA_SYSTEM.

## Table des Matières

1. [Introduction](#introduction)
2. [Architecture](#architecture)
3. [Configuration](#configuration)
4. [Utilisation](#utilisation)
5. [Troubleshooting](#troubleshooting)

## Introduction

TODO: Compléter documentation

## Architecture

TODO: Décrire architecture

## Configuration

TODO: Paramètres configuration

## Utilisation

TODO: Guide utilisation

## Troubleshooting

TODO: Solutions problèmes courants

---

*Créé automatiquement par structure updater - {datetime.now().strftime("%Y-%m-%d")}*
'''
    
    def create_new_main_files(self):
        """Création nouveaux points d'entrée"""
        main_files = {
            "automation_main.py": '''"""
MIA_IA_SYSTEM - Automation Main Entry Point
Point d'entrée principal pour automation trading
"""

import sys
import logging
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.absolute()
sys.path.insert(0, str(project_root))

from config.automation_config import get_automation_config
from execution.simple_trader import SimpleBattleNavaleTrader
from monitoring.live_monitor import LiveMonitor

def main():
    """Point d'entrée automation"""
    print("🚀 MIA_IA_SYSTEM - Automation Mode")
    
    # Load config
    config = get_automation_config()
    
    if not config.automation.enabled:
        print("❌ Automation désactivée dans config")
        return False
    
    # Initialize components
    trader = SimpleBattleNavaleTrader(mode=config.automation.mode)
    monitor = LiveMonitor()
    
    # Start automation
    try:
        print("✅ Démarrage automation...")
        trader.run_trading_session()
    except KeyboardInterrupt:
        print("🛑 Arrêt automation par utilisateur")
    except Exception as e:
        print(f"❌ Erreur automation: {e}")
        return False
    
    return True

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
''',
            
            "data_collection_main.py": '''"""
MIA_IA_SYSTEM - Data Collection Main Entry Point
Point d'entrée pour collection données pure
"""

import sys
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.absolute()
sys.path.insert(0, str(project_root))

from data.data_collector import DataCollector
from data.market_data_feed import MarketDataFeed

def main():
    """Point d'entrée data collection"""
    print("📊 MIA_IA_SYSTEM - Data Collection Mode")
    
    # Initialize components
    collector = DataCollector()
    data_feed = MarketDataFeed()
    
    # Start collection
    try:
        print("✅ Démarrage collection données...")
        data_feed.start_collection()
    except KeyboardInterrupt:
        print("🛑 Arrêt collection par utilisateur")
    except Exception as e:
        print(f"❌ Erreur collection: {e}")
        return False
    
    return True

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
'''
        }
        
        for file_name, content in main_files.items():
            file_path = self.project_root / file_name
            
            if not file_path.exists():
                if not self.dry_run:
                    with open(file_path, 'w', encoding='utf-8') as f:
                        f.write(content)
                    self.logger.info(f"📄 Créé: {file_name}")
                else:
                    self.logger.info(f"🔍 [DRY RUN] Créerait: {file_name}")
    
    def create_env_files(self):
        """Création fichiers environnement automation"""
        env_files = {
            ".env.automation": '''# MIA_IA_SYSTEM - Automation Environment
# Configuration pour automation trading

# Trading Mode
TRADING_MODE=paper_trading
AUTOMATION_ENABLED=false

# IBKR Configuration
IBKR_HOST=127.0.0.1
IBKR_PORT=7497
IBKR_CLIENT_ID=1

# Risk Management
MAX_POSITION_SIZE=2
DAILY_LOSS_LIMIT=500.00
EMERGENCY_STOP_ENABLED=true

# Monitoring
MONITORING_ENABLED=true
ALERT_EMAIL=your_email@example.com
LOG_LEVEL=INFO

# Data Collection
SNAPSHOT_ENABLED=true
SNAPSHOT_FREQUENCY=every_trade
DATA_BACKUP_ENABLED=true
''',
            
            ".env.live": '''# MIA_IA_SYSTEM - Live Trading Environment  
# Configuration pour live trading (PRODUCTION)

# Trading Mode
TRADING_MODE=live_trading
AUTOMATION_ENABLED=false

# IBKR Live Configuration
IBKR_HOST=127.0.0.1
IBKR_PORT=7496
IBKR_CLIENT_ID=1

# Risk Management (Conservative)
MAX_POSITION_SIZE=1
DAILY_LOSS_LIMIT=200.00
EMERGENCY_STOP_ENABLED=true

# Monitoring (Strict)
MONITORING_ENABLED=true
ALERT_EMAIL=your_live_email@example.com
LOG_LEVEL=WARNING

# Data Collection (Full)
SNAPSHOT_ENABLED=true
SNAPSHOT_FREQUENCY=every_tick
DATA_BACKUP_ENABLED=true
BACKUP_FREQUENCY=hourly
'''
        }
        
        for file_name, content in env_files.items():
            file_path = self.project_root / file_name
            
            if not file_path.exists():
                if not self.dry_run:
                    with open(file_path, 'w', encoding='utf-8') as f:
                        f.write(content)
                    self.logger.info(f"📄 Créé: {file_name}")
                else:
                    self.logger.info(f"🔍 [DRY RUN] Créerait: {file_name}")
    
    def update_requirements(self):
        """Mise à jour requirements pour automation"""
        new_requirements = """# MIA_IA_SYSTEM - Requirements Automation
# Nouvelles dépendances Phase 3

# Machine Learning Simple
scikit-learn>=1.3.0
joblib>=1.3.0

# Monitoring & Alertes  
psutil>=5.9.0
schedule>=1.2.0

# Data Processing
pyarrow>=12.0.0
fastparquet>=0.8.0

# IBKR Enhanced
ib_insync>=0.9.86

# Logging Enhanced
colorlog>=6.7.0
"""
        
        req_file = self.project_root / "requirements_automation.txt"
        
        if not req_file.exists():
            if not self.dry_run:
                with open(req_file, 'w', encoding='utf-8') as f:
                    f.write(new_requirements)
                self.logger.info("📄 Créé: requirements_automation.txt")
            else:
                self.logger.info("🔍 [DRY RUN] Créerait: requirements_automation.txt")
    
    def generate_report(self, stats: Dict[str, int]) -> str:
        """Génération rapport mise à jour"""
        report = f"""
🎯 RAPPORT MISE À JOUR STRUCTURE PHASE 3
{'='*50}

📊 STATISTIQUES:
• Dossiers créés: {stats['directories_created']}
• Fichiers créés: {stats['files_created']}  
• Éléments ignorés (déjà existants): {stats['skipped']}

📁 NOUVEAUX COMPOSANTS:
• monitoring/ - Surveillance temps réel
• docs/ - Documentation structurée  
• scripts/ - Scripts utilitaires
• data/snapshots/ - Données détaillées trades
• tests/test_execution/ - Tests automation

📄 NOUVEAUX POINTS D'ENTRÉE:
• automation_main.py - Démarrage automation
• data_collection_main.py - Collection données
• .env.automation - Variables automation
• requirements_automation.txt - Dépendances

🎯 PROCHAINES ÉTAPES:
1. Installer: pip install -r requirements_automation.txt
2. Configurer: .env.automation
3. Développer: execution/simple_trader.py
4. Tester: python automation_main.py

✅ STRUCTURE PRÊTE POUR PHASE 3!
"""
        return report
    
    def run_update(self, dry_run: bool = False) -> bool:
        """Exécution mise à jour complète"""
        self.dry_run = dry_run
        
        print(f"🚀 MIA_IA_SYSTEM Structure Updater")
        print(f"{'='*50}")
        print(f"Mode: {'🔍 DRY RUN' if dry_run else '🔥 EXECUTION'}")
        print(f"Projet: {self.project_root}")
        print()
        
        try:
            # 1. Backup sécurité
            if not dry_run:
                backup_path = self.create_backup()
                if not backup_path:
                    self.logger.error("❌ Backup échoué - Arrêt mise à jour")
                    return False
            
            # 2. Création structure
            self.logger.info("📁 Création structure dossiers...")
            stats = self.create_directory_structure()
            
            # 3. Nouveaux points d'entrée
            self.logger.info("📄 Création points d'entrée...")
            self.create_new_main_files()
            
            # 4. Fichiers environnement
            self.logger.info("⚙️ Création fichiers environnement...")
            self.create_env_files()
            
            # 5. Requirements
            self.logger.info("📦 Mise à jour requirements...")
            self.update_requirements()
            
            # 6. Rapport final
            report = self.generate_report(stats)
            print(report)
            
            if not dry_run:
                with open(self.project_root / "structure_update_report.md", 'w', encoding='utf-8') as f:
                    f.write(report)
            
            self.logger.info("🎉 Mise à jour terminée avec succès!")
            return True
            
        except Exception as e:
            self.logger.error(f"❌ Erreur mise à jour: {e}")
            return False

def main():
    """Point d'entrée script"""
    import argparse
    
    parser = argparse.ArgumentParser(description='MIA_IA_SYSTEM Structure Updater')
    parser.add_argument('--dry-run', action='store_true', help='Mode simulation (aucune modification)')
    parser.add_argument('--project-path', default='.', help='Chemin projet (défaut: répertoire actuel)')
    
    args = parser.parse_args()
    
    try:
        updater = ProjectStructureUpdater(args.project_path)
        success = updater.run_update(dry_run=args.dry_run)
        
        if success:
            print("\n🎯 SUCCÈS - Structure mise à jour!")
            if args.dry_run:
                print("💡 Relancez sans --dry-run pour appliquer les modifications")
        else:
            print("\n💀 ÉCHEC - Voir logs pour détails")
        
        return success
        
    except Exception as e:
        print(f"\n❌ ERREUR CRITIQUE: {e}")
        return False

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)