#!/usr/bin/env python3
"""
MIA_IA_SYSTEM - Signal Generator 
🧠 CERVEAU CENTRAL DU BOT - Orchestrateur Signaux Master
Version: Production Ready
Performance: Génération signal complète <5ms

RESPONSABILITÉS CRITIQUES :
1. 🎪 ORCHESTRATION COMPLÈTE - Combine tous vos composants
2. 🎯 DÉCISION INTELLIGENTE - 1 signal final unifié  
3. 🔍 VALIDATION QUALITÉ - Filtres confluence + cohérence
4. ⚡ ADAPTATION RÉGIME - Trend vs Range vs Wait
5. 🛡️ GESTION RISQUE - Position sizing + stops
6. 📊 PERFORMANCE TRACKING - Métriques temps réel

WORKFLOW COMPLET :
MarketData → Features → Régime → Stratégie → Bataille Navale → Confluence → Signal Final

SIGNAUX GÉNÉRÉS :
- LONG_TREND/SHORT_TREND : Setups tendance confirmés
- LONG_RANGE/SHORT_RANGE : Setups range confirmés  
- EXIT_PROFIT/EXIT_STOP : Sorties positions
- NO_SIGNAL : Attendre meilleur setup

INPUT : MarketData + OrderFlow + Options + Structure
OUTPUT : 1 TradingSignal unifié prêt pour exécution
"""

import time
import logging
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Any, Union
from dataclasses import dataclass, field
from enum import Enum
from collections import deque, defaultdict

# === IMPORTS CORE ===
from core.base_types import (
    StructureData,
    MarketData, OrderFlowData, TradingSignal, SignalType, 
    MarketRegime, PatternType, SignalStrength, TradingFeatures,
    ES_TICK_SIZE, ES_TICK_VALUE
)

# === IMPORTS COMPONENTS ===
from features.market_regime import MarketRegimeDetector
try:
    from core.battle_navale import BattleNavaleAnalyzer, BattleNavaleResult
except ImportError:
    from core.battle_navale import BattleNavaleDetector as BattleNavaleAnalyzer

from features.feature_calculator import (
    FeatureCalculator, FeatureCalculationResult, SignalQuality
)
from features.confluence_analyzer import (
    ConfluenceAnalyzer, ConfluenceAnalysis, ConfluenceZone
)
from features.market_regime import (
    MarketRegimeDetector, MarketRegimeData
)
from strategies.trend_strategy import (
    TrendStrategy, TrendSignalData, TrendSignalType
)
from strategies.range_strategy import (
    RangeStrategy, RangeSignalData, RangeSignalType
)

logger = logging.getLogger(__name__)

# === SIGNAL GENERATOR ENUMS ===

class SignalDecision(Enum):
    """Décisions finales possibles"""
    EXECUTE_LONG = "execute_long"
    EXECUTE_SHORT = "execute_short"
    EXIT_POSITION = "exit_position"
    WAIT_BETTER_SETUP = "wait_better_setup"
    INSUFFICIENT_CONFLUENCE = "insufficient_confluence"
    REGIME_UNCLEAR = "regime_unclear"

class SignalSource(Enum):
    """Sources de signaux"""
    BATTLE_NAVALE = "battle_navale"
    TREND_STRATEGY = "trend_strategy"
    RANGE_STRATEGY = "range_strategy"
    CONFLUENCE_FILTER = "confluence_filter"
    RISK_MANAGER = "risk_manager"

class QualityLevel(Enum):
    """Niveaux de qualité signal"""
    PREMIUM = "premium"      # 90-100% - Best setups
    STRONG = "strong"        # 80-89%  - Good setups
    MODERATE = "moderate"    # 70-79%  - Acceptable
    WEAK = "weak"           # 60-69%  - Reduced size
    REJECT = "reject"       # 0-59%   - No trade

# === SIGNAL GENERATOR DATACLASSES ===

@dataclass
class SignalComponents:
    """Composants d'analyse d'un signal"""
    timestamp: pd.Timestamp
    
    # Résultats composants
    features: Optional[FeatureCalculationResult] = None
    battle_navale: Optional[Any] = None  # BattleNavaleResult
    market_regime: Optional[MarketRegimeData] = None
    confluence: Optional[ConfluenceAnalysis] = None
    trend_signal: Optional[TrendSignalData] = None
    range_signal: Optional[RangeSignalData] = None
    
    # Métriques qualité
    overall_confidence: float = 0.0
    confluence_boost: float = 0.0
    regime_alignment: float = 0.0
    
    # Performance
    analysis_time_ms: float = 0.0

@dataclass
class FinalSignal:
    """Signal final généré"""
    timestamp: pd.Timestamp
    decision: SignalDecision
    signal_type: SignalType
    
    # Pricing
    entry_price: float
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    
    # Risk
    position_size: float = 1.0
    risk_reward_ratio: float = 0.0
    
    # Quality metrics
    confidence: float = 0.0
    quality_level: QualityLevel = QualityLevel.WEAK
    confluence_score: float = 0.0
    
    # Sources & reasoning
    primary_source: SignalSource = SignalSource.BATTLE_NAVALE
    reasoning: str = ""
    components: Optional[SignalComponents] = None
    
    # Metadata
    metadata: Dict[str, Any] = field(default_factory=dict)

# === MAIN SIGNAL GENERATOR ===

class SignalGenerator:
    """
    🧠 CERVEAU CENTRAL - Générateur de signaux master
    
    Orchestration complète :
    1. Analyse tous les composants (bataille navale, features, confluence, etc.)
    2. Détermine régime marché et stratégie appropriée
    3. Valide qualité et cohérence des signaux
    4. Génère 1 signal final unifié pour exécution
    
    Performance garantie : <5ms pour analyse complète
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """Initialisation du générateur de signaux"""
        self.config = config or {}
        
        # === COMPOSANTS SYSTÈME ===
        self.feature_calculator = FeatureCalculator(config)
        self.confluence_analyzer = ConfluenceAnalyzer(config)
        self.market_regime = MarketRegimeDetector(config)
        self.battle_navale = BattleNavaleAnalyzer(config)
        self.trend_strategy = TrendStrategy(config)
        self.range_strategy = RangeStrategy(config)
        
        # === PARAMÈTRES GÉNÉRATION ===
        self.min_confidence = self.config.get('min_signal_confidence', 0.70)
        self.min_confluence = self.config.get('min_confluence_score', 0.60)
        self.min_risk_reward = self.config.get('min_risk_reward', 1.5)
        self.max_position_size = self.config.get('max_position_size', 3.0)
        
        # === ÉTAT SYSTÈME ===
        self.last_signal: Optional[FinalSignal] = None
        self.signal_history: deque = deque(maxlen=100)
        self.current_regime: Optional[MarketRegimeData] = None
        
        # === PERFORMANCE TRACKING ===
        self.stats = {
            'signals_generated': 0,
            'signals_executed': 0,
            'avg_generation_time_ms': 0.0,
            'quality_distribution': defaultdict(int),
            'regime_distribution': defaultdict(int),
            'success_by_source': defaultdict(list)
        }
        
        logger.info("SignalGenerator initialisé - Cerveau central prêt")
    
    def generate_signal(self,
                       market_data: MarketData,
                       order_flow: Optional[OrderFlowData] = None,
                       options_data: Optional[Dict[str, Any]] = None,
                       structure_data: Optional[Dict[str, Any]] = None,
                       sierra_patterns: Optional[Dict[str, float]] = None) -> FinalSignal:
        """
        🎯 GÉNÉRATION SIGNAL PRINCIPAL
        
        Workflow complet d'analyse et génération signal final :
        1. Calcul features avec confluence
        2. Analyse bataille navale (votre méthode signature)
        3. Détection régime marché (trend vs range)
        4. Sélection et exécution stratégie appropriée
        5. Validation confluence et qualité
        6. Génération signal final unifié
        
        Args:
            market_data: Données OHLC + volume obligatoires
            order_flow: Données order flow optionnelles
            options_data: Données options pour gamma (SpotGamma)
            structure_data: Market profile + VWAP levels
            sierra_patterns: Patterns Sierra Chart
            
        Returns:
            FinalSignal : Signal final prêt pour exécution
        """
        start_time = time.perf_counter()
        
        try:
            # === ÉTAPE 1: ANALYSE COMPOSANTS ===
            components = self._analyze_all_components(
                market_data, order_flow, options_data, structure_data, sierra_patterns
            )
            
            # === ÉTAPE 2: VALIDATION COMPOSANTS ===
            if not self._validate_components(components):
                return self._create_wait_signal(
                    market_data, "Composants insuffisants", components
                )
            
            # === ÉTAPE 3: DÉTERMINATION STRATÉGIE ===
            strategy_decision = self._determine_strategy(components)
            
            # === ÉTAPE 4: GÉNÉRATION SIGNAL PRIMAIRE ===
            primary_signal = self._generate_primary_signal(
                components, strategy_decision, market_data
            )
            
            # === ÉTAPE 5: VALIDATION CONFLUENCE ===
            confluence_validated = self._validate_confluence(
                primary_signal, components.confluence
            )
            
            if not confluence_validated:
                return self._create_wait_signal(
                    market_data, "Confluence insuffisante", components
                )
            
            # === ÉTAPE 6: CALCUL QUALITÉ FINALE ===
            final_quality = self._calculate_final_quality(primary_signal, components)
            
            # === ÉTAPE 7: SIGNAL FINAL ===
            final_signal = self._create_final_signal(
                primary_signal, components, final_quality, market_data
            )
            
            # === ÉTAPE 8: TRACKING PERFORMANCE ===
            execution_time = (time.perf_counter() - start_time) * 1000
            components.analysis_time_ms = execution_time
            final_signal.components = components
            
            self._update_stats(final_signal, execution_time)
            self.last_signal = final_signal
            self.signal_history.append(final_signal)
            
            logger.info(f"Signal généré en {execution_time:.2f}ms: "
                       f"{final_signal.decision.value} "
                       f"(Confidence: {final_signal.confidence:.3f})")
            
            return final_signal
            
        except Exception as e:
            logger.error(f"Erreur génération signal: {e}")
            return self._create_error_signal(market_data, str(e))
    
    def _analyze_all_components(self,
                               market_data: MarketData,
                               order_flow: Optional[OrderFlowData],
                               options_data: Optional[Dict[str, Any]],
                               structure_data: Optional[Dict[str, Any]],
                               sierra_patterns: Optional[Dict[str, float]]) -> SignalComponents:
        """Analyse complète de tous les composants"""
        
        components = SignalComponents(timestamp=market_data.timestamp)
        
        try:
            # 1. CALCUL FEATURES AVEC CONFLUENCE
            components.features = self.feature_calculator.calculate_all_features(
                market_data=market_data,
                order_flow=order_flow,
                options_data=options_data,
                structure_data=structure_data,
                sierra_patterns=sierra_patterns
            )
            
            # 2. ANALYSE BATAILLE NAVALE (votre méthode signature)
            components.battle_navale = self.battle_navale.analyze_battle_navale(market_data, order_flow)
            
            # 3. DÉTECTION RÉGIME MARCHÉ
            components.market_regime = self.market_regime.analyze_market_regime(market_data)
            self.current_regime = components.market_regime
            
            # 4. ANALYSE CONFLUENCE 
            # Confluence temporairement simplifiée
            if self.confluence_analyzer and hasattr(self.confluence_analyzer, 'analyze_confluence'):
                try:
                    components.confluence = self.confluence_analyzer.analyze_confluence(
                        price=market_data.close,
                        levels=structure_data if structure_data else {}
                    )
                except:
                    # Créer une confluence par défaut si erreur
                    from dataclasses import dataclass
                    @dataclass
                    class DefaultConfluence:
                        max_confluence_score: float = 0.5
                        zones: list = None
                    components.confluence = DefaultConfluence()
            else:
                # Confluence par défaut si analyzer manquant
                from dataclasses import dataclass
                @dataclass
                class DefaultConfluence:
                    max_confluence_score: float = 0.5
                    zones: list = None
                components.confluence = DefaultConfluence()
            
            # 5. SIGNAUX STRATÉGIES (selon régime détecté)
            if components.market_regime:
                regime = components.market_regime.regime
                
                # Signal Trend si régime trend
                if regime in [MarketRegime.TREND_BULLISH, MarketRegime.TREND_BEARISH]:
                    components.trend_signal = self.trend_strategy.analyze_trend_signal(
                        components.features, market_data, components.market_regime
                    )
                
                # Signal Range si régime range  
                elif regime in [MarketRegime.RANGE_TIGHT, MarketRegime.RANGE_WIDE]:
                    components.range_signal = self.range_strategy.analyze_range_signal(
                        components.features, market_data, components.market_regime
                    )
            
            logger.debug(f"Composants analysés: "
                        f"Features={'✅' if components.features else '❌'}, "
                        f"Bataille={'✅' if components.battle_navale else '❌'}, "
                        f"Régime={'✅' if components.market_regime else '❌'}, "
                        f"Confluence={'✅' if components.confluence else '❌'}")
            
        except Exception as e:
            logger.error(f"Erreur analyse composants: {e}")
        
        return components
    
    def _validate_components(self, components: SignalComponents) -> bool:
        """Validation des composants essentiels"""
        
        # Composants obligatoires
        required_components = [
            components.features,
            components.market_regime
        ]
        
        if not all(required_components):
            logger.warning("Composants essentiels manquants")
            return False
        
        # Validation qualité features
        if components.features.confluence_score < 0.1:  # Réduit de 0.3 à 0.1 pour debug
            logger.debug("Score confluence trop faible pour trading")
            return False
        
        # Validation régime clair
        if components.market_regime.regime == MarketRegime.UNKNOWN and False:  # Désactivé temporairement
            logger.debug("Régime marché unclear")
            return False
        
        return True
    
    def _determine_strategy(self, components: SignalComponents) -> str:
        """Détermine la stratégie à utiliser selon le régime"""
        
        if not components.market_regime:
            return "wait"
        
        regime = components.market_regime.regime
        confidence = components.market_regime.regime_confidence
        
        # Régimes trend -> Trend strategy
        if regime in [MarketRegime.TREND_BULLISH, MarketRegime.TREND_BEARISH]:
            if confidence >= 0.7:
                return "trend_strong"
            else:
                return "trend_weak"
        
        # Régimes range -> Range strategy
        elif regime in [MarketRegime.RANGE_TIGHT, MarketRegime.RANGE_WIDE]:
            if confidence >= 0.7:
                return "range_strong"
            else:
                return "range_weak"
        
        # Transition ou unclear -> Wait
        else:
            return "wait"
    
    def _generate_primary_signal(self,
                                components: SignalComponents,
                                strategy_decision: str,
                                market_data: MarketData) -> Optional[Dict[str, Any]]:
        """Génère le signal primaire selon la stratégie choisie"""
        
        if strategy_decision.startswith("trend"):
            return self._generate_trend_signal(components, market_data)
        elif strategy_decision.startswith("range"):
            return self._generate_range_signal(components, market_data)
        else:
            return None
    
    def _generate_trend_signal(self, 
                              components: SignalComponents, 
                              market_data: MarketData) -> Optional[Dict[str, Any]]:
        """Génère signal trend basé sur bataille navale + trend strategy"""
        
        try:
            # Prioriser bataille navale pour direction
            battle_signal = components.battle_navale
            trend_signal = components.trend_signal
            regime = components.market_regime.regime
            
            signal_direction = None
            confidence = 0.0
            
            # Détecter direction depuis bataille navale
            if battle_signal:
                if hasattr(battle_signal, 'signal_type'):
                    if battle_signal.signal_type in ['LONG', 'LONG_TREND']:
                        signal_direction = "LONG"
                        confidence += 0.3
                    elif battle_signal.signal_type in ['SHORT', 'SHORT_TREND']:
                        signal_direction = "SHORT" 
                        confidence += 0.3
            
            # Confirmer avec trend strategy
            if trend_signal and signal_direction:
                if (signal_direction == "LONG" and 
                    trend_signal.signal_type in [TrendSignalType.PREMIUM_PULLBACK, TrendSignalType.STRONG_PULLBACK]):
                    confidence += 0.4
                elif (signal_direction == "SHORT" and 
                      trend_signal.signal_type in [TrendSignalType.PREMIUM_PULLBACK, TrendSignalType.STRONG_PULLBACK]):
                    confidence += 0.4
            
            # Confirmer avec régime
            if regime == MarketRegime.TREND_BULLISH and signal_direction == "LONG":
                confidence += 0.2
            elif regime == MarketRegime.TREND_BEARISH and signal_direction == "SHORT":
                confidence += 0.2
            
            if signal_direction and confidence >= self.min_confidence:
                return {
                    'direction': signal_direction,
                    'type': f"{signal_direction}_TREND",
                    'confidence': min(confidence, 1.0),
                    'entry_price': market_data.close,
                    'source': SignalSource.TREND_STRATEGY,
                    'reasoning': f"Bataille navale {signal_direction} + Trend confirmé"
                }
            
        except Exception as e:
            logger.error(f"Erreur génération signal trend: {e}")
        
        return None
    
    def _generate_range_signal(self, 
                              components: SignalComponents, 
                              market_data: MarketData) -> Optional[Dict[str, Any]]:
        """Génère signal range basé sur confluence + range strategy"""
        
        try:
            range_signal = components.range_signal
            confluence = components.confluence
            
            if not range_signal:
                return None
            
            confidence = 0.5  # Base range confidence
            
            # Boost si confluence forte aux niveaux clés
            if confluence and confluence.max_confluence_score > 0.7:
                confidence += 0.2
            
            # Validation range strategy
            if range_signal.signal_type in [RangeSignalType.STRONG_SUPPORT, RangeSignalType.STRONG_RESISTANCE]:
                confidence += 0.2
            
            if confidence >= self.min_confidence:
                direction = "LONG" if "SUPPORT" in range_signal.signal_type.value.upper() else "SHORT"
                
                return {
                    'direction': direction,
                    'type': f"{direction}_RANGE",
                    'confidence': min(confidence, 1.0),
                    'entry_price': market_data.close,
                    'source': SignalSource.RANGE_STRATEGY,
                    'reasoning': f"Range {direction} + Confluence confirmée"
                }
            
        except Exception as e:
            logger.error(f"Erreur génération signal range: {e}")
        
        return None
    
    def _validate_confluence(self, 
                           primary_signal: Optional[Dict[str, Any]], 
                           confluence: Optional[ConfluenceAnalysis]) -> bool:
        """Valide que le signal a une confluence suffisante"""
        
        if not primary_signal:  # confluence rendue optionnelle
            return False
        
        if not confluence:  # Si pas de confluence, on accepte quand même
            return True
        
        # Score confluence minimum requis
        if confluence.max_confluence_score < self.min_confluence:
            logger.debug(f"Confluence insuffisante: {confluence.max_confluence_score:.3f} < {self.min_confluence}")
            return False
        
        return True
    
    def _calculate_final_quality(self, 
                               primary_signal: Dict[str, Any], 
                               components: SignalComponents) -> QualityLevel:
        """Calcule la qualité finale du signal"""
        
        base_confidence = primary_signal['confidence']
        
        # Boost confluence
        confluence_boost = 0.0
        if components.confluence:
            confluence_boost = components.confluence.max_confluence_score * 0.15
        
        # Boost bataille navale
        battle_boost = 0.0
        if components.battle_navale and hasattr(components.battle_navale, 'confidence'):
            battle_boost = components.battle_navale.confidence * 0.1
        
        # Score final
        final_score = min(base_confidence + confluence_boost + battle_boost, 1.0)
        
        # Classification qualité
        if final_score >= 0.90:
            return QualityLevel.PREMIUM
        elif final_score >= 0.80:
            return QualityLevel.STRONG
        elif final_score >= 0.70:
            return QualityLevel.MODERATE
        elif final_score >= 0.60:
            return QualityLevel.WEAK
        else:
            return QualityLevel.REJECT
    
    def _create_final_signal(self,
                           primary_signal: Dict[str, Any],
                           components: SignalComponents,
                           quality: QualityLevel,
                           market_data: MarketData) -> FinalSignal:
        """Crée le signal final avec tous les paramètres"""
        
        # Déterminer signal type
        signal_type_map = {
            'LONG_TREND': SignalType.LONG_TREND,
            'SHORT_TREND': SignalType.SHORT_TREND,
            'LONG_RANGE': SignalType.LONG_RANGE,
            'SHORT_RANGE': SignalType.SHORT_RANGE
        }
        
        signal_type = signal_type_map.get(primary_signal['type'], SignalType.NO_SIGNAL)
        
        # Position sizing selon qualité
        position_size_map = {
            QualityLevel.PREMIUM: 3.0,
            QualityLevel.STRONG: 2.0,
            QualityLevel.MODERATE: 1.5,
            QualityLevel.WEAK: 1.0,
            QualityLevel.REJECT: 0.0
        }
        
        position_size = min(position_size_map[quality], self.max_position_size)
        
        # Calcul stops et targets (logique simplifiée)
        entry_price = primary_signal['entry_price']
        direction = primary_signal['direction']
        
        if direction == "LONG":
            stop_loss = entry_price - (10 * ES_TICK_SIZE)  # 10 ticks stop
            take_profit = entry_price + (15 * ES_TICK_SIZE)  # 15 ticks target
        else:
            stop_loss = entry_price + (10 * ES_TICK_SIZE)
            take_profit = entry_price - (15 * ES_TICK_SIZE)
        
        risk_reward = abs(take_profit - entry_price) / abs(entry_price - stop_loss)
        
        # Décision finale
        if quality == QualityLevel.REJECT or risk_reward < self.min_risk_reward:
            decision = SignalDecision.WAIT_BETTER_SETUP
        else:
            decision = SignalDecision.EXECUTE_LONG if direction == "LONG" else SignalDecision.EXECUTE_SHORT
        
        return FinalSignal(
            timestamp=market_data.timestamp,
            decision=decision,
            signal_type=signal_type,
            entry_price=entry_price,
            stop_loss=stop_loss,
            take_profit=take_profit,
            position_size=position_size,
            risk_reward_ratio=risk_reward,
            confidence=primary_signal['confidence'],
            quality_level=quality,
            confluence_score=components.confluence.max_confluence_score if components.confluence else 0.0,
            primary_source=primary_signal['source'],
            reasoning=primary_signal['reasoning'],
            metadata={
                'regime': components.market_regime.regime.value if components.market_regime else "unknown",
                'strategy_used': primary_signal['source'].value,
                'confluence_zones': len(components.confluence.zones) if components.confluence else 0
            }
        )
    
    def _create_wait_signal(self, 
                           market_data: MarketData, 
                           reason: str, 
                           components: Optional[SignalComponents] = None) -> FinalSignal:
        """Crée un signal d'attente"""
        
        return FinalSignal(
            timestamp=market_data.timestamp,
            decision=SignalDecision.WAIT_BETTER_SETUP,
            signal_type=SignalType.NO_SIGNAL,
            entry_price=market_data.close,
            confidence=0.0,
            quality_level=QualityLevel.REJECT,
            reasoning=reason,
            components=components
        )
    
    def _create_error_signal(self, market_data: MarketData, error: str) -> FinalSignal:
        """Crée un signal d'erreur"""
        
        return FinalSignal(
            timestamp=market_data.timestamp,
            decision=SignalDecision.WAIT_BETTER_SETUP,
            signal_type=SignalType.NO_SIGNAL,
            entry_price=market_data.close,
            confidence=0.0,
            quality_level=QualityLevel.REJECT,
            reasoning=f"Erreur: {error}"
        )
    
    def _update_stats(self, signal: FinalSignal, execution_time: float):
        """Mise à jour statistiques performance"""
        
        self.stats['signals_generated'] += 1
        
        if signal.decision in [SignalDecision.EXECUTE_LONG, SignalDecision.EXECUTE_SHORT]:
            self.stats['signals_executed'] += 1
        
        # Moyenne mobile temps exécution
        current_avg = self.stats['avg_generation_time_ms']
        count = self.stats['signals_generated']
        self.stats['avg_generation_time_ms'] = (
            (current_avg * (count - 1) + execution_time) / count
        )
        
        # Distribution qualité
        self.stats['quality_distribution'][signal.quality_level.value] += 1
        
        # Distribution régime
        if signal.metadata.get('regime'):
            self.stats['regime_distribution'][signal.metadata['regime']] += 1
    
    # === MÉTHODES PUBLIQUES UTILITAIRES ===
    
    def get_last_signal(self) -> Optional[FinalSignal]:
        """Retourne le dernier signal généré"""
        return self.last_signal
    
    def get_signal_history(self, count: int = 10) -> List[FinalSignal]:
        """Retourne l'historique des signaux"""
        return list(self.signal_history)[-count:]
    
    def get_current_regime(self) -> Optional[MarketRegimeData]:
        """Retourne le régime marché actuel"""
        return self.current_regime
    
    def get_performance_stats(self) -> Dict[str, Any]:
        """Retourne les statistiques de performance"""
        return {
            'signals_generated': self.stats['signals_generated'],
            'signals_executed': self.stats['signals_executed'],
            'execution_rate': (self.stats['signals_executed'] / max(self.stats['signals_generated'], 1)) * 100,
            'avg_generation_time_ms': round(self.stats['avg_generation_time_ms'], 2),
            'quality_distribution': dict(self.stats['quality_distribution']),
            'regime_distribution': dict(self.stats['regime_distribution']),
            'current_regime': self.current_regime.regime.value if self.current_regime else "unknown"
        }
    
    def reset_stats(self):
        """Remet à zéro les statistiques"""
        self.stats = {
            'signals_generated': 0,
            'signals_executed': 0,
            'avg_generation_time_ms': 0.0,
            'quality_distribution': defaultdict(int),
            'regime_distribution': defaultdict(int),
            'success_by_source': defaultdict(list)
        }
        logger.info("Statistiques réinitialisées")

# === FACTORY FUNCTIONS ===

def create_signal_generator(config: Optional[Dict[str, Any]] = None) -> SignalGenerator:
    """Factory function pour créer un SignalGenerator"""
    return SignalGenerator(config)

def generate_trading_signal(market_data: MarketData,
                           order_flow: Optional[OrderFlowData] = None,
                           options_data: Optional[Dict[str, Any]] = None,
                           structure_data: Optional[Dict[str, Any]] = None,
                           sierra_patterns: Optional[Dict[str, float]] = None,
                           generator: Optional[SignalGenerator] = None) -> FinalSignal:
    """
    🎯 FONCTION PRINCIPALE - Point d'entrée unique
    
    Génère un signal de trading complet en utilisant tous les composants
    du système (bataille navale, features, confluence, etc.)
    
    Usage:
        signal = generate_trading_signal(market_data, order_flow, options_data)
        if signal.decision == SignalDecision.EXECUTE_LONG:
            execute_trade(signal)
    """
    
    if generator is None:
        generator = create_signal_generator()
    
    return generator.generate_signal(
        market_data=market_data,
        order_flow=order_flow,
        options_data=options_data,
        structure_data=structure_data,
        sierra_patterns=sierra_patterns
    )

# === EXPORTS ===

__all__ = [
    # Classes principales
    'SignalGenerator',
    'FinalSignal',
    'SignalComponents',
    
    # Enums
    'SignalDecision',
    'SignalSource', 
    'QualityLevel',
    
    # Factory functions
    'create_signal_generator',
    'generate_trading_signal'
]

if __name__ == "__main__":
    # Test basique
    import sys
    from pathlib import Path
    
    # Ajouter le dossier parent au path
    sys.path.append(str(Path(__file__).parent.parent))
    
    print("🧠 Test SignalGenerator...")
    
    try:
        # Test création
        generator = create_signal_generator()
        print("✅ SignalGenerator créé avec succès")
        
        # Test données factices
        test_data = MarketData(
            timestamp=pd.Timestamp.now(),
            symbol="ES",
            open=4500.0,
            high=4505.0,
            low=4495.0,
            close=4502.0,
            volume=1000
        )
        
        # Test génération signal
        signal = generator.generate_signal(test_data)
        print(f"✅ Signal généré: {signal.decision.value}")
        print(f"   └─ Confiance: {signal.confidence:.3f}")
        print(f"   └─ Qualité: {signal.quality_level.value}")
        
        # Test stats
        stats = generator.get_performance_stats()
        print(f"✅ Stats: {stats['signals_generated']} signaux générés")
        
    except Exception as e:
        print(f"❌ Erreur test: {e}")
    
    print("\n🎯 SignalGenerator prêt pour intégration complète!")