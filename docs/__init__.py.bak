"""
MIA Trading System - Documentation Package
=========================================

Ce package contient toute la documentation technique du projet MIA_IA_SYSTEM.

Structure:
---------
- ARCHITECTURE_MASTER.md : Document de r√©f√©rence principal
- IMPORTS_RULES.md : Guide des r√®gles d'imports anti-erreurs
- architecture.md : Architecture technique d√©taill√©e
- automation_guide.md : Guide d'automation du trading
- data_collection_guide.md : Guide de collection des donn√©es
- ml_strategy.md : Strat√©gie ML progressive
- deployment_guide.md : Guide de d√©ploiement en production

Usage:
------
    from docs import get_doc_content, validate_docs
    
    # Lire un document
    content = get_doc_content('ARCHITECTURE_MASTER')
    
    # Valider que tous les docs existent
    validation = validate_docs()
    
    # Obtenir le chemin d'un document
    path = get_doc_path('IMPORTS_RULES')
"""

import os
from pathlib import Path
from typing import Dict, List, Optional, Any
import json
from datetime import datetime

# Metadata
__version__ = '3.0.0'
__author__ = 'MIA Trading Team'
__last_updated__ = '2025-01-25'
__status__ = 'Production'

# Documentation structure
DOCUMENTATION_STRUCTURE = {
    'ARCHITECTURE_MASTER.md': {
        'title': 'Architecture Master - Document de R√©f√©rence',
        'description': 'Vue compl√®te de l\'architecture syst√®me avec r√®gles d\'int√©gration',
        'topics': ['Architecture', 'Imports', 'Modules', 'Int√©gration', 'Workflow'],
        'audience': ['Tous d√©veloppeurs'],
        'maintenance_frequency': 'Mensuelle'
    },
    'IMPORTS_RULES.md': {
        'title': 'R√®gles d\'Imports - Guide Anti-Erreurs',
        'description': 'Guide d√©taill√© pour √©viter tous probl√®mes d\'imports',
        'topics': ['Imports', 'D√©pendances', 'Hi√©rarchie', 'Debugging'],
        'audience': ['D√©veloppeurs'],
        'maintenance_frequency': 'Bi-mensuelle'
    },
    'architecture.md': {
        'title': 'Architecture Technique D√©taill√©e',
        'description': 'Description technique approfondie de chaque composant',
        'topics': ['Components', 'Design Patterns', 'Interfaces', 'Data Flow'],
        'audience': ['Senior Developers', 'Architectes'],
        'maintenance_frequency': 'Trimestrielle'
    },
    'automation_guide.md': {
        'title': 'Guide d\'Automation Trading',
        'description': 'Configuration et utilisation du syst√®me d\'automation',
        'topics': ['Automation', 'Configuration', 'Monitoring', 'Safety'],
        'audience': ['Traders', 'DevOps'],
        'maintenance_frequency': 'Mensuelle'
    },
    'data_collection_guide.md': {
        'title': 'Guide Collection de Donn√©es',
        'description': 'Processus de collection et stockage des donn√©es de trading',
        'topics': ['Data Pipeline', 'Storage', 'Quality', 'Snapshots'],
        'audience': ['Data Engineers', 'ML Engineers'],
        'maintenance_frequency': 'Bi-mensuelle'
    },
    'ml_strategy.md': {
        'title': 'Strat√©gie ML Progressive',
        'description': 'Approche progressive pour l\'int√©gration du Machine Learning',
        'topics': ['ML Models', 'Training', 'Validation', 'Deployment'],
        'audience': ['ML Engineers', 'Quants'],
        'maintenance_frequency': 'Mensuelle'
    },
    'deployment_guide.md': {
        'title': 'Guide de D√©ploiement Production',
        'description': 'Proc√©dures pour d√©ployer en environnement de production',
        'topics': ['Deployment', 'Configuration', 'Monitoring', 'Rollback'],
        'audience': ['DevOps', 'SRE'],
        'maintenance_frequency': 'Trimestrielle'
    }
}

# === UTILITY FUNCTIONS ===

def get_docs_directory() -> Path:
    """Retourne le chemin du dossier docs"""
    return Path(__file__).parent

def get_doc_path(doc_name: str) -> Optional[Path]:
    """Retourne le chemin complet d'un document"""
    if not doc_name.endswith('.md'):
        doc_name += '.md'
    
    if doc_name not in DOCUMENTATION_STRUCTURE:
        return None
    
    return get_docs_directory() / doc_name

def get_doc_info() -> Dict[str, Any]:
    """Retourne les informations sur la documentation"""
    return {
        'version': __version__,
        'last_updated': __last_updated__,
        'total_documents': len(DOCUMENTATION_STRUCTURE),
        'documents': list(DOCUMENTATION_STRUCTURE.keys()),
        'structure': DOCUMENTATION_STRUCTURE
    }

def validate_docs() -> Dict[str, Any]:
    """Valide que tous les documents existent et sont √† jour"""
    docs_dir = get_docs_directory()
    validation_results = {
        'valid': True,
        'missing_files': [],
        'file_sizes': {},
        'last_modified': {},
        'validation_timestamp': datetime.now().isoformat()
    }
    
    for doc_name in DOCUMENTATION_STRUCTURE.keys():
        doc_path = docs_dir / doc_name
        
        if not doc_path.exists():
            validation_results['valid'] = False
            validation_results['missing_files'].append(doc_name)
        else:
            # File size
            validation_results['file_sizes'][doc_name] = doc_path.stat().st_size
            
            # Last modified
            mod_time = datetime.fromtimestamp(doc_path.stat().st_mtime)
            validation_results['last_modified'][doc_name] = mod_time.isoformat()
    
    return validation_results

def get_doc_content(doc_name: str) -> Optional[str]:
    """Lit le contenu d'un document"""
    docs_dir = get_docs_directory()
    
    # Ajouter .md si pas pr√©sent
    if not doc_name.endswith('.md'):
        doc_name += '.md'
    
    doc_path = docs_dir / doc_name
    
    if not doc_path.exists():
        return None
    
    try:
        with open(doc_path, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        print(f"Erreur lecture {doc_name}: {e}")
        return None

def get_doc_summary(doc_name: str) -> Optional[Dict[str, Any]]:
    """R√©sum√© d'un document sp√©cifique"""
    if doc_name not in DOCUMENTATION_STRUCTURE:
        return None
    
    docs_dir = get_docs_directory()
    doc_path = docs_dir / doc_name
    
    summary = DOCUMENTATION_STRUCTURE[doc_name].copy()
    
    if doc_path.exists():
        stat = doc_path.stat()
        summary.update({
            'file_exists': True,
            'file_size_bytes': stat.st_size,
            'file_size_kb': round(stat.st_size / 1024, 2),
            'last_modified': datetime.fromtimestamp(stat.st_mtime).isoformat(),
            'path': str(doc_path)
        })
    else:
        summary.update({
            'file_exists': False,
            'error': f'File {doc_name} not found'
        })
    
    return summary

def generate_docs_index() -> str:
    """G√©n√®re un index de toute la documentation"""
    index = f"""# MIA_IA_SYSTEM - Documentation Index

**Version:** {__version__}  
**Derni√®re mise √† jour:** {__last_updated__}  
**Statut:** {__status__}

## üìö Documentation Disponible

"""
    
    for doc_name, info in DOCUMENTATION_STRUCTURE.items():
        index += f"""### [{info['title']}](./{doc_name})

**Description:** {info['description']}  
**Audience:** {', '.join(info['audience'])}  
**Maintenance:** {info['maintenance_frequency']}

**Sujets couverts:**
"""
        for topic in info['topics']:
            index += f"- {topic}\n"
        
        index += "\n---\n\n"
    
    return index

def export_docs_metadata() -> str:
    """Export m√©tadonn√©es en JSON pour outils externes"""
    metadata = {
        'package_info': {
            'version': __version__,
            'author': __author__,
            'status': __status__,
            'last_updated': __last_updated__
        },
        'structure': DOCUMENTATION_STRUCTURE,
        'validation': validate_docs()
    }
    
    return json.dumps(metadata, indent=2, ensure_ascii=False)

def get_maintenance_schedule() -> Dict[str, List[str]]:
    """Planning maintenance documentation"""
    schedule = {
        'Hebdomadaire': [],
        'Bi-mensuelle': [],
        'Mensuelle': [],
        'Trimestrielle': []
    }
    
    for doc_name, info in DOCUMENTATION_STRUCTURE.items():
        frequency = info['maintenance_frequency']
        if frequency in schedule:
            schedule[frequency].append(doc_name)
    
    return schedule

# === API DOCUMENTATION ===

def get_all_topics() -> List[str]:
    """Liste tous les sujets couverts dans la documentation"""
    all_topics = []
    for info in DOCUMENTATION_STRUCTURE.values():
        all_topics.extend(info['topics'])
    return sorted(set(all_topics))

def search_docs(query: str) -> List[Dict[str, Any]]:
    """Recherche dans les titres et descriptions"""
    results = []
    query_lower = query.lower()
    
    for doc_name, info in DOCUMENTATION_STRUCTURE.items():
        relevance_score = 0
        
        # Check title
        if query_lower in info['title'].lower():
            relevance_score += 3
        
        # Check description  
        if query_lower in info['description'].lower():
            relevance_score += 2
        
        # Check topics
        for topic in info['topics']:
            if query_lower in topic.lower():
                relevance_score += 1
        
        if relevance_score > 0:
            result = info.copy()
            result['document'] = doc_name
            result['relevance_score'] = relevance_score
            results.append(result)
    
    # Sort by relevance
    return sorted(results, key=lambda x: x['relevance_score'], reverse=True)

# === EXPORTS ===

__all__ = [
    # M√©tadonn√©es
    '__version__',
    '__author__',
    '__status__',
    
    # Fonctions principales
    'get_doc_info',
    'validate_docs', 
    'get_doc_content',
    'get_doc_summary',
    
    # Utilitaires
    'generate_docs_index',
    'export_docs_metadata',
    'get_maintenance_schedule',
    'get_all_topics',
    'search_docs',
    
    # Structure
    'DOCUMENTATION_STRUCTURE'
]

# === TESTING ===

def test_docs_package():
    """Test rapide du package documentation"""
    print("=== TEST DOCS PACKAGE ===")
    
    # Test 1: Info g√©n√©rale
    info = get_doc_info()
    print(f"‚úÖ Documentation version {info['version']}")
    print(f"‚úÖ {info['total_documents']} documents disponibles")
    
    # Test 2: Validation
    validation = validate_docs()
    if validation['valid']:
        print("‚úÖ Tous les documents existent")
    else:
        print(f"‚ùå Documents manquants: {validation['missing_files']}")
    
    # Test 3: Test lecture
    ml_content = get_doc_content('ml_strategy')
    if ml_content:
        print(f"‚úÖ ml_strategy.md lu: {len(ml_content)} caract√®res")
    else:
        print("‚ùå Impossible de lire ml_strategy.md")
    
    # Test 4: Recherche
    search_results = search_docs('ML')
    print(f"‚úÖ Recherche 'ML': {len(search_results)} r√©sultats")
    
    print("=== TEST TERMIN√â ===")
    return True

if __name__ == "__main__":
    test_docs_package()