"""
MIA_IA_SYSTEM - Trading Configuration
Configuration centralisée trading + risk management
Version: Production Ready v2.1 (PRIORITÉ #2 APPLIQUÉE)
Performance: Configuration optimisée pour trading live

PRIORITÉ #2: RECALIBRAGE SEUILS INTÉGRÉ
- Nouveaux seuils Battle Navale: 0.25/-0.25 (vs 0.35/-0.35)
- Configuration centralisée pour +150% fréquence signaux
- Paramètres optimisés pour +2-3% win rate
"""

from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass, field
from enum import Enum
import json
from core.logger import get_logger
from pathlib import Path

logger = get_logger(__name__)

# === PRIORITÉ #2: CONSTANTES SEUILS ===
# Nouveaux seuils Battle Navale calibrés
BATTLE_NAVALE_LONG_THRESHOLD_DEFAULT = 0.25   # Abaissé de 0.35
BATTLE_NAVALE_SHORT_THRESHOLD_DEFAULT = -0.25  # Abaissé de -0.35

# Anciens seuils pour référence/comparaison
BATTLE_NAVALE_LONG_THRESHOLD_OLD = 0.35
BATTLE_NAVALE_SHORT_THRESHOLD_OLD = -0.35

# Seuils confluence ajustés pour cohérence
CONFLUENCE_THRESHOLD_PREMIUM = 0.80    # Pour signaux premium
CONFLUENCE_THRESHOLD_STRONG = 0.70     # Pour signaux strong
CONFLUENCE_THRESHOLD_MODERATE = 0.60   # Pour signaux modérés (maintenu)
CONFLUENCE_THRESHOLD_WEAK = 0.50       # Pour signaux faibles

# === CONFIGURATION ENUMS ===


class TradingMode(Enum):
    """Modes de trading"""
    PAPER_TRADING = "paper_trading"
    LIVE_TRADING = "live_trading"
    BACKTESTING = "backtesting"
    SIMULATION = "simulation"


class DataSource(Enum):
    """Sources de données"""
    IBKR = "ibkr"
    SIERRA_CHART = "sierra_chart"
    SIMULATED = "simulated"


class ExecutionMode(Enum):
    """Modes d'exécution"""
    MANUAL_APPROVAL = "manual_approval"
    SEMI_AUTO = "semi_auto"
    FULL_AUTO = "full_auto"


class RiskLevel(Enum):
    """Niveaux de risque"""
    CONSERVATIVE = "conservative"
    MODERATE = "moderate"
    AGGRESSIVE = "aggressive"


class Priority2Mode(Enum):
    """PRIORITÉ #2: Modes de seuils"""
    OLD_THRESHOLDS = "old_thresholds"      # 0.35/-0.35 (référence)
    NEW_THRESHOLDS = "new_thresholds"      # 0.25/-0.25 (PRIORITÉ #2)
    ADAPTIVE_THRESHOLDS = "adaptive"       # Adaptatifs selon conditions
    CUSTOM_THRESHOLDS = "custom"           # Définis par utilisateur

# === CORE CONFIGURATION ===


@dataclass
class SymbolConfig:
    """Configuration par symbole"""
    symbol: str
    exchange: str
    tick_size: float
    tick_value: float
    min_quantity: float = 1.0
    max_quantity: float = 10.0
    trading_hours_start: int = 9
    trading_hours_end: int = 16
    commission_per_contract: float = 2.50

    def __post_init__(self):
        """Validation configuration symbole"""
        if self.tick_size <= 0:
            raise ValueError(f"Tick size must be > 0: {self.tick_size}")
        if self.max_quantity < self.min_quantity:
            raise ValueError(
                f"Max quantity < min quantity: {
                    self.max_quantity} < {
                    self.min_quantity}")


@dataclass
class RiskManagementConfig:
    """Configuration risk management"""
    # Position sizing
    max_position_size: int = 3
    position_size_method: str = "fixed"  # fixed, percentage, volatility
    base_position_size: float = 1.0

    # Daily limits
    max_daily_loss: float = 1000.0
    max_daily_trades: int = 10
    daily_profit_target: float = 500.0
    stop_trading_on_target: bool = False

    # Per trade limits
    max_risk_per_trade: float = 200.0
    min_risk_reward_ratio: float = 1.2
    max_holding_time_minutes: int = 240  # 4 hours

    # Stop loss settings
    use_adaptive_stops: bool = True
    base_stop_distance_ticks: int = 8
    max_stop_distance_ticks: int = 20
    trailing_stop_enabled: bool = True

    # Portfolio limits
    max_open_positions: int = 2
    max_correlation_exposure: float = 0.7

    # === PRIORITÉ #2: RISK MANAGEMENT AJUSTÉ ===
    # Paramètres ajustés pour nouveaux seuils
    signal_frequency_multiplier: float = 2.5  # +150% fréquence attendue
    max_daily_trades_priority2: int = 25      # Augmenté pour nouvelle fréquence
    risk_per_trade_adjustment: float = 0.8    # Réduit car plus de trades

    def validate(self) -> bool:
        """Validation cohérence risk config"""
        try:
            if self.max_daily_loss <= 0:
                logger.error("Max daily loss doit être > 0")
                return False

            if self.max_risk_per_trade > self.max_daily_loss:
                logger.error("Risk per trade > daily loss limit")
                return False

            if self.min_risk_reward_ratio < 1.0:
                logger.warning("Risk/reward ratio < 1.0 peut être non profitable")

            # === PRIORITÉ #2: VALIDATIONS SPÉCIFIQUES ===
            if self.signal_frequency_multiplier < 1.0:
                logger.error("Signal frequency multiplier doit être >= 1.0")
                return False

            if self.max_daily_trades_priority2 < self.max_daily_trades:
                logger.warning("Max daily trades PRIORITÉ #2 < standard")

            return True
        except Exception as e:
            logger.error(f"Erreur validation risk config: {e}")
            return False

    def get_adjusted_risk_per_trade(self) -> float:
        """Calcul risk per trade ajusté pour PRIORITÉ #2"""
        return self.max_risk_per_trade * self.risk_per_trade_adjustment

    def get_adjusted_max_daily_trades(self) -> int:
        """Calcul max daily trades ajusté pour PRIORITÉ #2"""
        return self.max_daily_trades_priority2


@dataclass
class BattleNavaleConfig:
    """
    PRIORITÉ #2: Configuration Battle Navale dédiée
    """
    # Seuils principaux
    long_threshold: float = BATTLE_NAVALE_LONG_THRESHOLD_DEFAULT
    short_threshold: float = BATTLE_NAVALE_SHORT_THRESHOLD_DEFAULT
    threshold_mode: Priority2Mode = Priority2Mode.NEW_THRESHOLDS

    # Seuils de qualité
    premium_threshold: float = 0.75    # Signaux premium
    strong_threshold: float = 0.60     # Signaux strong  
    moderate_threshold: float = 0.45   # Signaux modérés
    weak_threshold: float = 0.30       # Signaux faibles

    # Paramètres bataille navale
    min_base_quality: float = 0.6
    rouge_sous_verte_strict: bool = True
    base_size_threshold_ticks: int = 4
    
    # Validation et tracking
    validate_against_old_thresholds: bool = True
    track_frequency_boost: bool = True
    target_frequency_boost_pct: float = 150.0
    
    # Performance targets
    target_win_rate_boost_pct: float = 2.5  # +2.5% win rate ciblé
    min_win_rate_threshold: float = 0.68   # Win rate minimum attendu

    def get_thresholds(self) -> Dict[str, float]:
        """Retourne seuils selon mode configuré"""
        if self.threshold_mode == Priority2Mode.OLD_THRESHOLDS:
            return {
                'long': BATTLE_NAVALE_LONG_THRESHOLD_OLD,
                'short': BATTLE_NAVALE_SHORT_THRESHOLD_OLD
            }
        elif self.threshold_mode == Priority2Mode.NEW_THRESHOLDS:
            return {
                'long': self.long_threshold,
                'short': self.short_threshold
            }
        elif self.threshold_mode == Priority2Mode.ADAPTIVE_THRESHOLDS:
            # Logique adaptative (à implémenter)
            return {
                'long': self.long_threshold,
                'short': self.short_threshold
            }
        else:  # CUSTOM
            return {
                'long': self.long_threshold,
                'short': self.short_threshold
            }

    def validate(self) -> bool:
        """Validation configuration Battle Navale"""
        try:
            # Vérification seuils cohérents
            if self.long_threshold <= 0:
                logger.error("Long threshold doit être > 0")
                return False
            
            if self.short_threshold >= 0:
                logger.error("Short threshold doit être < 0")
                return False
            
            # Vérification hiérarchie qualité
            thresholds = [self.premium_threshold, self.strong_threshold, 
                         self.moderate_threshold, self.weak_threshold]
            if not all(thresholds[i] > thresholds[i+1] for i in range(len(thresholds)-1)):
                logger.error("Seuils qualité doivent être décroissants")
                return False
            
            # Vérification targets réalistes
            if self.target_frequency_boost_pct < 100.0:
                logger.warning("Target frequency boost < 100% peut être trop faible")
            
            return True
            
        except Exception as e:
            logger.error(f"Erreur validation Battle Navale config: {e}")
            return False


@dataclass
class FeatureConfig:
    """Configuration features et signaux"""
    # Feature calculation
    lookback_periods: int = 20
    feature_update_frequency_ms: int = 1000
    max_calculation_time_ms: float = 5.0

    # Signal generation
    min_signal_confidence: float = 0.65
    min_pattern_strength: float = 0.6
    signal_aggregation_method: str = "weighted_average"

    # Battle Navale settings (PRIORITÉ #2: Migrées vers BattleNavaleConfig)
    battle_navale_enabled: bool = True
    battle_navale_config: BattleNavaleConfig = field(default_factory=BattleNavaleConfig)

    # Pattern detection
    gamma_pin_enabled: bool = True
    headfake_detection_enabled: bool = True
    microstructure_ml_enabled: bool = True

    # Confluence settings (PRIORITÉ #2: Ajustés)
    confluence_required_levels: int = 2
    confluence_proximity_ticks: float = 2.0
    confluence_threshold_premium: float = CONFLUENCE_THRESHOLD_PREMIUM
    confluence_threshold_strong: float = CONFLUENCE_THRESHOLD_STRONG
    confluence_threshold_moderate: float = CONFLUENCE_THRESHOLD_MODERATE
    confluence_threshold_weak: float = CONFLUENCE_THRESHOLD_WEAK

    # Regime detection
    trend_range_threshold: float = 0.7
    regime_confirmation_periods: int = 5

    # === PRIORITÉ #2: PARAMÈTRES DE PERFORMANCE ===
    # Cache et optimisation pour fréquence accrue
    enable_feature_cache: bool = True
    cache_ttl_seconds: int = 60
    cache_max_size: int = 500
    
    # Validation et monitoring
    track_signal_generation_rate: bool = True
    log_threshold_comparisons: bool = True
    performance_alert_enabled: bool = True

    def get_confluence_threshold(self, quality_level: str) -> float:
        """Retourne seuil confluence selon niveau qualité"""
        thresholds = {
            'premium': self.confluence_threshold_premium,
            'strong': self.confluence_threshold_strong,
            'moderate': self.confluence_threshold_moderate,
            'weak': self.confluence_threshold_weak
        }
        return thresholds.get(quality_level.lower(), self.confluence_threshold_moderate)


@dataclass
class MLConfig:
    """Configuration ML models"""
    # Model settings
    model_type: str = "xgboost"  # xgboost, linear, ensemble
    retrain_frequency_trades: int = 100
    validation_split: float = 0.2

    # Performance thresholds
    min_model_accuracy: float = 0.65
    max_model_age_hours: int = 24
    model_validation_required: bool = True

    # Feature engineering
    feature_normalization: bool = True
    feature_selection_enabled: bool = False
    max_features: int = 8

    # Ensemble settings
    use_ensemble: bool = False
    ensemble_models: List[str] = field(default_factory=lambda: ["xgboost", "linear"])
    ensemble_weights: Dict[str, float] = field(
        default_factory=lambda: {"xgboost": 0.7, "linear": 0.3})

    # === PRIORITÉ #2: ML ADAPTATIONS ===
    # Adaptations pour fréquence signaux accrue
    retrain_frequency_priority2: int = 150  # Plus fréquent car plus de données
    include_battle_navale_features: bool = True
    battle_navale_feature_weight: float = 0.30
    
    # Validation spécifique PRIORITÉ #2
    validate_frequency_boost: bool = True
    min_frequency_improvement: float = 1.4  # Minimum +40%
    win_rate_degradation_threshold: float = 0.02  # Max -2% win rate acceptable


@dataclass
class DataConfig:
    """Configuration données"""
    # Data sources
    primary_data_source: DataSource = DataSource.IBKR
    backup_data_source: Optional[DataSource] = DataSource.SIERRA_CHART

    # Data quality
    max_data_latency_ms: int = 100
    data_validation_enabled: bool = True
    outlier_detection_enabled: bool = True

    # Historical data
    historical_data_days: int = 30
    tick_data_retention_hours: int = 24

    # Real-time data
    market_data_symbols: List[str] = field(default_factory=lambda: ["ES", "NQ"])
    options_data_enabled: bool = True
    level2_data_enabled: bool = True

    # === PRIORITÉ #2: DATA REQUIREMENTS ===
    # Besoins data pour nouveaux seuils
    increased_data_frequency: bool = True
    battle_navale_data_retention_hours: int = 48  # Plus de rétention pour analyse
    signal_comparison_data_enabled: bool = True   # Compare old vs new thresholds


@dataclass
class ExecutionConfig:
    """Configuration exécution"""
    # Execution mode
    execution_mode: ExecutionMode = ExecutionMode.SEMI_AUTO
    order_type_default: str = "MARKET"

    # Order management
    order_timeout_seconds: int = 30
    partial_fill_handling: str = "accept"  # accept, reject, cancel
    slippage_tolerance_ticks: float = 2.0

    # Broker settings
    broker_connection_timeout: int = 10
    max_reconnection_attempts: int = 3
    heartbeat_interval_seconds: int = 30

    # Position management
    auto_close_on_session_end: bool = True
    emergency_close_enabled: bool = True
    position_monitoring_interval_ms: int = 1000

    # === PRIORITÉ #2: EXECUTION ADAPTATIONS ===
    # Adaptations pour fréquence accrue
    enable_rapid_execution: bool = True
    rapid_execution_threshold_ms: int = 100
    batch_order_processing: bool = True
    max_orders_per_second: int = 10


@dataclass
class PerformanceConfig:
    """Configuration monitoring performance"""
    # Logging
    trade_logging_enabled: bool = True
    performance_logging_interval_trades: int = 10
    detailed_logging_enabled: bool = True

    # Analysis
    real_time_analysis_enabled: bool = True
    performance_analysis_window: int = 100  # trades
    adaptation_enabled: bool = True

    # Optimization
    auto_optimization_enabled: bool = True
    optimization_frequency_trades: int = 200
    a_b_testing_enabled: bool = True
    a_b_test_allocation: float = 0.3  # 30% new parameters

    # Alerts
    performance_alerts_enabled: bool = True
    alert_on_loss_streak: int = 3
    alert_on_low_win_rate: float = 0.5

    # === PRIORITÉ #2: PERFORMANCE MONITORING ===
    # Monitoring spécifique PRIORITÉ #2
    track_frequency_boost: bool = True
    track_win_rate_change: bool = True
    alert_on_frequency_target_miss: bool = True
    alert_on_win_rate_degradation: bool = True
    
    # Métriques comparaison
    compare_old_vs_new_thresholds: bool = True
    threshold_comparison_window: int = 1000  # trades
    performance_report_frequency: int = 50   # trades

# === MAIN CONFIGURATION CLASS ===


@dataclass
class TradingConfig:
    """Configuration principale système trading"""
    # Basic settings
    trading_mode: TradingMode = TradingMode.PAPER_TRADING
    config_version: str = "2.1.0"  # PRIORITÉ #2
    environment: str = "development"  # development, staging, production

    # === PRIORITÉ #2: CONFIGURATION FLAG ===
    priority_2_enabled: bool = True
    priority_2_version: str = "1.0.0"
    threshold_mode: Priority2Mode = Priority2Mode.NEW_THRESHOLDS

    # Component configurations
    symbols: Dict[str, SymbolConfig] = field(default_factory=dict)
    risk_management: RiskManagementConfig = field(default_factory=RiskManagementConfig)
    features: FeatureConfig = field(default_factory=FeatureConfig)
    ml: MLConfig = field(default_factory=MLConfig)
    data: DataConfig = field(default_factory=DataConfig)
    execution: ExecutionConfig = field(default_factory=ExecutionConfig)
    performance: PerformanceConfig = field(default_factory=PerformanceConfig)

    # File paths
    data_directory: str = "data"
    logs_directory: str = "logs"
    models_directory: str = "models"
    config_file_path: Optional[str] = None

    def __post_init__(self):
        """Initialisation post-création"""
        if not self.symbols:
            self._setup_default_symbols()

        # === PRIORITÉ #2: SETUP SPÉCIFIQUE ===
        if self.priority_2_enabled:
            self._setup_priority_2_config()

        # Validation configuration
        if not self.validate():
            raise ValueError("Configuration invalide")

    def _setup_default_symbols(self):
        """Setup symboles par défaut"""
        # ES Futures
        self.symbols["ES"] = SymbolConfig(
            symbol="ES",
            exchange="CME",
            tick_size=0.25,
            tick_value=12.50,
            min_quantity=1.0,
            max_quantity=5.0,
            commission_per_contract=2.50
        )

        # MES Futures (micro)
        self.symbols["MES"] = SymbolConfig(
            symbol="MES",
            exchange="CME",
            tick_size=0.25,
            tick_value=1.25,
            min_quantity=1.0,
            max_quantity=10.0,
            commission_per_contract=0.85
        )

        # NQ Futures (pour corrélation)
        self.symbols["NQ"] = SymbolConfig(
            symbol="NQ",
            exchange="CME",
            tick_size=0.25,
            tick_value=5.00,
            min_quantity=1.0,
            max_quantity=3.0,
            commission_per_contract=2.50
        )

    def _setup_priority_2_config(self):
        """
        PRIORITÉ #2: Configuration spécifique nouveaux seuils
        """
        logger.info("🎯 Setup PRIORITÉ #2 configuration")
        
        # Battle Navale config selon mode
        if self.threshold_mode == Priority2Mode.NEW_THRESHOLDS:
            self.features.battle_navale_config.long_threshold = BATTLE_NAVALE_LONG_THRESHOLD_DEFAULT
            self.features.battle_navale_config.short_threshold = BATTLE_NAVALE_SHORT_THRESHOLD_DEFAULT
        elif self.threshold_mode == Priority2Mode.OLD_THRESHOLDS:
            self.features.battle_navale_config.long_threshold = BATTLE_NAVALE_LONG_THRESHOLD_OLD
            self.features.battle_navale_config.short_threshold = BATTLE_NAVALE_SHORT_THRESHOLD_OLD

        # Risk management ajusté
        if self.threshold_mode == Priority2Mode.NEW_THRESHOLDS:
            # Ajustements pour fréquence accrue
            self.risk_management.max_daily_trades = self.risk_management.get_adjusted_max_daily_trades()
            
        # Performance monitoring activé
        self.performance.track_frequency_boost = True
        self.performance.compare_old_vs_new_thresholds = True
        
        # Cache activé pour performance
        self.features.enable_feature_cache = True
        
        # Execution rapide activée
        self.execution.enable_rapid_execution = True

        logger.info(f"PRIORITÉ #2 setup terminé - Mode: {self.threshold_mode.value}")

    def validate(self) -> bool:
        """Validation complète configuration"""
        try:
            # Validation risk management
            if not self.risk_management.validate():
                return False

            # Validation symboles
            for symbol, config in self.symbols.items():
                if config.tick_size <= 0 or config.tick_value <= 0:
                    logger.error(f"Configuration invalide pour {symbol}")
                    return False

            # Validation ML config
            if self.ml.max_features > 8:
                logger.error("Max features > 8 non supporté")
                return False

            # Validation data config
            if self.data.max_data_latency_ms > 1000:
                logger.warning("Latence data > 1s peut affecter performance")

            # === PRIORITÉ #2: VALIDATIONS SPÉCIFIQUES ===
            if self.priority_2_enabled:
                if not self.features.battle_navale_config.validate():
                    logger.error("Validation Battle Navale config échouée")
                    return False

            return True

        except Exception as e:
            logger.error(f"Erreur validation config: {e}")
            return False

    def save_to_file(self, file_path: str):
        """Sauvegarde configuration vers fichier"""
        try:
            config_dict = self.to_dict()

            with open(file_path, 'w') as f:
                json.dump(config_dict, f, indent=2, default=str)

            self.config_file_path = file_path
            logger.info(f"Configuration sauvée: {file_path}")

        except Exception as e:
            logger.error(f"Erreur sauvegarde config: {e}")
            raise

    def to_dict(self) -> Dict[str, Any]:
        """Conversion en dictionnaire"""
        return {
            'trading_mode': self.trading_mode.value,
            'config_version': self.config_version,
            'environment': self.environment,
            'priority_2_enabled': self.priority_2_enabled,
            'priority_2_version': self.priority_2_version,
            'threshold_mode': self.threshold_mode.value,
            'symbols': {k: v.__dict__ for k, v in self.symbols.items()},
            'risk_management': self.risk_management.__dict__,
            'features': {
                **self.features.__dict__,
                'battle_navale_config': self.features.battle_navale_config.__dict__
            },
            'ml': self.ml.__dict__,
            'data': self.data.__dict__,
            'execution': self.execution.__dict__,
            'performance': self.performance.__dict__,
            'data_directory': self.data_directory,
            'logs_directory': self.logs_directory,
            'models_directory': self.models_directory
        }

    def update_risk_level(self, risk_level: RiskLevel):
        """Mise à jour niveau de risque"""
        if risk_level == RiskLevel.CONSERVATIVE:
            self.risk_management.max_position_size = 1
            self.risk_management.max_daily_loss = 500.0
            self.risk_management.max_risk_per_trade = 100.0
            self.features.min_signal_confidence = 0.75

        elif risk_level == RiskLevel.MODERATE:
            self.risk_management.max_position_size = 2
            self.risk_management.max_daily_loss = 1000.0
            self.risk_management.max_risk_per_trade = 200.0
            self.features.min_signal_confidence = 0.65

        elif risk_level == RiskLevel.AGGRESSIVE:
            self.risk_management.max_position_size = 3
            self.risk_management.max_daily_loss = 2000.0
            self.risk_management.max_risk_per_trade = 400.0
            self.features.min_signal_confidence = 0.60

        # === PRIORITÉ #2: AJUSTEMENTS RISK LEVEL ===
        if self.priority_2_enabled and self.threshold_mode == Priority2Mode.NEW_THRESHOLDS:
            # Ajustements pour nouveaux seuils
            adjusted_risk = self.risk_management.get_adjusted_risk_per_trade()
            adjusted_trades = self.risk_management.get_adjusted_max_daily_trades()
            
            logger.info(f"PRIORITÉ #2 risk adjustments: "
                       f"Risk/trade: {adjusted_risk:.2f}, "
                       f"Max trades: {adjusted_trades}")

        logger.info(f"Risk level mis à jour: {risk_level.value}")

    def get_battle_navale_thresholds(self) -> Dict[str, float]:
        """
        PRIORITÉ #2: Récupération seuils Battle Navale
        """
        return self.features.battle_navale_config.get_thresholds()

    def set_threshold_mode(self, mode: Priority2Mode):
        """
        PRIORITÉ #2: Changement mode seuils
        """
        old_mode = self.threshold_mode
        self.threshold_mode = mode
        
        # Reconfiguration
        self._setup_priority_2_config()
        
        logger.info(f"🎯 Threshold mode changé: {old_mode.value} → {mode.value}")

    def get_priority_2_summary(self) -> Dict[str, Any]:
        """
        PRIORITÉ #2: Résumé configuration
        """
        thresholds = self.get_battle_navale_thresholds()
        
        return {
            'enabled': self.priority_2_enabled,
            'version': self.priority_2_version,
            'threshold_mode': self.threshold_mode.value,
            'thresholds': thresholds,
            'target_frequency_boost': self.features.battle_navale_config.target_frequency_boost_pct,
            'target_win_rate_boost': self.features.battle_navale_config.target_win_rate_boost_pct,
            'risk_adjustments': {
                'max_daily_trades': self.risk_management.get_adjusted_max_daily_trades(),
                'risk_per_trade_multiplier': self.risk_management.risk_per_trade_adjustment
            },
            'performance_tracking': {
                'frequency_boost': self.performance.track_frequency_boost,
                'win_rate_change': self.performance.track_win_rate_change,
                'threshold_comparison': self.performance.compare_old_vs_new_thresholds
            }
        }

# === FACTORY FUNCTIONS ===


def create_default_config() -> TradingConfig:
    """Création configuration par défaut"""
    return TradingConfig()


def create_paper_trading_config() -> TradingConfig:
    """Configuration pour paper trading"""
    config = TradingConfig()
    config.trading_mode = TradingMode.PAPER_TRADING
    config.execution.execution_mode = ExecutionMode.FULL_AUTO
    config.risk_management.max_daily_loss = 10000.0  # Virtuel
    return config


def create_live_trading_config() -> TradingConfig:
    """Configuration pour trading live"""
    config = TradingConfig()
    config.trading_mode = TradingMode.LIVE_TRADING
    config.execution.execution_mode = ExecutionMode.SEMI_AUTO
    config.update_risk_level(RiskLevel.CONSERVATIVE)
    return config


def create_backtesting_config() -> TradingConfig:
    """Configuration pour backtesting"""
    config = TradingConfig()
    config.trading_mode = TradingMode.BACKTESTING
    config.data.historical_data_days = 365
    config.performance.real_time_analysis_enabled = False
    return config


def create_priority_2_config() -> TradingConfig:
    """
    PRIORITÉ #2: Configuration optimisée nouveaux seuils
    """
    config = create_paper_trading_config()
    
    # Force PRIORITÉ #2
    config.priority_2_enabled = True
    config.threshold_mode = Priority2Mode.NEW_THRESHOLDS
    config.config_version = "2.1.0-priority2"
    
    # Optimisations spécifiques
    config.features.enable_feature_cache = True
    config.execution.enable_rapid_execution = True
    config.performance.track_frequency_boost = True
    
    # Risk management ajusté
    config.risk_management.signal_frequency_multiplier = 2.5
    
    logger.info("🎯 Configuration PRIORITÉ #2 créée avec nouveaux seuils")
    
    return config


def load_config_from_file(file_path: str) -> TradingConfig:
    """Chargement configuration depuis fichier"""
    try:
        with open(file_path, 'r') as f:
            config_dict = json.load(f)

        # Reconstruction objet (simplified)
        config = TradingConfig()
        config.trading_mode = TradingMode(config_dict['trading_mode'])
        config.config_version = config_dict['config_version']
        config.environment = config_dict['environment']

        # === PRIORITÉ #2: CHARGEMENT SPÉCIFIQUE ===
        if 'priority_2_enabled' in config_dict:
            config.priority_2_enabled = config_dict['priority_2_enabled']
            config.priority_2_version = config_dict.get('priority_2_version', '1.0.0')
            
            if 'threshold_mode' in config_dict:
                config.threshold_mode = Priority2Mode(config_dict['threshold_mode'])

        # Update fields from dict
        if 'risk_management' in config_dict:
            rm_dict = config_dict['risk_management']
            for key, value in rm_dict.items():
                if hasattr(config.risk_management, key):
                    setattr(config.risk_management, key, value)

        # Battle Navale config si présent
        if 'features' in config_dict and 'battle_navale_config' in config_dict['features']:
            bn_dict = config_dict['features']['battle_navale_config']
            for key, value in bn_dict.items():
                if hasattr(config.features.battle_navale_config, key):
                    setattr(config.features.battle_navale_config, key, value)

        config.config_file_path = file_path
        logger.info(f"Configuration chargée: {file_path}")

        return config

    except Exception as e:
        logger.error(f"Erreur chargement config: {e}")
        raise

# === CONFIGURATION PRESETS ===


def get_prop_firm_config() -> TradingConfig:
    """Configuration optimisée prop firm"""
    config = create_live_trading_config()

    # Risk management strict
    config.risk_management.max_daily_loss = 800.0  # 80% of typical $1000 limit
    config.risk_management.daily_profit_target = 400.0
    config.risk_management.max_position_size = 2
    config.risk_management.stop_trading_on_target = True

    # Signals conservateurs
    config.features.min_signal_confidence = 0.75
    config.features.min_pattern_strength = 0.7

    # Monitoring renforcé
    config.performance.performance_alerts_enabled = True
    config.performance.alert_on_loss_streak = 2

    return config


def get_prop_firm_priority_2_config() -> TradingConfig:
    """
    PRIORITÉ #2: Configuration prop firm avec nouveaux seuils
    """
    config = get_prop_firm_config()
    
    # Activation PRIORITÉ #2
    config.priority_2_enabled = True
    config.threshold_mode = Priority2Mode.NEW_THRESHOLDS
    
    # Ajustements pour fréquence accrue
    config.risk_management.max_daily_trades = 20  # Augmenté de 10
    config.risk_management.signal_frequency_multiplier = 2.0
    
    # Monitoring PRIORITÉ #2
    config.performance.track_frequency_boost = True
    config.performance.alert_on_frequency_target_miss = True
    
    logger.info("🎯 Configuration prop firm PRIORITÉ #2 créée")
    
    return config


def get_development_config() -> TradingConfig:
    """Configuration pour développement"""
    config = create_paper_trading_config()
    config.environment = "development"
    config.performance.detailed_logging_enabled = True
    config.ml.model_validation_required = False  # Plus rapide en dev
    return config

# === GLOBAL CONFIG INSTANCE ===


_global_config: Optional[TradingConfig] = None


def get_trading_config() -> TradingConfig:
    """Récupération configuration globale"""
    global _global_config
    if _global_config is None:
        _global_config = create_default_config()
    return _global_config


def set_trading_config(config: TradingConfig):
    """Définition configuration globale"""
    global _global_config
    _global_config = config
    logger.info("Configuration globale mise à jour")


def get_risk_config() -> RiskManagementConfig:
    """Raccourci vers risk management config"""
    return get_trading_config().risk_management


def get_feature_config() -> FeatureConfig:
    """Raccourci vers feature config"""
    return get_trading_config().features


def get_battle_navale_config() -> BattleNavaleConfig:
    """
    PRIORITÉ #2: Raccourci vers Battle Navale config
    """
    return get_trading_config().features.battle_navale_config


def get_priority_2_thresholds() -> Dict[str, float]:
    """
    PRIORITÉ #2: Raccourci vers seuils Battle Navale
    """
    return get_trading_config().get_battle_navale_thresholds()

# === TESTING ===


def test_trading_config():
    """Test configuration trading"""
    logger.info("🎯 Test trading config avec PRIORITÉ #2...")

    # Test config par défaut
    config = create_default_config()
    logger.info(f"Config par défaut: {config.trading_mode.value}")
    logger.info(f"Symboles: {list(config.symbols.keys())}")
    logger.info(f"Max position: {config.risk_management.max_position_size}")
    logger.info(f"Min confidence: {config.features.min_signal_confidence}")

    # === PRIORITÉ #2: TESTS SPÉCIFIQUES ===
    logger.info(f"PRIORITÉ #2 enabled: {config.priority_2_enabled}")
    logger.info(f"Threshold mode: {config.threshold_mode.value}")
    
    # Test seuils Battle Navale
    thresholds = config.get_battle_navale_thresholds()
    logger.info(f"Battle Navale thresholds: {thresholds}")
    
    # Test config PRIORITÉ #2
    priority_2_config = create_priority_2_config()
    priority_2_summary = priority_2_config.get_priority_2_summary()
    logger.info(f"PRIORITÉ #2 summary: {priority_2_summary}")

    # Test validation
    is_valid = config.validate()
    logger.info(f"Validation: {is_valid}")

    # Test Battle Navale config validation
    bn_valid = config.features.battle_navale_config.validate()
    logger.info(f"Battle Navale validation: {bn_valid}")

    # Test risk levels
    config.update_risk_level(RiskLevel.CONSERVATIVE)
    logger.info(f"Conservative risk: max pos = {config.risk_management.max_position_size}")

    # Test prop firm config PRIORITÉ #2
    prop_config_p2 = get_prop_firm_priority_2_config()
    logger.info(f"Prop firm P2: daily trades = {prop_config_p2.risk_management.max_daily_trades}")

    # Test changement mode seuils
    config.set_threshold_mode(Priority2Mode.OLD_THRESHOLDS)
    old_thresholds = config.get_battle_navale_thresholds()
    logger.info(f"Old thresholds: {old_thresholds}")

    config.set_threshold_mode(Priority2Mode.NEW_THRESHOLDS)
    new_thresholds = config.get_battle_navale_thresholds()
    logger.info(f"New thresholds: {new_thresholds}")

    # Test serialization
    config_dict = config.to_dict()
    logger.info(f"Serialization: {len(config_dict)} keys")
    logger.info(f"PRIORITÉ #2 dans dict: {'priority_2_enabled' in config_dict}")

    logger.info("✅ Trading config avec PRIORITÉ #2 test COMPLETED")
    return True


if __name__ == "__main__":
    test_trading_config()