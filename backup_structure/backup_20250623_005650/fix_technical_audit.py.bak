"""
MIA_IA_SYSTEM - Fix Technical Audit
Corrige le probleme Windows dans technical_audit.py
Version: Fix definitif du vrai probleme
"""

import re
from pathlib import Path
import shutil

def backup_original_audit():
    """Cree backup de l'audit original"""
    audit_file = Path("technical_audit.py")
    backup_file = Path("technical_audit.py.original")
    
    if audit_file.exists() and not backup_file.exists():
        shutil.copy2(audit_file, backup_file)
        print(f"‚úÖ Backup cr√©√©: {backup_file}")
        return True
    elif backup_file.exists():
        print(f"‚úÖ Backup existe d√©j√†: {backup_file}")
        return True
    else:
        print(f"‚ùå Fichier audit non trouv√©: {audit_file}")
        return False

def fix_windows_path_issue():
    """Fix le probleme chemins Windows dans technical_audit.py"""
    audit_file = Path("technical_audit.py")
    
    if not audit_file.exists():
        print(f"‚ùå {audit_file} non trouv√©")
        return False
    
    # Lire contenu
    content = audit_file.read_text(encoding='utf-8')
    original_content = content
    
    print("üîß CORRECTION PROBL√àME WINDOWS...")
    
    # Fix 1: Chemins Windows dans conversion module
    # Pattern: str(py_file.relative_to(self.project_root)).replace('/', '.').replace('.py', '')
    pattern1 = r"str\(py_file\.relative_to\(self\.project_root\)\)\.replace\('/', '\.'\)\.replace\('\.py', ''\)"
    replacement1 = r"str(py_file.relative_to(self.project_root)).replace('\\\\', '.').replace('/', '.').replace('.py', '')"
    
    if re.search(pattern1, content):
        content = re.sub(pattern1, replacement1, content)
        print("‚úÖ Fix 1: Chemins Windows corrig√©s")
    else:
        # Pattern alternatif plus flexible
        pattern1_alt = r"\.replace\('/', '\.'\)\.replace\('\.py', ''\)"
        replacement1_alt = r".replace('\\\\', '.').replace('/', '.').replace('.py', '')"
        
        if re.search(pattern1_alt, content):
            content = re.sub(pattern1_alt, replacement1_alt, content)
            print("‚úÖ Fix 1 (alternatif): Chemins Windows corrig√©s")
        else:
            print("‚ö†Ô∏è Fix 1: Pattern non trouv√©, recherche manuelle...")
            
            # Recherche manuelle et remplacement
            lines = content.split('\n')
            for i, line in enumerate(lines):
                if 'relative_to' in line and "replace('/', '.')" in line and '.py' in line:
                    # Remplacer cette ligne
                    new_line = line.replace("replace('/', '.')", "replace('\\\\', '.').replace('/', '.')")
                    lines[i] = new_line
                    print(f"‚úÖ Fix 1 (manuel): Ligne {i+1} corrig√©e")
            
            content = '\n'.join(lines)
    
    # Fix 2: Filtrer fichiers non-modules (optionnel mais recommand√©)
    # Ajouter filtrage pour √©viter d'importer scripts utilitaires
    filter_pattern = r"(python_files = \[f for f in python_files if \"__pycache__\" not in str\(f\)\])"
    filter_replacement = r"""\1
        
        # Filter out utility scripts and non-module files
        python_files = [f for f in python_files if (
            "__pycache__" not in str(f) and
            not f.name.startswith(('test_', 'fix_', 'performance_', 'audit_', 'quick_', 'ultimate_', 'corrected_', 'windows_')) and
            f.name not in ('main.py', 'setup.py') and
            f.parent.name in ('core', 'config', 'features', 'strategies')  # Only scan valid packages
        )]"""
    
    if re.search(filter_pattern, content):
        content = re.sub(filter_pattern, filter_replacement, content)
        print("‚úÖ Fix 2: Filtrage fichiers non-modules ajout√©")
    else:
        print("‚ö†Ô∏è Fix 2: Pattern filtrage non trouv√© (optionnel)")
    
    # V√©rifier si changements appliqu√©s
    if content != original_content:
        # Sauvegarder version corrig√©e
        audit_file.write_text(content, encoding='utf-8')
        print(f"‚úÖ {audit_file} corrig√© et sauvegard√©")
        return True
    else:
        print("‚ùå Aucun changement appliqu√©")
        return False

def verify_fix():
    """V√©rifie que le fix fonctionne"""
    print("\nüß™ V√âRIFICATION FIX...")
    
    # Test si le code se compile
    audit_file = Path("technical_audit.py")
    try:
        with open(audit_file, 'r', encoding='utf-8') as f:
            source = f.read()
        
        compile(source, str(audit_file), 'exec')
        print("‚úÖ Compilation: OK")
        
        # Test simulation import logic
        project_root = Path(".")
        test_file = project_root / "config" / "trading_config.py"
        
        if test_file.exists():
            relative_path = test_file.relative_to(project_root)
            
            # Test nouvelle logique
            file_module = str(relative_path).replace('\\', '.').replace('/', '.').replace('.py', '')
            print(f"‚úÖ Test conversion: config/trading_config.py ‚Üí {file_module}")
            
            if '\\' not in file_module and file_module == 'config.trading_config':
                print("‚úÖ Logique conversion: OK")
                return True
            else:
                print(f"‚ùå Logique conversion: NOK - {file_module}")
                return False
        else:
            print("‚ö†Ô∏è Fichier test non trouv√©, mais compilation OK")
            return True
            
    except Exception as e:
        print(f"‚ùå Erreur v√©rification: {e}")
        return False

def show_diff():
    """Montre diff√©rences avant/apr√®s"""
    original_file = Path("technical_audit.py.original")
    current_file = Path("technical_audit.py")
    
    if not original_file.exists():
        print("‚ö†Ô∏è Pas de backup original pour comparaison")
        return
    
    print("\nüìä DIFF√âRENCES APPLIQU√âES:")
    
    try:
        original_content = original_file.read_text(encoding='utf-8')
        current_content = current_file.read_text(encoding='utf-8')
        
        original_lines = original_content.split('\n')
        current_lines = current_content.split('\n')
        
        changes_found = False
        for i, (orig, curr) in enumerate(zip(original_lines, current_lines)):
            if orig != curr:
                changes_found = True
                print(f"Ligne {i+1}:")
                print(f"  AVANT: {orig}")
                print(f"  APR√àS: {curr}")
                print()
        
        if not changes_found:
            print("Aucune diff√©rence trouv√©e")
            
    except Exception as e:
        print(f"Erreur comparaison: {e}")

def main():
    """Fix principal technical_audit.py"""
    print("üöÄ FIX TECHNICAL AUDIT - PROBL√àME WINDOWS")
    print("=" * 50)
    
    # 1. Backup
    if not backup_original_audit():
        return False
    
    # 2. Appliquer fix
    if not fix_windows_path_issue():
        print("‚ùå Fix √©chou√©")
        return False
    
    # 3. V√©rifier fix
    if not verify_fix():
        print("‚ùå V√©rification √©chou√©e")
        return False
    
    # 4. Montrer diff√©rences
    show_diff()
    
    # 5. Instructions finales
    print("\nüéØ FIX APPLIQU√â AVEC SUCC√àS!")
    print("=" * 30)
    print("CHANGEMENTS:")
    print("  ‚úÖ Chemins Windows (backslashes) corrig√©s")
    print("  ‚úÖ Logique import r√©par√©e")
    print("  ‚úÖ Filtrage fichiers utilitaires (optionnel)")
    
    print("\nPROCHAINES √âTAPES:")
    print("  1. python technical_audit.py")
    print("  2. Score attendu: 85-90%+")
    print("  3. Si probl√®me: python technical_audit.py.original pour restaurer")
    
    return True

if __name__ == "__main__":
    success = main()
    
    if success:
        print("\nüöÄ PR√äT POUR AUDIT FINAL:")
        print("python technical_audit.py")
    else:
        print("\nüíÄ FIX √âCHOU√â - Debug manuel requis")