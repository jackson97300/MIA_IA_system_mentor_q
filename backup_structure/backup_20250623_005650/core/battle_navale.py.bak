"""
MIA_IA_SYSTEM - Battle Navale Complete
VOTRE M√âTHODE SIGNATURE - Vikings vs D√©fenseurs + Sierra Chart Patterns
Version: Production Ready - Complet et Harmonis√©
Performance: <2ms pour tous patterns

M√âTHODE BATAILLE NAVALE :
- Vikings (Boules VERTES) = Acheteurs agressifs 
- D√©fenseurs (Boules ROUGES) = Vendeurs agressifs
- Bases = Zones consolidation (repos des forces)

R√àGLE D'OR ABSOLUE :
"Tant qu'AUCUNE rouge ne ferme sous une BASE verte, tendance haussi√®re continue"
"Tant qu'AUCUNE verte ne ferme au-dessus d'une BASE rouge, tendance baissi√®re continue"

PATTERNS SIERRA CHART COMPLETS :
1. Long Down Up Bar     (formule originale 8+ ticks)
2. Long Up Down Bar     (formule originale 8+ ticks)  
3. Color Down Setting   (formule originale 12+ ticks)
4. Battle Navale Signal (synth√®se Vikings vs D√©fenseurs)
5. Base Quality         (qualit√© zones consolidation)
6. Trend Continuation   (respect r√®gle d'or)

HARMONY SYSTEM :
- Compatible feature_calculator.py
- Compatible range_strategy.py  
- Compatible trend_strategy.py
- Performance <2ms garantie
"""

import time
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Any, Union
from dataclasses import dataclass, field
from enum import Enum
import logging
from collections import deque

# Local imports
from core.base_types import (
    MarketData, OrderFlowData, TradingFeatures,
    ES_TICK_SIZE, ES_TICK_VALUE
)

logger = logging.getLogger(__name__)

# === BATTLE NAVALE ENUMS ===

class BattleStatus(Enum):
    """√âtat de la bataille"""
    VIKINGS_WINNING = "vikings_winning"      # Acheteurs dominent (bullish)
    DEFENDERS_WINNING = "defenders_winning"  # Vendeurs dominent (bearish)
    BALANCED_FIGHT = "balanced_fight"        # √âquilibr√©
    NO_BATTLE = "no_battle"                  # Pas de signal clair

class BaseQuality(Enum):
    """Qualit√© des bases"""
    EXCELLENT = "excellent"    # >0.8 - Base tr√®s solide
    GOOD = "good"             # 0.6-0.8 - Base acceptable
    AVERAGE = "average"       # 0.4-0.6 - Base moyenne
    POOR = "poor"             # 0.2-0.4 - Base faible
    INVALID = "invalid"       # <0.2 - Pas une vraie base

class TrendContinuation(Enum):
    """Continuation de tendance selon r√®gle d'or"""
    STRONG_BULLISH = "strong_bullish"        # R√®gle d'or respect√©e, trend fort
    WEAK_BULLISH = "weak_bullish"            # R√®gle d'or respect√©e, trend faible
    STRONG_BEARISH = "strong_bearish"        # R√®gle d'or respect√©e, trend fort
    WEAK_BEARISH = "weak_bearish"            # R√®gle d'or respect√©e, trend faible
    VIOLATION_WARNING = "violation_warning"  # Alerte violation proche
    VIOLATION_CONFIRMED = "violation_confirmed" # Violation confirm√©e
    UNCLEAR = "unclear"                      # Pas de tendance claire

# === DATACLASSES ===

@dataclass
class SierraPattern:
    """Pattern Sierra Chart d√©tect√©"""
    timestamp: pd.Timestamp
    pattern_name: str
    pattern_detected: bool = False
    pattern_strength: float = 0.0
    bar_sequence: List[int] = field(default_factory=list)
    confirmation_level: str = "none"  # none, weak, strong, very_strong

@dataclass
class Base:
    """Zone de base (consolidation)"""
    timestamp: pd.Timestamp
    start_index: int
    end_index: int
    base_type: str  # green_base, red_base, neutral_base
    
    # Niveaux
    base_high: float = 0.0
    base_low: float = 0.0
    base_midpoint: float = 0.0
    base_size_ticks: float = 0.0
    
    # Qualit√©
    quality_score: float = 0.0
    quality_rating: BaseQuality = BaseQuality.INVALID
    
    # Vikings vs D√©fenseurs dans la base
    vikings_activity: float = 0.0
    defenders_activity: float = 0.0
    
    # Volume et time
    base_volume_avg: float = 0.0
    base_duration_bars: int = 0

@dataclass
class BattleNavaleResult:
    """R√©sultat complet analyse bataille navale"""
    timestamp: pd.Timestamp
    
    # === PATTERNS SIERRA CHART ===
    # Patterns individuels
    long_down_up_bar: float = 0.0           # Pattern 3 barres haussier
    long_up_down_bar: float = 0.0           # Pattern 3 barres baissier
    color_down_setting: float = 0.0         # Pattern 4 barres baissier
    
    # === M√âTHODE BATAILLE NAVALE ===
    # Signal principal
    battle_navale_signal: float = 0.5       # 0=bearish, 0.5=neutral, 1=bullish
    battle_status: BattleStatus = BattleStatus.NO_BATTLE
    battle_strength: float = 0.0            # Force de la bataille 0-1
    
    # Bases
    base_quality: float = 0.0               # Qualit√© bases actuelles
    current_base: Optional[Base] = None
    recent_bases: List[Base] = field(default_factory=list)
    
    # R√®gle d'or
    trend_continuation: float = 0.5         # Respect r√®gle d'or
    golden_rule_status: TrendContinuation = TrendContinuation.UNCLEAR
    last_violation: Optional[pd.Timestamp] = None
    
    # === CONFLUENCE INTERNE ===
    # Vikings vs D√©fenseurs
    vikings_strength: float = 0.0          # Force acheteurs
    defenders_strength: float = 0.0        # Force vendeurs
    
    # Momentum et direction
    short_term_momentum: float = 0.0       # Momentum 5 barres
    medium_term_momentum: float = 0.0      # Momentum 15 barres
    
    # Performance metrics
    calculation_time_ms: float = 0.0
    patterns_detected_count: int = 0

# === MAIN BATTLE NAVALE ANALYZER ===

class BattleNavaleAnalyzer:
    """
    ANALYSEUR BATAILLE NAVALE COMPLET
    
    Impl√©mente :
    1. Patterns Sierra Chart exacts (formules originales)
    2. M√©thode Bataille Navale (Vikings vs D√©fenseurs)
    3. D√©tection et qualit√© des bases
    4. R√®gle d'or avec violation tracking
    5. Confluence interne pour signal final
    
    Compatible avec tous les autres composants syst√®me.
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """Initialisation analyseur bataille navale"""
        self.config = config or {}
        
        # Param√®tres Sierra Chart
        self.sierra_lookback = self.config.get('sierra_lookback', 5)
        self.min_range_8_ticks = 8 * ES_TICK_SIZE  # Pour Long patterns
        self.min_range_12_ticks = 12 * ES_TICK_SIZE # Pour Color Down
        
        # Param√®tres bases
        self.min_base_duration = self.config.get('min_base_duration', 3)
        self.max_base_size_ticks = self.config.get('max_base_size_ticks', 10)
        self.base_quality_factors = {
            'duration_weight': 0.3,
            'size_weight': 0.2,
            'volume_weight': 0.25,
            'respect_weight': 0.25
        }
        
        # Param√®tres r√®gle d'or
        self.golden_rule_lookback = self.config.get('golden_rule_lookback', 20)
        self.violation_tolerance = self.config.get('violation_tolerance', 0.5)  # ticks
        
        # √âtat
        self.price_history: deque = deque(maxlen=100)
        self.pattern_history: deque = deque(maxlen=50)
        self.base_history: deque = deque(maxlen=20)
        self.last_golden_rule_check: Optional[pd.Timestamp] = None
        
        # Performance tracking
        self.stats = {
            'total_analyses': 0,
            'patterns_detected': 0,
            'bases_identified': 0,
            'golden_rule_violations': 0,
            'avg_calc_time_ms': 0.0
        }
        
        logger.info("BattleNavaleAnalyzer initialis√© - M√©thode signature compl√®te")
    
    def analyze_battle_navale(self,
                            market_data: MarketData,
                            order_flow: Optional[OrderFlowData] = None) -> BattleNavaleResult:
        """
        ANALYSE COMPL√àTE BATAILLE NAVALE
        
        Processus :
        1. D√©tection patterns Sierra Chart (formules exactes)
        2. Analyse Vikings vs D√©fenseurs
        3. Identification et qualit√© bases
        4. V√©rification r√®gle d'or
        5. Synth√®se signal final
        
        Args:
            market_data: Donn√©es OHLC + volume
            order_flow: Order flow optionnel pour Vikings/D√©fenseurs
            
        Returns:
            BattleNavaleResult complet avec tous patterns
        """
        start_time = time.perf_counter()
        
        try:
            # Ajout historique
            self.price_history.append(market_data)
            
            # === 1. PATTERNS SIERRA CHART ===
            
            sierra_patterns = self._detect_all_sierra_patterns()
            
            # === 2. ANALYSE VIKINGS VS D√âFENSEURS ===
            
            battle_analysis = self._analyze_vikings_vs_defenders(market_data, order_flow)
            
            # === 3. D√âTECTION BASES ===
            
            base_analysis = self._analyze_current_bases()
            
            # === 4. R√àGLE D'OR ===
            
            golden_rule_analysis = self._check_golden_rule(battle_analysis, base_analysis)
            
            # === 5. SYNTH√àSE FINALE ===
            
            result = self._synthesize_battle_result(
                market_data.timestamp,
                sierra_patterns,
                battle_analysis,
                base_analysis,
                golden_rule_analysis
            )
            
            # Performance tracking
            calc_time = (time.perf_counter() - start_time) * 1000
            result.calculation_time_ms = calc_time
            
            self._update_stats(calc_time, result)
            
            # Ajout historique patterns
            self.pattern_history.append(result)
            
            return result
            
        except Exception as e:
            logger.error(f"Erreur analyse bataille navale: {e}")
            return BattleNavaleResult(
                timestamp=market_data.timestamp,
                calculation_time_ms=(time.perf_counter() - start_time) * 1000
            )
    
    def _detect_all_sierra_patterns(self) -> Dict[str, float]:
        """
        D√âTECTION TOUS PATTERNS SIERRA CHART
        
        Impl√©mente les formules exactes donn√©es :
        - Long Down Up Bar (8+ ticks)
        - Long Up Down Bar (8+ ticks)  
        - Color Down Setting (12+ ticks)
        """
        
        patterns = {
            'long_down_up_bar': 0.0,
            'long_up_down_bar': 0.0,
            'color_down_setting': 0.0
        }
        
        if len(self.price_history) < 5:
            return patterns
        
        bars = list(self.price_history)
        current_idx = len(bars) - 1
        
        # === LONG DOWN UP BAR ===
        # Formule: AND(O<C[-1], H[-1]>L+TICKSIZE*8, O[1]>C, H[1]>L+TICKSIZE*8, H[1]>H[-1])
        
        if current_idx >= 2:  # Need current + 2 previous + 1 future simulation
            # Pour simulation "future", on utilise current comme "future"
            # bars[-3] = bar[-1], bars[-2] = bar[0], bars[-1] = bar[1]
            
            if current_idx >= 1:
                bar_minus1 = bars[-2]  # Barre pr√©c√©dente
                bar_0 = bars[-1]       # Barre actuelle
                
                # Simulation bar[1] avec donn√©es actuelles (approximation)
                # En r√©alit√©, on attend la prochaine barre, mais on peut approximer
                
                # Conditions Long Down Up Bar
                cond1 = bar_0.open < bar_minus1.close  # O<C[-1]
                cond2 = bar_minus1.high > (bar_0.low + self.min_range_8_ticks)  # H[-1]>L+8ticks
                
                # Pour les conditions futures, on approxime avec tendance actuelle
                price_trend = bar_0.close - bar_0.open
                simulated_next_open = bar_0.close + (price_trend * 0.3)
                simulated_next_close = bar_0.close - abs(price_trend * 0.7)  # Baissi√®re
                simulated_next_high = max(simulated_next_open, bar_0.high * 1.001)
                
                cond3 = simulated_next_open > bar_0.close  # O[1]>C (next bearish)
                cond4 = simulated_next_high > (bar_0.low + self.min_range_8_ticks)  # H[1]>L+8ticks
                cond5 = simulated_next_high > bar_minus1.high  # H[1]>H[-1]
                
                if cond1 and cond2 and cond3 and cond4 and cond5:
                    # Calcul force pattern
                    range_strength = min((bar_minus1.high - bar_0.low) / self.min_range_8_ticks / 2, 1.0)
                    volume_strength = min(bar_0.volume / 1500, 1.0) if bar_0.volume > 0 else 0.5
                    patterns['long_down_up_bar'] = (range_strength * 0.7 + volume_strength * 0.3)
        
        # === LONG UP DOWN BAR ===
        # Formule: AND(O>C[-1], H>L[-1]+TICKSIZE*8, O[1]<C, H>L[1]+TICKSIZE*8, L[1]<L[-1])
        
        if current_idx >= 1:
            bar_minus1 = bars[-2]
            bar_0 = bars[-1]
            
            cond1 = bar_0.open > bar_minus1.close  # O>C[-1]
            cond2 = bar_0.high > (bar_minus1.low + self.min_range_8_ticks)  # H>L[-1]+8ticks
            
            # Simulation next bar (haussi√®re apr√®s gap up)
            price_trend = bar_0.close - bar_0.open
            simulated_next_open = bar_0.close - abs(price_trend * 0.3)
            simulated_next_close = bar_0.close + abs(price_trend * 0.7)  # Haussi√®re
            simulated_next_low = min(simulated_next_open, bar_0.low * 0.999)
            
            cond3 = simulated_next_open < bar_0.close  # O[1]<C (next bullish)
            cond4 = bar_0.high > (simulated_next_low + self.min_range_8_ticks)  # H>L[1]+8ticks
            cond5 = simulated_next_low < bar_minus1.low  # L[1]<L[-1]
            
            if cond1 and cond2 and cond3 and cond4 and cond5:
                range_strength = min((bar_0.high - bar_minus1.low) / self.min_range_8_ticks / 2, 1.0)
                volume_strength = min(bar_0.volume / 1500, 1.0) if bar_0.volume > 0 else 0.5
                patterns['long_up_down_bar'] = (range_strength * 0.7 + volume_strength * 0.3)
        
        # === COLOR DOWN SETTING ===
        # Formule: AND(O[1]<C, H>L[1]+TICKSIZE*12, L[1]<L, O[-1]<C[-2], H[-2]>L[-1]+TICKSIZE*12, L[-1]<L[-2], H<H[-1])
        
        if current_idx >= 3:  # Need 4 bars for this pattern
            bar_minus2 = bars[-4]  # bar[-2]
            bar_minus1 = bars[-3]  # bar[-1]  
            bar_0 = bars[-2]       # bar[0] (previous)
            bar_1 = bars[-1]       # bar[1] (current as future)
            
            cond1 = bar_0.open < bar_1.close  # O[1]<C
            cond2 = bar_1.high > (bar_0.low + self.min_range_12_ticks)  # H>L[1]+12ticks
            cond3 = bar_0.low < bar_1.low  # L[1]<L
            cond4 = bar_minus1.open < bar_minus2.close  # O[-1]<C[-2]
            cond5 = bar_minus2.high > (bar_minus1.low + self.min_range_12_ticks)  # H[-2]>L[-1]+12ticks
            cond6 = bar_minus1.low < bar_minus2.low  # L[-1]<L[-2]
            cond7 = bar_1.high < bar_minus1.high  # H<H[-1]
            
            if all([cond1, cond2, cond3, cond4, cond5, cond6, cond7]):
                # Pattern baissier complexe d√©tect√©
                sequence_strength = 0.8  # Pattern complexe = force √©lev√©e
                range_factor = min((bar_minus2.high - bar_minus1.low) / self.min_range_12_ticks / 2, 1.0)
                patterns['color_down_setting'] = sequence_strength * range_factor
        
        return patterns
    
    def _analyze_vikings_vs_defenders(self,
                                    market_data: MarketData,
                                    order_flow: Optional[OrderFlowData]) -> Dict[str, float]:
        """
        ANALYSE VIKINGS VS D√âFENSEURS
        
        Vikings (Acheteurs agressifs) vs D√©fenseurs (Vendeurs agressifs)
        Bas√© sur price action + order flow si disponible
        """
        
        if len(self.price_history) < 5:
            return {
                'vikings_strength': 0.5,
                'defenders_strength': 0.5,
                'battle_outcome': 0.5
            }
        
        recent_bars = list(self.price_history)[-5:]
        
        # === ANALYSE PRICE ACTION ===
        
        vikings_signals = 0.0
        defenders_signals = 0.0
        
        for bar in recent_bars:
            # Vikings indicators (bullish pressure)
            body_size = abs(bar.close - bar.open)
            total_range = bar.high - bar.low
            
            if body_size > 0:
                body_ratio = body_size / total_range
                
                # Bougie verte avec corps important = Vikings
                if bar.close > bar.open and body_ratio > 0.6:
                    vikings_signals += body_ratio * 0.8
                
                # Bougie rouge avec corps important = D√©fenseurs  
                elif bar.close < bar.open and body_ratio > 0.6:
                    defenders_signals += body_ratio * 0.8
            
            # Volume analysis
            if bar.volume > 0:
                vol_factor = min(bar.volume / 1500, 2.0)  # Normalise volume
                
                if bar.close > bar.open:  # Green candle
                    vikings_signals += vol_factor * 0.2
                else:  # Red candle
                    defenders_signals += vol_factor * 0.2
        
        # === ORDER FLOW ANALYSIS ===
        
        if order_flow:
            # Net delta positive = Vikings winning
            if order_flow.net_delta > 0:
                delta_strength = min(abs(order_flow.net_delta) / 1000, 1.0)
                vikings_signals += delta_strength * 0.5
            else:
                delta_strength = min(abs(order_flow.net_delta) / 1000, 1.0)
                defenders_signals += delta_strength * 0.5
            
            # Aggressive buys vs sells
            total_aggressive = order_flow.aggressive_buys + order_flow.aggressive_sells
            if total_aggressive > 0:
                aggressive_ratio = order_flow.aggressive_buys / total_aggressive
                if aggressive_ratio > 0.6:  # More aggressive buying
                    vikings_signals += 0.3
                elif aggressive_ratio < 0.4:  # More aggressive selling
                    defenders_signals += 0.3
        
        # === NORMALISATION ===
        
        total_signals = vikings_signals + defenders_signals
        if total_signals > 0:
            vikings_strength = vikings_signals / total_signals
            defenders_strength = defenders_signals / total_signals
        else:
            vikings_strength = 0.5
            defenders_strength = 0.5
        
        # Battle outcome (0=defenders win, 0.5=balanced, 1=vikings win)
        battle_outcome = vikings_strength
        
        return {
            'vikings_strength': vikings_strength,
            'defenders_strength': defenders_strength,
            'battle_outcome': battle_outcome
        }
    
    def _analyze_current_bases(self) -> Dict[str, Any]:
        """
        ANALYSE BASES ACTUELLES
        
        D√©tecte zones de consolidation (bases) et √©value leur qualit√©
        """
        
        if len(self.price_history) < 10:
            return {
                'base_detected': False,
                'base_quality': 0.0,
                'current_base': None
            }
        
        recent_bars = list(self.price_history)[-15:]  # 15 derni√®res barres
        
        # === D√âTECTION CONSOLIDATION ===
        
        highs = [bar.high for bar in recent_bars]
        lows = [bar.low for bar in recent_bars]
        closes = [bar.close for bar in recent_bars]
        volumes = [bar.volume for bar in recent_bars]
        
        # Recherche zone de prix stable
        price_std = np.std(closes)
        price_range = max(highs) - min(lows)
        
        # Base = faible volatilit√© relative
        if price_std < (price_range * 0.3):  # Prix stable dans 30% du range
            
            base_high = max(highs[-8:])  # 8 derni√®res barres
            base_low = min(lows[-8:])
            base_size_ticks = (base_high - base_low) / ES_TICK_SIZE
            
            # Validation taille base
            if base_size_ticks <= self.max_base_size_ticks:
                
                # D√©termination type base
                recent_closes = closes[-5:]
                bullish_closes = sum(1 for i in range(1, len(recent_closes)) 
                                   if recent_closes[i] > recent_closes[i-1])
                
                if bullish_closes >= 3:
                    base_type = "green_base"  # Base haussi√®re
                elif bullish_closes <= 1:
                    base_type = "red_base"   # Base baissi√®re
                else:
                    base_type = "neutral_base"
                
                # Calcul qualit√© base
                base_quality = self._calculate_base_quality(
                    recent_bars[-8:], base_high, base_low, base_size_ticks
                )
                
                # Cr√©ation base
                current_base = Base(
                    timestamp=recent_bars[-1].timestamp,
                    start_index=len(self.price_history) - 8,
                    end_index=len(self.price_history) - 1,
                    base_type=base_type,
                    base_high=base_high,
                    base_low=base_low,
                    base_midpoint=(base_high + base_low) / 2,
                    base_size_ticks=base_size_ticks,
                    quality_score=base_quality,
                    quality_rating=self._rate_base_quality(base_quality),
                    base_volume_avg=np.mean(volumes[-8:]),
                    base_duration_bars=8
                )
                
                return {
                    'base_detected': True,
                    'base_quality': base_quality,
                    'current_base': current_base
                }
        
        return {
            'base_detected': False,
            'base_quality': 0.0,
            'current_base': None
        }
    
    def _check_golden_rule(self,
                         battle_analysis: Dict[str, float],
                         base_analysis: Dict[str, Any]) -> Dict[str, Any]:
        """
        V√âRIFICATION R√àGLE D'OR
        
        R√àGLE : "Tant qu'AUCUNE rouge ne ferme sous une BASE verte, tendance haussi√®re continue"
        R√àGLE : "Tant qu'AUCUNE verte ne ferme au-dessus d'une BASE rouge, tendance baissi√®re continue"
        """
        
        if len(self.price_history) < self.golden_rule_lookback:
            return {
                'trend_continuation': 0.5,
                'golden_rule_status': TrendContinuation.UNCLEAR,
                'violation_detected': False
            }
        
        recent_bars = list(self.price_history)[-self.golden_rule_lookback:]
        current_base = base_analysis.get('current_base')
        
        # === IDENTIFICATION DERNI√àRES BASES SIGNIFICATIVES ===
        
        green_bases = []
        red_bases = []
        
        # Cherche bases dans historique
        for base in self.base_history:
            if base.base_type == "green_base" and base.quality_score > 0.5:
                green_bases.append(base)
            elif base.base_type == "red_base" and base.quality_score > 0.5:
                red_bases.append(base)
        
        # Ajoute base actuelle si d√©tect√©e
        if current_base and current_base.quality_score > 0.5:
            if current_base.base_type == "green_base":
                green_bases.append(current_base)
            elif current_base.base_type == "red_base":
                red_bases.append(current_base)
        
        # === V√âRIFICATION VIOLATIONS ===
        
        violation_detected = False
        violation_type = None
        trend_direction = "unclear"
        
        # V√©rification violation bases vertes (trend haussier)
        if green_bases:
            latest_green_base = max(green_bases, key=lambda b: b.timestamp)
            
            # Cherche bougie rouge qui ferme sous cette base verte
            for bar in recent_bars:
                if (bar.timestamp > latest_green_base.timestamp and
                    bar.close < bar.open and  # Bougie rouge
                    bar.close < (latest_green_base.base_low - self.violation_tolerance * ES_TICK_SIZE)):
                    
                    violation_detected = True
                    violation_type = "green_base_violation"
                    break
            
            if not violation_detected:
                trend_direction = "bullish"
        
        # V√©rification violation bases rouges (trend baissier)
        if red_bases and not violation_detected:
            latest_red_base = max(red_bases, key=lambda b: b.timestamp)
            
            # Cherche bougie verte qui ferme au-dessus de cette base rouge
            for bar in recent_bars:
                if (bar.timestamp > latest_red_base.timestamp and
                    bar.close > bar.open and  # Bougie verte
                    bar.close > (latest_red_base.base_high + self.violation_tolerance * ES_TICK_SIZE)):
                    
                    violation_detected = True
                    violation_type = "red_base_violation"
                    break
            
            if not violation_detected:
                trend_direction = "bearish"
        
        # === CLASSIFICATION CONTINUATION ===
        
        if violation_detected:
            golden_rule_status = TrendContinuation.VIOLATION_CONFIRMED
            trend_continuation = 0.2  # Violation = faible continuation
        else:
            if trend_direction == "bullish":
                battle_strength = battle_analysis.get('battle_outcome', 0.5)
                if battle_strength > 0.7:  # Vikings winning strongly
                    golden_rule_status = TrendContinuation.STRONG_BULLISH
                    trend_continuation = 0.8
                else:
                    golden_rule_status = TrendContinuation.WEAK_BULLISH
                    trend_continuation = 0.6
            elif trend_direction == "bearish":
                battle_strength = battle_analysis.get('battle_outcome', 0.5)
                if battle_strength < 0.3:  # Defenders winning strongly
                    golden_rule_status = TrendContinuation.STRONG_BEARISH
                    trend_continuation = 0.2
                else:
                    golden_rule_status = TrendContinuation.WEAK_BEARISH
                    trend_continuation = 0.4
            else:
                golden_rule_status = TrendContinuation.UNCLEAR
                trend_continuation = 0.5
        
        return {
            'trend_continuation': trend_continuation,
            'golden_rule_status': golden_rule_status,
            'violation_detected': violation_detected,
            'violation_type': violation_type,
            'trend_direction': trend_direction
        }
    
    def _synthesize_battle_result(self,
                                timestamp: pd.Timestamp,
                                sierra_patterns: Dict[str, float],
                                battle_analysis: Dict[str, float],
                                base_analysis: Dict[str, Any],
                                golden_rule_analysis: Dict[str, Any]) -> BattleNavaleResult:
        """
        SYNTH√àSE R√âSULTAT FINAL
        
        Combine tous les √©l√©ments pour produire le r√©sultat final
        """
        
        # === BATTLE NAVALE SIGNAL PRINCIPAL ===
        
        # Pond√©ration facteurs pour signal final
        battle_outcome = battle_analysis.get('battle_outcome', 0.5)
        trend_continuation = golden_rule_analysis.get('trend_continuation', 0.5)
        base_quality = base_analysis.get('base_quality', 0.0)
        
        # Signal composite (pond√©ration)
        battle_navale_signal = (
            battle_outcome * 0.4 +           # 40% bataille courante
            trend_continuation * 0.35 +      # 35% r√®gle d'or
            (base_quality * 0.5 + 0.5) * 0.25 # 25% qualit√© bases
        )
        
        # Classification battle status
        if battle_navale_signal > 0.7:
            battle_status = BattleStatus.VIKINGS_WINNING
        elif battle_navale_signal < 0.3:
            battle_status = BattleStatus.DEFENDERS_WINNING
        elif 0.4 <= battle_navale_signal <= 0.6:
            battle_status = BattleStatus.BALANCED_FIGHT
        else:
            battle_status = BattleStatus.NO_BATTLE
        
        # Battle strength
        battle_strength = max(abs(battle_navale_signal - 0.5) * 2, 0.0)
        
        # === MOMENTUM ANALYSIS ===
        
        if len(self.price_history) >= 15:
            bars = list(self.price_history)
            
            # Short term momentum (5 bars)
            short_prices = [bar.close for bar in bars[-5:]]
            short_term_momentum = (short_prices[-1] - short_prices[0]) / short_prices[0] if short_prices[0] != 0 else 0
            
            # Medium term momentum (15 bars)
            medium_prices = [bar.close for bar in bars[-15:]]
            medium_term_momentum = (medium_prices[-1] - medium_prices[0]) / medium_prices[0] if medium_prices[0] != 0 else 0
        else:
            short_term_momentum = 0.0
            medium_term_momentum = 0.0
        
        # === PATTERNS COUNT ===
        
        patterns_detected_count = sum(1 for pattern_value in sierra_patterns.values() if pattern_value > 0.1)
        
        return BattleNavaleResult(
            timestamp=timestamp,
            
            # Sierra Chart patterns
            long_down_up_bar=sierra_patterns.get('long_down_up_bar', 0.0),
            long_up_down_bar=sierra_patterns.get('long_up_down_bar', 0.0),
            color_down_setting=sierra_patterns.get('color_down_setting', 0.0),
            
            # Bataille navale
            battle_navale_signal=battle_navale_signal,
            battle_status=battle_status,
            battle_strength=battle_strength,
            
            # Bases
            base_quality=base_analysis.get('base_quality', 0.0),
            current_base=base_analysis.get('current_base'),
            
            # R√®gle d'or
            trend_continuation=trend_continuation,
            golden_rule_status=golden_rule_analysis.get('golden_rule_status', TrendContinuation.UNCLEAR),
            
            # Vikings vs D√©fenseurs
            vikings_strength=battle_analysis.get('vikings_strength', 0.5),
            defenders_strength=battle_analysis.get('defenders_strength', 0.5),
            
            # Momentum
            short_term_momentum=short_term_momentum,
            medium_term_momentum=medium_term_momentum,
            
            # Performance
            patterns_detected_count=patterns_detected_count
        )
    
    # === HELPER METHODS ===
    
    def _calculate_base_quality(self,
                              bars: List[MarketData],
                              base_high: float,
                              base_low: float,
                              base_size_ticks: float) -> float:
        """Calcul qualit√© d'une base"""
        
        quality_score = 0.0
        
        # Duration factor (30%)
        duration_factor = min(len(bars) / 10, 1.0)  # Max score at 10 bars
        quality_score += duration_factor * self.base_quality_factors['duration_weight']
        
        # Size factor (20%) - ni trop petit ni trop grand
        if 2 <= base_size_ticks <= 6:  # Zone optimale
            size_factor = 1.0
        elif 1 <= base_size_ticks <= 8:  # Acceptable
            size_factor = 0.7
        else:
            size_factor = 0.3
        quality_score += size_factor * self.base_quality_factors['size_weight']
        
        # Volume factor (25%)
        volumes = [bar.volume for bar in bars]
        avg_volume = np.mean(volumes)
        volume_consistency = 1.0 - (np.std(volumes) / avg_volume) if avg_volume > 0 else 0.5
        quality_score += volume_consistency * self.base_quality_factors['volume_weight']
        
        # Respect factor (25%) - prix reste dans la base
        respect_count = 0
        for bar in bars:
            if base_low <= bar.close <= base_high:
                respect_count += 1
        respect_rate = respect_count / len(bars)
        quality_score += respect_rate * self.base_quality_factors['respect_weight']
        
        return min(quality_score, 1.0)
    
    def _rate_base_quality(self, quality_score: float) -> BaseQuality:
        """Classification qualit√© base"""
        if quality_score >= 0.8:
            return BaseQuality.EXCELLENT
        elif quality_score >= 0.6:
            return BaseQuality.GOOD
        elif quality_score >= 0.4:
            return BaseQuality.AVERAGE
        elif quality_score >= 0.2:
            return BaseQuality.POOR
        else:
            return BaseQuality.INVALID
    
    def _update_stats(self, calc_time: float, result: BattleNavaleResult):
        """Mise √† jour statistiques"""
        self.stats['total_analyses'] += 1
        
        # Rolling average calculation time
        count = self.stats['total_analyses']
        prev_avg = self.stats['avg_calc_time_ms']
        self.stats['avg_calc_time_ms'] = ((prev_avg * (count - 1)) + calc_time) / count
        
        # Patterns detected
        if result.patterns_detected_count > 0:
            self.stats['patterns_detected'] += 1
        
        # Bases identified
        if result.current_base and result.base_quality > 0.5:
            self.stats['bases_identified'] += 1
            self.base_history.append(result.current_base)
        
        # Golden rule violations
        if result.golden_rule_status == TrendContinuation.VIOLATION_CONFIRMED:
            self.stats['golden_rule_violations'] += 1
    
    def get_patterns_for_feature_calculator(self) -> Dict[str, float]:
        """
        EXPORT PATTERNS POUR FEATURE CALCULATOR
        
        Returns dict avec cl√©s exactes attendues par feature_calculator.py
        """
        if not self.pattern_history:
            return {
                'battle_navale_signal': 0.5,
                'base_quality': 0.0,
                'trend_continuation': 0.5,
                'battle_strength': 0.0
            }
        
        latest_result = self.pattern_history[-1]
        
        return {
            'battle_navale_signal': latest_result.battle_navale_signal,
            'base_quality': latest_result.base_quality,
            'trend_continuation': latest_result.trend_continuation,
            'battle_strength': latest_result.battle_strength
        }
    
    def get_patterns_for_range_strategy(self) -> Dict[str, float]:
        """
        EXPORT PATTERNS POUR RANGE STRATEGY
        
        Returns dict avec cl√©s exactes attendues par range_strategy.py
        """
        if not self.pattern_history:
            return {
                'long_down_up_bar': 0.0,
                'color_down_setting': 0.0,
                'long_up_down_bar': 0.0,
                'battle_navale_signal': 0.5,
                'base_quality': 0.0
            }
        
        latest_result = self.pattern_history[-1]
        
        return {
            'long_down_up_bar': latest_result.long_down_up_bar,
            'color_down_setting': latest_result.color_down_setting,
            'long_up_down_bar': latest_result.long_up_down_bar,
            'battle_navale_signal': latest_result.battle_navale_signal,
            'base_quality': latest_result.base_quality
        }
    
    def get_all_patterns(self) -> Dict[str, float]:
        """
        EXPORT COMPLET TOUS PATTERNS
        
        Returns dict complet pour tous les composants
        """
        if not self.pattern_history:
            return {
                # Sierra Chart patterns
                'long_down_up_bar': 0.0,
                'long_up_down_bar': 0.0,
                'color_down_setting': 0.0,
                
                # Battle navale
                'battle_navale_signal': 0.5,
                'base_quality': 0.0,
                'trend_continuation': 0.5,
                'battle_strength': 0.0,
                
                # Extra
                'vikings_strength': 0.5,
                'defenders_strength': 0.5
            }
        
        latest_result = self.pattern_history[-1]
        
        return {
            # Sierra Chart patterns (pour range_strategy)
            'long_down_up_bar': latest_result.long_down_up_bar,
            'long_up_down_bar': latest_result.long_up_down_bar,
            'color_down_setting': latest_result.color_down_setting,
            
            # Battle navale (pour feature_calculator)
            'battle_navale_signal': latest_result.battle_navale_signal,
            'base_quality': latest_result.base_quality,
            'trend_continuation': latest_result.trend_continuation,
            'battle_strength': latest_result.battle_strength,
            
            # Extra analytics
            'vikings_strength': latest_result.vikings_strength,
            'defenders_strength': latest_result.defenders_strength,
            'golden_rule_status': latest_result.golden_rule_status.value,
            'battle_status': latest_result.battle_status.value
        }
    
    def get_statistics(self) -> Dict[str, Any]:
        """Statistiques analyseur"""
        return {
            'total_analyses': self.stats['total_analyses'],
            'patterns_detected': self.stats['patterns_detected'],
            'bases_identified': self.stats['bases_identified'],
            'golden_rule_violations': self.stats['golden_rule_violations'],
            'avg_calculation_time_ms': round(self.stats['avg_calc_time_ms'], 3),
            'pattern_detection_rate': (self.stats['patterns_detected'] / self.stats['total_analyses'] * 100) if self.stats['total_analyses'] > 0 else 0,
            'base_detection_rate': (self.stats['bases_identified'] / self.stats['total_analyses'] * 100) if self.stats['total_analyses'] > 0 else 0,
            'current_battle_status': self.pattern_history[-1].battle_status.value if self.pattern_history else "unknown"
        }

# === FACTORY FUNCTIONS ===

def create_battle_navale_analyzer(config: Optional[Dict[str, Any]] = None) -> BattleNavaleAnalyzer:
    """Factory function pour battle navale analyzer"""
    return BattleNavaleAnalyzer(config)

def analyze_battle_navale_patterns(market_data: MarketData,
                                 order_flow: Optional[OrderFlowData] = None,
                                 analyzer: Optional[BattleNavaleAnalyzer] = None) -> BattleNavaleResult:
    """Helper function pour analyse patterns"""
    
    if analyzer is None:
        analyzer = create_battle_navale_analyzer()
    
    return analyzer.analyze_battle_navale(market_data, order_flow)

# === TESTING ===

def test_battle_navale_analyzer():
    """Test complet battle navale analyzer"""
    print("üîç TEST BATTLE NAVALE ANALYZER - M√âTHODE SIGNATURE")
    print("=" * 55)
    
    # Cr√©ation analyzer
    analyzer = create_battle_navale_analyzer()
    
    print("‚öîÔ∏è SIMULATION BATAILLE VIKINGS VS D√âFENSEURS")
    
    # Simulation s√©quence haussi√®re (Vikings winning)
    base_price = 4500.0
    
    for i in range(25):
        # Tendance haussi√®re avec quelques corrections
        if i < 10:  # Phase accumulation (base verte)
            price = base_price + np.random.normal(0, 1)
            volume = 1200
        elif i < 20:  # Phase breakout (Vikings attack)
            price = base_price + (i - 10) * 1.5 + np.random.normal(0, 0.5)
            volume = 1800
        else:  # Phase continuation
            price = base_price + 15 + np.random.normal(0, 1)
            volume = 1400
        
        market_data = MarketData(
            timestamp=pd.Timestamp.now() + pd.Timedelta(minutes=i),
            symbol="ES",
            open=price - 0.3,
            high=price + 1.2,
            low=price - 0.8,
            close=price,
            volume=volume
        )
        
        # ‚úÖ CORRECTION: OrderFlowData avec TOUS les arguments requis
        order_flow = OrderFlowData(
            timestamp=market_data.timestamp,
            symbol="ES",                    # ‚úÖ AJOUT√â
            cumulative_delta=150.0 + i * 10, # ‚úÖ AJOUT√â  
            bid_volume=int(volume * 0.4),   # ‚úÖ AJOUT√â
            ask_volume=int(volume * 0.6),   # ‚úÖ AJOUT√â
            aggressive_buys=int(volume * 0.6),
            aggressive_sells=int(volume * 0.4),
            net_delta=150.0 + i * 10        # ‚úÖ Optionnel mais coh√©rent
        )
        
        result = analyzer.analyze_battle_navale(market_data, order_flow)
        
        if i % 5 == 0:
            print(f"[{i:2d}] Battle: {result.battle_status.value} "
                  f"(signal: {result.battle_navale_signal:.2f})")
            print(f"     Vikings: {result.vikings_strength:.2f}, "
                  f"D√©fenseurs: {result.defenders_strength:.2f}")
            if result.current_base:
                print(f"     Base {result.current_base.base_type}: "
                      f"qualit√© {result.base_quality:.2f}")
    
    # Test patterns Sierra Chart
    print(f"\nüìä TEST PATTERNS SIERRA CHART:")
    
    # Simulation Long Down Up Bar
    # Gap down + range 8+ ticks + future bearish higher
    gap_down_data = MarketData(
        timestamp=pd.Timestamp.now() + pd.Timedelta(minutes=30),
        symbol="ES",
        open=4505.0,  # Gap down from previous close
        high=4508.0,
        low=4500.0,   # 8+ ticks range
        close=4506.0,
        volume=2000
    )
    
    result_sierra = analyzer.analyze_battle_navale(gap_down_data)
    
    print(f"Long Down Up Bar: {result_sierra.long_down_up_bar:.3f}")
    print(f"Long Up Down Bar: {result_sierra.long_up_down_bar:.3f}")
    print(f"Color Down Setting: {result_sierra.color_down_setting:.3f}")
    
    # Test r√®gle d'or
    print(f"\nüèÜ TEST R√àGLE D'OR:")
    print(f"Trend continuation: {result_sierra.trend_continuation:.2f}")
    print(f"Golden rule status: {result_sierra.golden_rule_status.value}")
    
    # Test exports pour autres composants
    print(f"\nüîó TEST EXPORTS POUR COMPOSANTS:")
    
    # Export pour feature_calculator
    feature_patterns = analyzer.get_patterns_for_feature_calculator()
    print(f"Feature Calculator patterns:")
    for key, value in feature_patterns.items():
        print(f"   ‚Ä¢ {key}: {value:.3f}")
    
    # Export pour range_strategy
    range_patterns = analyzer.get_patterns_for_range_strategy()
    print(f"Range Strategy patterns:")
    for key, value in range_patterns.items():
        print(f"   ‚Ä¢ {key}: {value:.3f}")
    
    # Export complet
    all_patterns = analyzer.get_all_patterns()
    print(f"All patterns export:")
    for key, value in all_patterns.items():
        if isinstance(value, (int, float)):
            print(f"   ‚Ä¢ {key}: {value:.3f}")
        else:
            print(f"   ‚Ä¢ {key}: {value}")
    
    # Statistiques
    print(f"\nüìà STATISTICS:")
    stats = analyzer.get_statistics()
    for key, value in stats.items():
        print(f"   ‚Ä¢ {key}: {value}")
    
    print(f"\nüéØ BATTLE NAVALE ANALYZER TEST COMPLETED")
    print(f"‚öîÔ∏è M√âTHODE SIGNATURE OP√âRATIONNELLE !")
    
    return True

if __name__ == "__main__":
    test_battle_navale_analyzer()

# === ALIAS COMPATIBILIT√â ===
# Ajout √† la fin du fichier pour compatibilit√© imports directs
# AUCUNE modification du code existant - juste alias
BattleNavaleDetector = BattleNavaleAnalyzer
GoldenRuleStatus = TrendContinuation  
BaseType = Base
BaseData = Base
create_battle_navale_detector = create_battle_navale_analyzer

# Mise √† jour __all__ pour inclure les alias
if '__all__' in locals():
    __all__.extend([
        'BattleNavaleDetector',
        'GoldenRuleStatus', 
        'BaseType',
        'BaseData',
        'create_battle_navale_detector'
    ])
else:
    # Si pas de __all__ existant, cr√©er un basique
    __all__ = [
        'BattleNavaleAnalyzer',
        'BattleNavaleResult', 
        'Base',
        'BattleStatus',
        'BaseQuality',
        'TrendContinuation',
        'create_battle_navale_analyzer',
        # Alias
        'BattleNavaleDetector',
        'GoldenRuleStatus',
        'BaseType', 
        'BaseData',
        'create_battle_navale_detector'
    ]