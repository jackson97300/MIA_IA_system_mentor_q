"""
scripts/start_automation.py

SCRIPT D√âMARRAGE AUTOMATION - OBJECTIF PRIORIT√â 9
Interface simple pour lancer l'automation Battle Navale en diff√©rents modes
Point d'entr√©e unique pour production, test, et collection de donn√©es

FONCTIONNALIT√âS :
1. start_paper_trading() - D√©marrage paper trading s√©curis√©
2. start_data_collection() - Collection donn√©es sans trading
3. start_live_trading() - Trading live avec capitaux r√©els
4. emergency_stop_all() - Arr√™t d'urgence syst√®me complet
5. Monitoring int√©gr√© et gestion erreurs
6. Configuration dynamique par mode
7. Logging d√©taill√© et alertes

ARCHITECTURE : Production-ready, failsafe, monitoring complet
"""

# === STDLIB ===
import os
import sys
import time
import signal
import logging
import argparse
import threading
import subprocess
from typing import Dict, List, Optional, Any
from pathlib import Path
from datetime import datetime, timezone
from enum import Enum
import json
import psutil

# === THIRD-PARTY ===
import numpy as np
import pandas as pd

# === LOCAL IMPORTS ===
# Configuration
from config import get_trading_config, get_automation_config

# Core Battle Navale
from core.base_types import (
    MarketData, TradingSignal, SignalType,
    TradeResult, ES_TICK_SIZE, ES_TICK_VALUE
)

# Logger
logger = logging.getLogger(__name__)

# === AUTOMATION ENUMS ===

class AutomationMode(Enum):
    """Modes d'automation"""
    PAPER_TRADING = "paper_trading"      # Paper trading s√©curis√©
    DATA_COLLECTION = "data_collection"  # Collection donn√©es uniquement
    LIVE_TRADING = "live_trading"        # Trading avec capital r√©el
    BACKTEST = "backtest"               # Backtest historique
    VALIDATION = "validation"           # Validation mod√®les

class SystemStatus(Enum):
    """√âtats du syst√®me"""
    STOPPED = "stopped"
    STARTING = "starting"
    RUNNING = "running"
    STOPPING = "stopping"
    ERROR = "error"
    EMERGENCY_STOP = "emergency_stop"

class AutomationHealth(Enum):
    """Sant√© de l'automation"""
    HEALTHY = "healthy"
    WARNING = "warning"
    CRITICAL = "critical"
    FAILURE = "failure"

# === AUTOMATION MANAGER ===

class AutomationManager:
    """
    GESTIONNAIRE CENTRAL D'AUTOMATION
    
    Orchestrateur principal pour tous les modes d'automation :
    - Gestion lifecycle (start/stop/restart)
    - Monitoring temps r√©el
    - Gestion erreurs et recovery
    - Coordination composants
    - S√©curit√© et failsafes
    """
    
    def __init__(self):
        """Initialisation du gestionnaire d'automation"""
        
        # Configuration
        self.trading_config = get_trading_config()
        self.auto_config = get_automation_config()
        
        # √âtat syst√®me
        self.status = SystemStatus.STOPPED
        self.current_mode: Optional[AutomationMode] = None
        self.health = AutomationHealth.HEALTHY
        self.start_time: Optional[datetime] = None
        
        # Composants principaux (simul√©s pour cette phase)
        self.trader = None
        self.snapshotter = None
        self.monitor = None
        self.performance_tracker = None
        self.alert_system = None
        self.data_collector = None
        self.ml_model = None
        
        # Threads de monitoring
        self.monitoring_thread: Optional[threading.Thread] = None
        self.health_check_thread: Optional[threading.Thread] = None
        
        # Flags de contr√¥le
        self.shutdown_requested = False
        self.emergency_stop_triggered = False
        
        # Paths et logging
        self.log_dir = Path("logs/automation")
        self.log_dir.mkdir(parents=True, exist_ok=True)
        
        # Setup signal handlers pour arr√™t propre
        self._setup_signal_handlers()
        
        logger.info("AutomationManager initialis√©")
    
    def start_paper_trading(self, 
                           duration_hours: Optional[int] = None,
                           max_trades: Optional[int] = None) -> bool:
        """
        D√©marrage paper trading s√©curis√©
        
        Args:
            duration_hours: Dur√©e maximale en heures (None = illimit√©)
            max_trades: Nombre maximum de trades (None = illimit√©)
            
        Returns:
            True si d√©marrage r√©ussi, False sinon
        """
        logger.info("=== D√âMARRAGE PAPER TRADING ===")
        
        if self.status != SystemStatus.STOPPED:
            logger.error(f"Impossible de d√©marrer - Status actuel: {self.status.value}")
            return False
        
        try:
            self.status = SystemStatus.STARTING
            self.current_mode = AutomationMode.PAPER_TRADING
            
            # 1. Initialisation composants paper trading
            self._initialize_paper_trading_components()
            
            # 2. Validation configuration
            if not self._validate_paper_trading_config():
                self.status = SystemStatus.ERROR
                return False
            
            # 3. Setup monitoring
            self._setup_monitoring()
            
            # 4. Configuration limites s√©curit√©
            self._setup_paper_trading_limits(duration_hours, max_trades)
            
            # 5. D√©marrage trader (simul√©)
            logger.info("D√©marrage trader en mode PAPER...")
            
            # 6. D√©marrage monitoring
            self._start_monitoring_threads()
            
            # 7. Finalisation
            self.status = SystemStatus.RUNNING
            self.start_time = datetime.now(timezone.utc)
            
            logger.info("‚úÖ Paper trading d√©marr√© avec succ√®s")
            logger.info(f"Configuration: Dur√©e={duration_hours}h, Max trades={max_trades}")
            
            return True
            
        except Exception as e:
            logger.error(f"Erreur d√©marrage paper trading: {e}")
            self.status = SystemStatus.ERROR
            self.emergency_stop_all()
            return False
    
    def start_data_collection(self, 
                             collection_hours: Optional[int] = None,
                             target_samples: Optional[int] = None) -> bool:
        """
        D√©marrage collection de donn√©es sans trading
        
        Args:
            collection_hours: Dur√©e collection en heures
            target_samples: Nombre cible d'√©chantillons
            
        Returns:
            True si d√©marrage r√©ussi, False sinon
        """
        logger.info("=== D√âMARRAGE DATA COLLECTION ===")
        
        if self.status != SystemStatus.STOPPED:
            logger.error(f"Impossible de d√©marrer - Status actuel: {self.status.value}")
            return False
        
        try:
            self.status = SystemStatus.STARTING
            self.current_mode = AutomationMode.DATA_COLLECTION
            
            # 1. Initialisation composants collection
            self._initialize_data_collection_components()
            
            # 2. Configuration collection
            collection_config = {
                "duration_hours": collection_hours or 8,
                "target_samples": target_samples or 1000,
                "include_market_data": True,
                "include_signals": True,
                "include_snapshots": True
            }
            
            # 3. D√©marrage collection
            logger.info("D√©marrage collection donn√©es...")
            
            # 4. Setup monitoring l√©ger
            self._setup_data_collection_monitoring()
            
            # 5. Finalisation
            self.status = SystemStatus.RUNNING
            self.start_time = datetime.now(timezone.utc)
            
            logger.info("‚úÖ Data collection d√©marr√©e avec succ√®s")
            logger.info(f"Configuration: {collection_config}")
            
            return True
            
        except Exception as e:
            logger.error(f"Erreur d√©marrage data collection: {e}")
            self.status = SystemStatus.ERROR
            return False
    
    def start_live_trading(self, 
                          capital_limit: Optional[float] = None,
                          max_position_size: Optional[int] = None) -> bool:
        """
        D√©marrage trading live avec capital r√©el - S√âCURIT√â MAXIMALE
        
        Args:
            capital_limit: Limite de capital √† risquer
            max_position_size: Taille maximale position
            
        Returns:
            True si d√©marrage r√©ussi, False sinon
        """
        logger.info("=== D√âMARRAGE LIVE TRADING ===")
        logger.warning("‚ö†Ô∏è  ATTENTION: TRADING AVEC CAPITAL R√âEL ‚ö†Ô∏è")
        
        if self.status != SystemStatus.STOPPED:
            logger.error(f"Impossible de d√©marrer - Status actuel: {self.status.value}")
            return False
        
        try:
            self.status = SystemStatus.STARTING
            self.current_mode = AutomationMode.LIVE_TRADING
            
            # 1. VALIDATIONS S√âCURIT√â CRITIQUES
            if not self._validate_live_trading_safety():
                logger.error("üö® VALIDATION S√âCURIT√â √âCHEC - ARR√äT")
                self.status = SystemStatus.ERROR
                return False
            
            # 2. Confirmation utilisateur obligatoire
            if not self._confirm_live_trading():
                logger.info("Live trading annul√© par utilisateur")
                self.status = SystemStatus.STOPPED
                return False
            
            # 3. Initialisation composants live trading
            self._initialize_live_trading_components()
            
            # 4. Configuration limites strictes
            self._setup_live_trading_limits(capital_limit, max_position_size)
            
            # 5. Test connexions critiques
            if not self._test_live_connections():
                logger.error("Test connexions live √©chec")
                self.status = SystemStatus.ERROR
                return False
            
            # 6. D√©marrage avec monitoring renforc√©
            self._setup_live_monitoring()
            
            # 7. D√©marrage trader live
            logger.info("üöÄ D√©marrage trader en mode LIVE...")
            
            # 8. Monitoring threads
            self._start_monitoring_threads()
            
            # 9. Finalisation
            self.status = SystemStatus.RUNNING
            self.start_time = datetime.now(timezone.utc)
            
            logger.info("‚úÖ Live trading d√©marr√© avec CAPITAL R√âEL")
            logger.warning("üî¥ SURVEILLANCE CONTINUE REQUISE")
            
            return True
            
        except Exception as e:
            logger.error(f"Erreur critique live trading: {e}")
            self.status = SystemStatus.ERROR
            self.emergency_stop_all()
            return False
    
    def emergency_stop_all(self) -> bool:
        """
        Arr√™t d'urgence complet du syst√®me
        
        Returns:
            True si arr√™t r√©ussi, False sinon
        """
        logger.warning("üö® ARR√äT D'URGENCE D√âCLENCH√â üö®")
        
        self.emergency_stop_triggered = True
        self.status = SystemStatus.EMERGENCY_STOP
        
        try:
            # 1. Arr√™t imm√©diat trader
            if self.trader:
                logger.info("Arr√™t d'urgence trader...")
                # self.trader.emergency_stop()
            
            # 2. Fermeture positions ouvertes
            self._close_all_positions_emergency()
            
            # 3. Arr√™t composants
            self._stop_all_components()
            
            # 4. Arr√™t threads
            self._stop_monitoring_threads()
            
            # 5. Sauvegarde √©tat d'urgence
            self._save_emergency_state()
            
            # 6. Finalisation
            self.status = SystemStatus.STOPPED
            self.current_mode = None
            
            logger.info("‚úÖ Arr√™t d'urgence termin√©")
            return True
            
        except Exception as e:
            logger.error(f"Erreur lors arr√™t d'urgence: {e}")
            return False
    
    def get_system_status(self) -> Dict[str, Any]:
        """
        Statut complet du syst√®me
        
        Returns:
            Dictionnaire avec statut d√©taill√©
        """
        runtime = None
        if self.start_time:
            runtime = (datetime.now(timezone.utc) - self.start_time).total_seconds()
        
        return {
            "status": self.status.value,
            "mode": self.current_mode.value if self.current_mode else None,
            "health": self.health.value,
            "start_time": self.start_time.isoformat() if self.start_time else None,
            "runtime_seconds": runtime,
            "emergency_stop": self.emergency_stop_triggered,
            "components": {
                "trader": self.trader is not None,
                "monitor": self.monitor is not None,
                "data_collector": self.data_collector is not None,
            },
            "system_resources": self._get_system_resources()
        }
    
    def stop_automation(self) -> bool:
        """
        Arr√™t propre de l'automation
        
        Returns:
            True si arr√™t r√©ussi, False sinon
        """
        logger.info("D√©but arr√™t propre automation...")
        
        if self.status == SystemStatus.STOPPED:
            logger.info("Syst√®me d√©j√† arr√™t√©")
            return True
        
        try:
            self.status = SystemStatus.STOPPING
            self.shutdown_requested = True
            
            # 1. Arr√™t propre trader
            if self.trader:
                logger.info("Arr√™t propre trader...")
                # self.trader.stop_trading()
            
            # 2. Finalisation snapshots
            if self.snapshotter:
                logger.info("Finalisation snapshots...")
                # self.snapshotter.finalize_session()
            
            # 3. Arr√™t monitoring
            self._stop_monitoring_threads()
            
            # 4. Sauvegarde finale
            self._save_final_state()
            
            # 5. Finalisation
            self.status = SystemStatus.STOPPED
            self.current_mode = None
            
            logger.info("‚úÖ Arr√™t propre termin√©")
            return True
            
        except Exception as e:
            logger.error(f"Erreur arr√™t propre: {e}")
            return self.emergency_stop_all()
    
    # === M√âTHODES PRIV√âES ===
    
    def _setup_signal_handlers(self):
        """Configuration gestionnaires de signaux"""
        def signal_handler(signum, frame):
            logger.warning(f"Signal {signum} re√ßu - arr√™t propre...")
            self.stop_automation()
            sys.exit(0)
        
        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)
    
    def _initialize_paper_trading_components(self):
        """Initialisation composants pour paper trading"""
        logger.info("Initialisation composants paper trading...")
        
        # Simulation des composants (√† remplacer par vrais imports)
        self.trader = "SimulatedTrader"
        self.snapshotter = "SimulatedSnapshotter"
        self.monitor = "SimulatedMonitor"
        
        logger.info("Composants paper trading initialis√©s")
    
    def _initialize_data_collection_components(self):
        """Initialisation composants pour collection donn√©es"""
        logger.info("Initialisation composants data collection...")
        
        # Simulation des composants
        self.data_collector = "SimulatedDataCollector"
        self.snapshotter = "SimulatedSnapshotter"
        
        logger.info("Composants data collection initialis√©s")
    
    def _initialize_live_trading_components(self):
        """Initialisation composants pour live trading"""
        logger.info("Initialisation composants live trading...")
        
        # Simulation des composants
        self.trader = "LiveTrader"
        self.snapshotter = "LiveSnapshotter"
        self.monitor = "LiveMonitor"
        self.alert_system = "LiveAlertSystem"
        
        logger.info("Composants live trading initialis√©s")
    
    def _validate_paper_trading_config(self) -> bool:
        """Validation configuration paper trading"""
        logger.info("Validation configuration paper trading...")
        
        # Validations basiques
        if not self.trading_config:
            logger.error("Configuration trading manquante")
            return False
        
        if not self.auto_config:
            logger.error("Configuration automation manquante")
            return False
        
        logger.info("‚úÖ Configuration paper trading valid√©e")
        return True
    
    def _validate_live_trading_safety(self) -> bool:
        """Validation s√©curit√© critique pour live trading"""
        logger.info("üîç Validation s√©curit√© live trading...")
        
        safety_checks = []
        
        # 1. Configuration pr√©sente
        if self.trading_config and self.auto_config:
            safety_checks.append("Configuration OK")
        else:
            logger.error("‚ùå Configuration manquante")
            return False
        
        # 2. Limites de risque configur√©es
        if hasattr(self.auto_config, 'max_daily_loss') and self.auto_config.max_daily_loss > 0:
            safety_checks.append("Limites risque configur√©es")
        else:
            logger.error("‚ùå Limites de risque non configur√©es")
            return False
        
        # 3. Mode paper valid√© avant
        # TODO: V√©rifier historique paper trading
        safety_checks.append("Paper trading prerequis OK")
        
        # 4. Validation mod√®le
        # TODO: V√©rifier performance mod√®le ML
        safety_checks.append("Mod√®le valid√©")
        
        logger.info(f"‚úÖ Validation s√©curit√©: {len(safety_checks)} checks OK")
        for check in safety_checks:
            logger.info(f"  ‚úì {check}")
        
        return True
    
    def _confirm_live_trading(self) -> bool:
        """Confirmation utilisateur pour live trading"""
        logger.warning("‚ö†Ô∏è  CONFIRMATION REQUISE POUR LIVE TRADING ‚ö†Ô∏è")
        
        # En production, demander confirmation interactive
        # Pour ce script, on simule une confirmation
        
        confirmation_text = """
        üö® ATTENTION: TRADING AVEC CAPITAL R√âEL üö®
        
        Vous √™tes sur le point de d√©marrer le trading automatique
        avec de l'argent r√©el. Ceci peut entra√Æner des pertes.
        
        Confirmez-vous vouloir continuer ? (yes/no): 
        """
        
        # Simulation: en production, utiliser input()
        # response = input(confirmation_text).lower().strip()
        # return response == "yes"
        
        # Pour cette d√©mo, on simule une confirmation
        logger.warning("Confirmation automatique activ√©e pour d√©mo")
        return True
    
    def _setup_monitoring(self):
        """Configuration monitoring standard"""
        logger.info("Configuration monitoring...")
        
        # Setup monitoring components (simul√©)
        self.monitor = "StandardMonitor"
        self.performance_tracker = "StandardPerformanceTracker"
        
        logger.info("Monitoring configur√©")
    
    def _setup_data_collection_monitoring(self):
        """Configuration monitoring pour data collection"""
        logger.info("Configuration monitoring data collection...")
        
        # Monitoring l√©ger pour collection donn√©es
        self.monitor = "DataCollectionMonitor"
        
        logger.info("Monitoring data collection configur√©")
    
    def _setup_live_monitoring(self):
        """Configuration monitoring renforc√© pour live trading"""
        logger.info("Configuration monitoring live renforc√©...")
        
        # Monitoring complet pour live trading
        self.monitor = "LiveMonitorReinforced"
        self.performance_tracker = "LivePerformanceTracker"
        self.alert_system = "LiveAlertSystem"
        
        logger.info("Monitoring live renforc√© configur√©")
    
    def _setup_paper_trading_limits(self, duration_hours, max_trades):
        """Configuration limites paper trading"""
        limits = {
            "duration_hours": duration_hours or 24,
            "max_trades": max_trades or 100,
            "max_position_size": 1,  # 1 contrat max en paper
            "max_daily_loss": 500   # $500 max loss simul√©
        }
        
        logger.info(f"Limites paper trading: {limits}")
    
    def _setup_live_trading_limits(self, capital_limit, max_position_size):
        """Configuration limites strictes live trading"""
        limits = {
            "capital_limit": capital_limit or 5000,  # $5000 max par d√©faut
            "max_position_size": max_position_size or 1,  # 1 contrat max
            "max_daily_loss": 200,  # $200 max loss par jour
            "max_daily_trades": 10,  # 10 trades max par jour
            "stop_loss_mandatory": True
        }
        
        logger.warning(f"üîí Limites STRICTES live trading: {limits}")
    
    def _test_live_connections(self) -> bool:
        """Test connexions critiques pour live trading"""
        logger.info("Test connexions live...")
        
        # Test connexions broker, donn√©es, etc.
        connections_ok = [
            "Broker connection OK",
            "Market data feed OK", 
            "Risk management system OK"
        ]
        
        for connection in connections_ok:
            logger.info(f"‚úì {connection}")
        
        return True
    
    def _start_monitoring_threads(self):
        """D√©marrage threads de monitoring"""
        logger.info("D√©marrage threads monitoring...")
        
        # Thread monitoring principal
        self.monitoring_thread = threading.Thread(
            target=self._monitoring_loop,
            daemon=True
        )
        self.monitoring_thread.start()
        
        # Thread health check
        self.health_check_thread = threading.Thread(
            target=self._health_check_loop,
            daemon=True
        )
        self.health_check_thread.start()
        
        logger.info("Threads monitoring d√©marr√©s")
    
    def _monitoring_loop(self):
        """Boucle principale de monitoring"""
        logger.info("D√©marrage boucle monitoring...")
        
        while not self.shutdown_requested and self.status == SystemStatus.RUNNING:
            try:
                # Monitoring des composants
                self._check_components_health()
                
                # Monitoring performance
                self._check_performance_metrics()
                
                # Monitoring ressources syst√®me
                self._check_system_resources()
                
                # Pause
                time.sleep(30)  # Check toutes les 30 secondes
                
            except Exception as e:
                logger.error(f"Erreur monitoring loop: {e}")
                time.sleep(10)
        
        logger.info("Arr√™t boucle monitoring")
    
    def _health_check_loop(self):
        """Boucle de v√©rification sant√© syst√®me"""
        logger.info("D√©marrage health check...")
        
        while not self.shutdown_requested and self.status == SystemStatus.RUNNING:
            try:
                # Health check complet
                self._perform_health_check()
                
                # Pause plus longue pour health check
                time.sleep(60)  # Check toutes les minutes
                
            except Exception as e:
                logger.error(f"Erreur health check: {e}")
                time.sleep(30)
        
        logger.info("Arr√™t health check")
    
    def _check_components_health(self):
        """V√©rification sant√© des composants"""
        # Simulation check composants
        if self.current_mode == AutomationMode.LIVE_TRADING:
            # Checks plus stricts en live
            pass
        
        # logger.debug("Components health OK")
    
    def _check_performance_metrics(self):
        """V√©rification m√©triques de performance"""
        # Simulation check performance
        # logger.debug("Performance metrics OK")
        pass
    
    def _check_system_resources(self):
        """V√©rification ressources syst√®me"""
        try:
            cpu_percent = psutil.cpu_percent()
            memory = psutil.virtual_memory()
            
            if cpu_percent > 90:
                logger.warning(f"‚ö†Ô∏è CPU √©lev√©: {cpu_percent}%")
                self.health = AutomationHealth.WARNING
            
            if memory.percent > 90:
                logger.warning(f"‚ö†Ô∏è M√©moire √©lev√©e: {memory.percent}%")
                self.health = AutomationHealth.WARNING
                
        except Exception as e:
            logger.error(f"Erreur check ressources: {e}")
    
    def _perform_health_check(self):
        """Health check complet du syst√®me"""
        try:
            # Reset health status
            self.health = AutomationHealth.HEALTHY
            
            # V√©rifications selon le mode
            if self.current_mode == AutomationMode.LIVE_TRADING:
                self._live_trading_health_check()
            elif self.current_mode == AutomationMode.PAPER_TRADING:
                self._paper_trading_health_check()
            elif self.current_mode == AutomationMode.DATA_COLLECTION:
                self._data_collection_health_check()
            
        except Exception as e:
            logger.error(f"Erreur health check: {e}")
            self.health = AutomationHealth.FAILURE
    
    def _live_trading_health_check(self):
        """Health check sp√©cifique live trading"""
        # Checks critiques pour live trading
        checks_passed = 0
        total_checks = 5
        
        # 1. Connexion broker
        if self.trader:
            checks_passed += 1
        
        # 2. Donn√©es march√©
        checks_passed += 1
        
        # 3. Syst√®me risque
        checks_passed += 1
        
        # 4. Performance dans limites
        checks_passed += 1
        
        # 5. Pas de situations d'urgence
        if not self.emergency_stop_triggered:
            checks_passed += 1
        
        # √âvaluation sant√©
        if checks_passed == total_checks:
            self.health = AutomationHealth.HEALTHY
        elif checks_passed >= 4:
            self.health = AutomationHealth.WARNING
        else:
            self.health = AutomationHealth.CRITICAL
            logger.error(f"üö® SANT√â CRITIQUE: {checks_passed}/{total_checks} checks OK")
    
    def _paper_trading_health_check(self):
        """Health check pour paper trading"""
        self.health = AutomationHealth.HEALTHY  # Moins critique
    
    def _data_collection_health_check(self):
        """Health check pour data collection"""
        self.health = AutomationHealth.HEALTHY  # Moins critique
    
    def _stop_monitoring_threads(self):
        """Arr√™t des threads de monitoring"""
        logger.info("Arr√™t threads monitoring...")
        
        self.shutdown_requested = True
        
        # Attendre arr√™t threads
        if self.monitoring_thread and self.monitoring_thread.is_alive():
            self.monitoring_thread.join(timeout=5)
        
        if self.health_check_thread and self.health_check_thread.is_alive():
            self.health_check_thread.join(timeout=5)
        
        logger.info("Threads monitoring arr√™t√©s")
    
    def _close_all_positions_emergency(self):
        """Fermeture d'urgence toutes positions"""
        logger.warning("üö® Fermeture d'urgence positions...")
        
        if self.current_mode == AutomationMode.LIVE_TRADING:
            # En live, fermeture r√©elle des positions
            logger.warning("FERMETURE POSITIONS R√âELLES")
            # TODO: Impl√©mentation fermeture positions
        
        logger.info("Positions ferm√©es (simulation)")
    
    def _stop_all_components(self):
        """Arr√™t de tous les composants"""
        logger.info("Arr√™t composants...")
        
        # Arr√™t simul√© des composants
        self.trader = None
        self.snapshotter = None
        self.monitor = None
        self.data_collector = None
        
        logger.info("Composants arr√™t√©s")
    
    def _save_emergency_state(self):
        """Sauvegarde √©tat d'urgence"""
        emergency_state = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "mode": self.current_mode.value if self.current_mode else None,
            "reason": "emergency_stop_triggered",
            "system_status": self.get_system_status()
        }
        
        emergency_file = self.log_dir / f"emergency_state_{int(time.time())}.json"
        
        try:
            with open(emergency_file, 'w') as f:
                json.dump(emergency_state, f, indent=2)
            
            logger.info(f"√âtat d'urgence sauvegard√©: {emergency_file}")
            
        except Exception as e:
            logger.error(f"Erreur sauvegarde √©tat urgence: {e}")
    
    def _save_final_state(self):
        """Sauvegarde √©tat final"""
        final_state = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "mode": self.current_mode.value if self.current_mode else None,
            "runtime_seconds": (datetime.now(timezone.utc) - self.start_time).total_seconds() if self.start_time else 0,
            "system_status": self.get_system_status()
        }
        
        final_file = self.log_dir / f"final_state_{int(time.time())}.json"
        
        try:
            with open(final_file, 'w') as f:
                json.dump(final_state, f, indent=2)
            
            logger.info(f"√âtat final sauvegard√©: {final_file}")
            
        except Exception as e:
            logger.error(f"Erreur sauvegarde √©tat final: {e}")
    
    def _get_system_resources(self) -> Dict[str, Any]:
        """Informations ressources syst√®me"""
        try:
            return {
                "cpu_percent": psutil.cpu_percent(),
                "memory_percent": psutil.virtual_memory().percent,
                "disk_usage": psutil.disk_usage('/').percent if os.name != 'nt' else psutil.disk_usage('C:').percent,
                "process_count": len(psutil.pids())
            }
        except Exception:
            return {"error": "Unable to get system resources"}

# === GLOBAL AUTOMATION MANAGER ===

# Instance globale du gestionnaire
automation_manager = AutomationManager()

# === FONCTIONS PRINCIPALES ===

def start_paper_trading(duration_hours: Optional[int] = None, max_trades: Optional[int] = None) -> bool:
    """
    D√©marrage paper trading s√©curis√©
    
    Args:
        duration_hours: Dur√©e en heures (None = illimit√©)
        max_trades: Nombre max trades (None = illimit√©)
        
    Returns:
        True si succ√®s, False sinon
    """
    return automation_manager.start_paper_trading(duration_hours, max_trades)

def start_data_collection(collection_hours: Optional[int] = None, target_samples: Optional[int] = None) -> bool:
    """
    D√©marrage collection donn√©es sans trading
    
    Args:
        collection_hours: Dur√©e collection en heures
        target_samples: Nombre cible √©chantillons
        
    Returns:
        True si succ√®s, False sinon
    """
    return automation_manager.start_data_collection(collection_hours, target_samples)

def start_live_trading(capital_limit: Optional[float] = None, max_position_size: Optional[int] = None) -> bool:
    """
    D√©marrage trading live avec capital r√©el
    
    Args:
        capital_limit: Limite capital √† risquer
        max_position_size: Taille max position
        
    Returns:
        True si succ√®s, False sinon
    """
    return automation_manager.start_live_trading(capital_limit, max_position_size)

def emergency_stop_all() -> bool:
    """
    Arr√™t d'urgence complet du syst√®me
    
    Returns:
        True si succ√®s, False sinon
    """
    return automation_manager.emergency_stop_all()

def get_automation_status() -> Dict[str, Any]:
    """
    Statut actuel de l'automation
    
    Returns:
        Dictionnaire avec statut d√©taill√©
    """
    return automation_manager.get_system_status()

def stop_automation() -> bool:
    """
    Arr√™t propre de l'automation
    
    Returns:
        True si succ√®s, False sinon
    """
    return automation_manager.stop_automation()

# === CLI INTERFACE ===

def main():
    """Interface en ligne de commande"""
    
    parser = argparse.ArgumentParser(description="MIA Trading Automation Starter")
    parser.add_argument("mode", choices=["paper", "data", "live", "status", "stop", "emergency"],
                       help="Mode d'automation")
    
    # Arguments optionnels
    parser.add_argument("--duration", type=int, help="Dur√©e en heures")
    parser.add_argument("--max-trades", type=int, help="Nombre max de trades")
    parser.add_argument("--capital-limit", type=float, help="Limite de capital")
    parser.add_argument("--max-position", type=int, help="Taille max position")
    parser.add_argument("--samples", type=int, help="Nombre cible √©chantillons")
    parser.add_argument("--verbose", "-v", action="store_true", help="Logging verbose")
    
    args = parser.parse_args()
    
    # Configuration logging
    log_level = logging.DEBUG if args.verbose else logging.INFO
    logging.basicConfig(
        level=log_level,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(f"logs/automation/automation_{datetime.now().strftime('%Y%m%d')}.log"),
            logging.StreamHandler()
        ]
    )
    
    logger.info("=== MIA TRADING AUTOMATION STARTER ===")
    
    try:
        # Ex√©cution selon mode
        if args.mode == "paper":
            success = start_paper_trading(args.duration, args.max_trades)
            if success:
                print("‚úÖ Paper trading d√©marr√© avec succ√®s")
                # Maintenir le processus actif
                try:
                    while automation_manager.status == SystemStatus.RUNNING:
                        time.sleep(10)
                except KeyboardInterrupt:
                    logger.info("Interruption clavier - arr√™t propre...")
                    stop_automation()
            else:
                print("‚ùå √âchec d√©marrage paper trading")
                sys.exit(1)
        
        elif args.mode == "data":
            success = start_data_collection(args.duration, args.samples)
            if success:
                print("‚úÖ Data collection d√©marr√©e avec succ√®s")
                # Maintenir le processus actif
                try:
                    while automation_manager.status == SystemStatus.RUNNING:
                        time.sleep(10)
                except KeyboardInterrupt:
                    logger.info("Interruption clavier - arr√™t propre...")
                    stop_automation()
            else:
                print("‚ùå √âchec d√©marrage data collection")
                sys.exit(1)
        
        elif args.mode == "live":
            success = start_live_trading(args.capital_limit, args.max_position)
            if success:
                print("‚úÖ Live trading d√©marr√© avec succ√®s")
                print("üî¥ SURVEILLANCE CONTINUE REQUISE")
                # Maintenir le processus actif
                try:
                    while automation_manager.status == SystemStatus.RUNNING:
                        time.sleep(10)
                except KeyboardInterrupt:
                    logger.info("Interruption clavier - arr√™t propre...")
                    stop_automation()
            else:
                print("‚ùå √âchec d√©marrage live trading")
                sys.exit(1)
        
        elif args.mode == "status":
            status = get_automation_status()
            print("üìä STATUT AUTOMATION:")
            print(json.dumps(status, indent=2))
        
        elif args.mode == "stop":
            success = stop_automation()
            if success:
                print("‚úÖ Automation arr√™t√©e proprement")
            else:
                print("‚ùå Erreur arr√™t automation")
                sys.exit(1)
        
        elif args.mode == "emergency":
            success = emergency_stop_all()
            if success:
                print("üö® ARR√äT D'URGENCE EFFECTU√â")
            else:
                print("‚ùå Erreur arr√™t d'urgence")
                sys.exit(1)
    
    except Exception as e:
        logger.error(f"Erreur critique: {e}")
        print(f"‚ùå Erreur critique: {e}")
        emergency_stop_all()
        sys.exit(1)

# === TEST FUNCTION ===

def test_automation_starter():
    """Test complet du starter d'automation"""
    logger.info("=== TEST AUTOMATION STARTER ===")
    
    print("Test 1: Paper Trading")
    success = start_paper_trading(duration_hours=1, max_trades=5)
    print(f"Paper trading: {'‚úÖ' if success else '‚ùå'}")
    
    if success:
        time.sleep(2)
        
        status = get_automation_status()
        print(f"Status: {status['status']}")
        
        stop_success = stop_automation()
        print(f"Stop: {'‚úÖ' if stop_success else '‚ùå'}")
    
    print("\nTest 2: Data Collection")
    success = start_data_collection(collection_hours=1, target_samples=100)
    print(f"Data collection: {'‚úÖ' if success else '‚ùå'}")
    
    if success:
        time.sleep(2)
        stop_success = stop_automation()
        print(f"Stop: {'‚úÖ' if stop_success else '‚ùå'}")
    
    print("\nTest 3: Emergency Stop")
    emergency_success = emergency_stop_all()
    print(f"Emergency stop: {'‚úÖ' if emergency_success else '‚ùå'}")
    
    logger.info("=== TEST TERMIN√â ===")

if __name__ == "__main__":
    if len(sys.argv) > 1:
        main()
    else:
        print("Usage: python start_automation.py {paper|data|live|status|stop|emergency}")
        print("Ou lancez test_automation_starter() pour tests")