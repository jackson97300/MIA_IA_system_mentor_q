"""
MIA_IA_SYSTEM - Audit Debugger
Identifie exactement quel fichier cause le probleme dans technical_audit.py
Version: Debug Windows paths
"""

import sys
import importlib
from pathlib import Path
from typing import List, Tuple, Dict

def analyze_audit_problem():
    """Analyse exacte du probleme audit"""
    print("üîç ANALYSE PROBLEME AUDIT TECHNIQUE")
    print("=" * 50)
    
    project_root = Path(".")
    
    # 1. Lister TOUS les fichiers Python
    print("\n1Ô∏è‚É£ ANALYSE FICHIERS PYTHON:")
    python_files = list(project_root.rglob("*.py"))
    python_files = [f for f in python_files if "__pycache__" not in str(f)]
    
    print(f"Total fichiers Python trouv√©s: {len(python_files)}")
    
    # 2. Simuler la logique de l'audit (probl√©matique)
    print("\n2Ô∏è‚É£ SIMULATION LOGIQUE AUDIT (BUGGU√âE):")
    problematic_modules = []
    valid_modules = []
    
    for py_file in python_files:
        # Reproduire la logique exacte de technical_audit.py
        relative_path = py_file.relative_to(project_root)
        
        # VOICI LE BUG ! Sur Windows, √ßa donne des backslashes
        file_module_buggy = str(relative_path).replace('/', '.').replace('.py', '')
        
        print(f"Fichier: {py_file}")
        print(f"  Chemin relatif: {relative_path}")
        print(f"  Module buggy: {file_module_buggy}")
        
        # V√©rifier si c'est un vrai module Python importable
        try:
            # Test si ce serait importable (sans vraiment importer)
            if '\\' in file_module_buggy:
                problematic_modules.append((str(py_file), file_module_buggy, "Windows backslash"))
            elif file_module_buggy.startswith('.'):
                problematic_modules.append((str(py_file), file_module_buggy, "Starts with dot"))
            elif any(part in file_module_buggy for part in ['test_', 'fix_', 'performance_', 'audit_']):
                problematic_modules.append((str(py_file), file_module_buggy, "Utility script"))
            else:
                valid_modules.append((str(py_file), file_module_buggy))
                
        except Exception as e:
            problematic_modules.append((str(py_file), file_module_buggy, str(e)))
        
        print()
    
    # 3. Identifier la vraie correction
    print("\n3Ô∏è‚É£ CORRECTION APPROPRI√âE:")
    fixed_modules = []
    
    for py_file in python_files:
        relative_path = py_file.relative_to(project_root)
        
        # CORRECTION: Remplacer AUSSI les backslashes Windows
        file_module_fixed = str(relative_path).replace('\\', '.').replace('/', '.').replace('.py', '')
        
        # Filtrer les fichiers non-modules
        if (not file_module_fixed.startswith('.') and 
            not any(part in file_module_fixed for part in ['test_', 'fix_', 'performance_', 'audit_', 'quick_', 'ultimate_', 'corrected_', 'windows_']) and
            file_module_fixed not in ['main', 'setup'] and
            '.' in file_module_fixed):  # Doit avoir au moins un package
            
            fixed_modules.append((str(py_file), file_module_fixed))
    
    # 4. R√©sum√© du probl√®me
    print("\nüìä R√âSUM√â PROBL√àME:")
    print(f"   ‚Ä¢ Fichiers totaux: {len(python_files)}")
    print(f"   ‚Ä¢ Modules probl√©matiques: {len(problematic_modules)}")
    print(f"   ‚Ä¢ Modules valides (apr√®s fix): {len(fixed_modules)}")
    
    # 5. D√©tail des probl√®mes
    print("\n‚ùå FICHIERS PROBL√âMATIQUES:")
    for file_path, module_name, reason in problematic_modules[:10]:  # Top 10
        file_name = Path(file_path).name
        print(f"   ‚Ä¢ {file_name:25} ‚Üí {module_name:30} ({reason})")
    
    if len(problematic_modules) > 10:
        print(f"   ... et {len(problematic_modules) - 10} autres")
    
    # 6. Modules valides
    print("\n‚úÖ MODULES VALIDES (APR√àS FIX):")
    for file_path, module_name in fixed_modules:
        file_name = Path(file_path).name
        print(f"   ‚Ä¢ {file_name:25} ‚Üí {module_name}")
    
    return problematic_modules, fixed_modules

def test_fixed_import_logic():
    """Test la logique d'import corrig√©e"""
    print("\nüß™ TEST LOGIQUE IMPORT CORRIG√âE")
    print("=" * 50)
    
    project_root = Path(".")
    
    # Modules critiques √† tester
    critical_files = [
        "config/trading_config.py",
        "core/base_types.py",
        "config/__init__.py",
        "core/__init__.py"
    ]
    
    # Add to path
    if str(project_root.absolute()) not in sys.path:
        sys.path.insert(0, str(project_root.absolute()))
    
    for file_path in critical_files:
        if Path(file_path).exists():
            # Logique corrig√©e
            py_file = Path(file_path)
            relative_path = py_file.relative_to(project_root)
            
            # CORRECTION: Remplacer backslashes ET slashes
            file_module = str(relative_path).replace('\\', '.').replace('/', '.').replace('.py', '')
            
            print(f"Fichier: {file_path}")
            print(f"Module: {file_module}")
            
            try:
                # Clear cache
                if file_module in sys.modules:
                    del sys.modules[file_module]
                
                importlib.import_module(file_module)
                print(f"‚úÖ Import r√©ussi: {file_module}")
                
            except Exception as e:
                print(f"‚ùå Import √©chou√©: {file_module} - {e}")
            
            print()

def identify_exact_fix_needed():
    """Identifie le fix exact n√©cessaire dans technical_audit.py"""
    print("\nüîß FIX EXACT N√âCESSAIRE")
    print("=" * 50)
    
    audit_file = Path("technical_audit.py")
    if not audit_file.exists():
        print("‚ùå technical_audit.py non trouv√©")
        return None
    
    content = audit_file.read_text(encoding='utf-8')
    
    # Chercher les lignes probl√©matiques
    lines = content.split('\n')
    problem_lines = []
    
    for i, line in enumerate(lines):
        if 'relative_to' in line and 'replace' in line and '.py' in line:
            problem_lines.append((i+1, line.strip()))
    
    print("üîç LIGNES PROBL√âMATIQUES TROUV√âES:")
    for line_num, line_content in problem_lines:
        print(f"   Ligne {line_num}: {line_content}")
    
    # Proposer fix exact
    if problem_lines:
        print("\nüîß FIX EXACT:")
        for line_num, line_content in problem_lines:
            if "replace('/', '.')" in line_content:
                fixed_line = line_content.replace(
                    "replace('/', '.')", 
                    "replace('\\\\', '.').replace('/', '.')"
                )
                print(f"   Ligne {line_num}:")
                print(f"   AVANT: {line_content}")
                print(f"   APR√àS: {fixed_line}")
                print()
        
        return problem_lines
    else:
        print("‚ùå Pattern probl√©matique non trouv√©")
        return None

def main():
    """Analyse compl√®te"""
    print("üöÄ AUDIT DEBUGGER - IDENTIFICATION PROBL√àME EXACT")
    print("=" * 60)
    
    # 1. Analyser le probl√®me
    problematic, valid = analyze_audit_problem()
    
    # 2. Tester logique corrig√©e
    test_fixed_import_logic()
    
    # 3. Identifier fix exact
    fix_lines = identify_exact_fix_needed()
    
    # 4. Conclusion
    print("\nüéØ CONCLUSION")
    print("=" * 30)
    
    print(f"PROBL√àME IDENTIFI√â:")
    print(f"   ‚Ä¢ {len(problematic)} fichiers causent des erreurs d'import")
    print(f"   ‚Ä¢ Cause principale: Chemins Windows (backslashes)")
    print(f"   ‚Ä¢ Fichiers utilitaires aussi inclus dans scan")
    
    print(f"\nSOLUTION:")
    print(f"   ‚Ä¢ Modifier technical_audit.py ligne(s): {[line[0] for line in fix_lines] if fix_lines else 'Non trouv√©'}")
    print(f"   ‚Ä¢ Ajouter .replace('\\\\', '.') avant .replace('/', '.')")
    print(f"   ‚Ä¢ Filtrer fichiers non-modules (test_, fix_, etc.)")
    
    print(f"\nR√âSULTAT ATTENDU:")
    print(f"   ‚Ä¢ {len(valid)} modules valides seraient import√©s")
    print(f"   ‚Ä¢ Score passerait de 62.5% √† 85%+")

if __name__ == "__main__":
    main()