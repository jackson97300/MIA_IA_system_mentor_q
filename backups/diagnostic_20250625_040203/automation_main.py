#!/usr/bin/env python3
"""
MIA_IA_SYSTEM - Automation Main (Version D√©finitive)
Point d'entr√©e principal pour l'automation de trading
Version: Production Ready v3.0
# Configuration encodage UTF-8 pour Windows
import sys
import io
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')


Architecture simplifi√©e :
- IBKR : Source unique de donn√©es (market data, options, order flow)
- Sierra Chart : Ex√©cution des ordres uniquement
- SignalGenerator : Cerveau central unifi√©
- ML Progressif : Commence simple, √©volue avec les donn√©es

Modes support√©s :
- DATA_COLLECTION : Collecte intensive pour ML (seuils bas)
- PAPER_TRADING : Validation strat√©gie (seuils moyens)
- LIVE_TRADING : Trading r√©el (seuils stricts)
"""

import sys
import os
import asyncio
import signal
import logging
import argparse
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime, timedelta
from pathlib import Path
import json
import time

# Configuration logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/automation.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# === IMPORTS MIA_IA_SYSTEM ===

# Configuration
from config import get_trading_config, get_sierra_config
from config.automation_config import (
    AutomationConfig, AutomationMode, 
    create_data_collection_config,
    create_paper_trading_config, 
    create_live_trading_config,
    create_conservative_config,
    get_automation_config,
    validate_config
)

# Core
from core.base_types import (
    MarketData, SystemState, TradingSignal,
    ES_TICK_SIZE, ES_TICK_VALUE
)

# Strategies - CERVEAU CENTRAL
from strategies import get_signal_now, SignalGenerator, SignalDecision

# Execution
from execution import (
    SimpleBattleNavaleTrader,
    create_simple_trader,
    TradingMode,
    AutomationStatus
)

# Monitoring
from monitoring import (
    LiveMonitor, PerformanceTracker,
    HealthChecker, create_discord_notifier
)

# Performance
from performance import TradeLogger, PerformanceAnalyzer

# === MAIN AUTOMATION BOT ===

class MIAAutomationBot:
    """
    Bot d'automation principal MIA_IA_SYSTEM
    
    Orchestrateur central qui coordonne :
    - SignalGenerator pour les d√©cisions
    - SimpleBattleNavaleTrader pour l'ex√©cution
    - Monitoring pour la surveillance
    - Performance tracking
    """
    
    def __init__(self, config: AutomationConfig):
        """
        Initialise le bot d'automation
        
        Args:
            config: Configuration automation compl√®te
        """
        self.config = config
        self.start_time = datetime.now()
        self.is_running = False
        self.shutdown_requested = False
        
        # === COMPOSANTS CORE ===
        logger.info("üöÄ Initialisation MIA Automation Bot...")
        
        # 1. Signal Generator (Cerveau Central)
        logger.info("üß† Cr√©ation SignalGenerator...")
        self.signal_generator = SignalGenerator()
        self._configure_signal_generator()
        
        # 2. Trader (Ex√©cution)
        logger.info("ü§ñ Cr√©ation SimpleBattleNavaleTrader...")
        trader_mode = self._get_trader_mode()
        self.trader = create_simple_trader(trader_mode)
        self._configure_trader()
        
        # 3. Monitoring
        logger.info("üìä Cr√©ation syst√®me monitoring...")
        self.live_monitor = LiveMonitor(self.trader)
        self.performance_tracker = PerformanceTracker()
        self.health_checker = HealthChecker()
        
        # 4. Performance & Logging
        logger.info("üìà Cr√©ation syst√®me performance...")
        self.trade_logger = TradeLogger()
        self.performance_analyzer = PerformanceAnalyzer()
        
        # 5. Notifications (optionnel)
        self.discord = None
        if self.config.monitoring.enable_alerts:
            try:
                self.discord = create_discord_notifier()
                logger.info("‚úÖ Discord notifications activ√©es")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Discord non disponible: {e}")
        
        # === √âTAT SYST√àME ===
        self.system_state = SystemState.IDLE
        self.stats = {
            'signals_generated': 0,
            'signals_executed': 0,
            'trades_completed': 0,
            'errors_count': 0,
            'uptime_hours': 0
        }
        
        logger.info("‚úÖ MIA Automation Bot initialis√© avec succ√®s")
        self._log_configuration()
    
    def _configure_signal_generator(self):
        """Configure SignalGenerator selon le mode"""
        mode = self.config.trading.automation_mode
        
        # Ajustement des seuils selon le mode
        if hasattr(self.signal_generator, 'min_confidence'):
            self.signal_generator.min_confidence = self.config.trading.battle_navale_min_confidence
        
        if hasattr(self.signal_generator, 'min_confluence'):
            self.signal_generator.min_confluence = self.config.trading.min_confluence_score
        
        logger.info(f"SignalGenerator configur√© pour mode: {mode.value}")
        logger.info(f"  - Min confidence: {self.config.trading.battle_navale_min_confidence}")
        logger.info(f"  - Min confluence: {self.config.trading.min_confluence_score}")
    
    def _configure_trader(self):
        """Configure le trader selon le mode"""
        # Le trader est d√©j√† configur√© via le mode pass√© √† create_simple_trader
        # Mais on peut ajouter des configs suppl√©mentaires ici
        
        if hasattr(self.trader, 'min_probability'):
            if self.config.trading.automation_mode == AutomationMode.DATA_COLLECTION:
                self.trader.min_probability = 0.35  # Tr√®s bas pour data collection
            elif self.config.trading.automation_mode == AutomationMode.PAPER_TRADING:
                self.trader.min_probability = 0.60  # Standard
            else:  # LIVE
                self.trader.min_probability = 0.70  # Strict
    
    def _get_trader_mode(self) -> str:
        """Convertit AutomationMode vers mode du trader"""
        mode_map = {
            AutomationMode.DATA_COLLECTION: "DATA_COLLECTION",
            AutomationMode.PAPER_TRADING: "PAPER",
            AutomationMode.LIVE_TRADING: "LIVE"
        }
        return mode_map.get(self.config.trading.automation_mode, "PAPER")
    
    def _log_configuration(self):
        """Log la configuration active"""
        logger.info("=" * 60)
        logger.info("üìã CONFIGURATION ACTIVE")
        logger.info("=" * 60)
        logger.info(f"Mode: {self.config.trading.automation_mode.value}")
        logger.info(f"Config name: {self.config.config_name}")
        
        logger.info("\nüéØ Param√®tres Trading:")
        logger.info(f"  - Battle Navale min: {self.config.trading.battle_navale_min_confidence}")
        logger.info(f"  - Confluence min: {self.config.trading.min_confluence_score}")
        logger.info(f"  - Positions max: {self.config.trading.max_positions_concurrent}")
        
        logger.info("\nüõ°Ô∏è Param√®tres Risk:")
        logger.info(f"  - Daily loss limit: ${self.config.risk.daily_loss_limit}")
        logger.info(f"  - Max daily trades: {self.config.risk.max_daily_trades}")
        logger.info(f"  - Stop loss: {self.config.risk.stop_loss_ticks} ticks")
        
        logger.info("\nüìä Param√®tres Monitoring:")
        logger.info(f"  - Monitoring enabled: {self.config.monitoring.enable_monitoring}")
        logger.info(f"  - Alerts enabled: {self.config.monitoring.enable_alerts}")
        logger.info("=" * 60)
    
    # === MAIN EXECUTION LOOP ===
    
    async def start(self):
        """D√©marre le bot d'automation"""
        logger.info("üöÄ D√âMARRAGE MIA AUTOMATION BOT")
        
        try:
            # 1. Validation syst√®me
            if not await self._validate_system():
                logger.error("‚ùå Validation syst√®me √©chou√©e")
                return False
            
            # 2. D√©marrage composants
            self.is_running = True
            self.system_state = SystemState.TRADING
            
            # 3. D√©marrage monitoring
            self.live_monitor.start_monitoring()
            
            # 4. Notification d√©marrage
            await self._notify_startup()
            
            # 5. D√©marrage trader
            await self.trader.start_trading_session()
            
            # 6. Loop principal
            await self._run_main_loop()
            
        except KeyboardInterrupt:
            logger.info("‚å®Ô∏è Arr√™t demand√© par l'utilisateur")
        except Exception as e:
            logger.error(f"‚ùå Erreur fatale: {e}", exc_info=True)
            self.stats['errors_count'] += 1
        finally:
            await self.shutdown()
    
    async def _validate_system(self) -> bool:
        """Valide que le syst√®me est pr√™t"""
        logger.info("üîç Validation syst√®me...")
        
        validations = []
        
        # 1. Configuration valide
        config_valid = validate_config(self.config)
        validations.append(("Configuration", config_valid))
        
        # 2. Connexions broker
        ibkr_ok = await self._test_ibkr_connection()
        validations.append(("IBKR Connection", ibkr_ok))
        
        sierra_ok = await self._test_sierra_connection()
        validations.append(("Sierra Chart", sierra_ok))
        
        # 3. Espace disque
        disk_ok = self._check_disk_space()
        validations.append(("Espace disque", disk_ok))
        
        # 4. Composants
        components_ok = self._validate_components()
        validations.append(("Composants", components_ok))
        
        # Affichage r√©sultats
        all_ok = True
        for name, status in validations:
            icon = "‚úÖ" if status else "‚ùå"
            logger.info(f"  {icon} {name}")
            if not status:
                all_ok = False
        
        return all_ok
    
    async def _test_ibkr_connection(self) -> bool:
        """Test connexion IBKR"""
        try:
            # Le trader teste d√©j√† la connexion √† l'init
            return self.trader.ibkr_connected if hasattr(self.trader, 'ibkr_connected') else True
        except:
            return False
    
    async def _test_sierra_connection(self) -> bool:
        """Test connexion Sierra Chart"""
        try:
            # V√©rifier que la config Sierra est valide
            sierra_config = get_sierra_config()
            return sierra_config is not None
        except:
            return False
    
    def _check_disk_space(self) -> bool:
        """V√©rifie l'espace disque disponible"""
        try:
            import shutil
            path = Path("data/snapshots")
            path.mkdir(parents=True, exist_ok=True)
            
            stat = shutil.disk_usage(path)
            free_gb = stat.free / (1024**3)
            
            return free_gb > 1.0  # Au moins 1GB libre
        except:
            return True  # On assume OK si erreur
    
    def _validate_components(self) -> bool:
        """Valide que tous les composants sont initialis√©s"""
        try:
            assert self.signal_generator is not None
            assert self.trader is not None
            assert self.live_monitor is not None
            return True
        except:
            return False
    
    async def _notify_startup(self):
        """Notification de d√©marrage"""
        message = f"""
üöÄ **MIA AUTOMATION BOT D√âMARR√â**
üìÖ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
‚öôÔ∏è Mode: {self.config.trading.automation_mode.value}
üìä Config: {self.config.config_name}
üéØ Battle Navale Min: {self.config.trading.battle_navale_min_confidence}
üí∞ Daily Loss Limit: ${self.config.risk.daily_loss_limit}
        """
        
        logger.info(message)
        
        if self.discord:
            try:
                await self.discord.send_message(message, alert_type="info")
            except:
                pass
    
    async def _run_main_loop(self):
        """Loop principal d'ex√©cution"""
        logger.info("üîÑ D√©marrage loop principal...")
        
        loop_count = 0
        last_health_check = time.time()
        last_performance_update = time.time()
        
        while self.is_running and not self.shutdown_requested:
            try:
                loop_start = time.time()
                loop_count += 1
                
                # 1. Health check p√©riodique
                if time.time() - last_health_check > 60:  # Chaque minute
                    await self._perform_health_check()
                    last_health_check = time.time()
                
                # 2. Performance update p√©riodique
                if time.time() - last_performance_update > 300:  # Toutes les 5 minutes
                    await self._update_performance_metrics()
                    last_performance_update = time.time()
                
                # 3. Check arr√™t demand√©
                if self._should_stop_trading():
                    logger.info("üõë Conditions d'arr√™t atteintes")
                    break
                
                # 4. D√©lai entre loops
                loop_duration = time.time() - loop_start
                sleep_time = max(0, (self.config.trading.analysis_frequency_ms / 1000) - loop_duration)
                
                if loop_count % 100 == 0:  # Log toutes les 100 iterations
                    logger.debug(f"Loop {loop_count}: {loop_duration*1000:.1f}ms")
                
                await asyncio.sleep(sleep_time)
                
            except Exception as e:
                logger.error(f"Erreur dans main loop: {e}", exc_info=True)
                self.stats['errors_count'] += 1
                await asyncio.sleep(1)  # Pause en cas d'erreur
    
    async def _perform_health_check(self):
        """Effectue un health check complet"""
        try:
            health_status = self.health_checker.check_system_health()
            
            if not health_status['healthy']:
                logger.warning(f"‚ö†Ô∏è Probl√®me sant√© syst√®me: {health_status['issues']}")
                
                if health_status['critical']:
                    logger.error("üö® Probl√®me critique d√©tect√© - Arr√™t d'urgence")
                    self.shutdown_requested = True
            
        except Exception as e:
            logger.error(f"Erreur health check: {e}")
    
    async def _update_performance_metrics(self):
        """Met √† jour les m√©triques de performance"""
        try:
            # R√©cup√©rer stats du trader
            trader_stats = self.trader.get_statistics()
            
            # Mettre √† jour performance tracker
            self.performance_tracker.update_metrics(trader_stats)
            
            # Log r√©sum√©
            logger.info(f"üìä Performance Update: "
                       f"Trades: {trader_stats.get('trades_completed', 0)}, "
                       f"Win Rate: {trader_stats.get('win_rate', 0):.1%}, "
                       f"P&L: ${trader_stats.get('total_pnl', 0):.2f}")
            
        except Exception as e:
            logger.error(f"Erreur update performance: {e}")
    
    def _should_stop_trading(self) -> bool:
        """D√©termine si le trading doit s'arr√™ter"""
        # 1. Arr√™t manuel demand√©
        if self.shutdown_requested:
            return True
        
        # 2. Daily loss limit atteint
        trader_stats = self.trader.get_statistics()
        daily_pnl = trader_stats.get('daily_pnl', 0)
        
        if daily_pnl <= -self.config.risk.daily_loss_limit:
            logger.warning(f"üõë Daily loss limit atteint: ${daily_pnl:.2f}")
            return True
        
        # 3. Daily profit target atteint (si configur√©)
        if self.config.risk.stop_on_daily_target:
            if daily_pnl >= self.config.risk.daily_profit_target:
                logger.info(f"üéØ Daily profit target atteint: ${daily_pnl:.2f}")
                return True
        
        # 4. Max trades atteint
        daily_trades = trader_stats.get('daily_trades', 0)
        if daily_trades >= self.config.risk.max_daily_trades:
            logger.info(f"üìä Max daily trades atteint: {daily_trades}")
            return True
        
        # 5. Erreurs critiques
        if self.stats['errors_count'] > 10:
            logger.error("‚ùå Trop d'erreurs - Arr√™t de s√©curit√©")
            return True
        
        return False
    
    async def shutdown(self):
        """Arr√™t propre du syst√®me"""
        logger.info("üõë ARR√äT MIA AUTOMATION BOT...")
        
        self.is_running = False
        self.system_state = SystemState.SHUTDOWN
        
        try:
            # 1. Arr√™t trader
            if self.trader:
                await self.trader.stop_trading()
            
            # 2. Arr√™t monitoring
            if self.live_monitor:
                self.live_monitor.stop_monitoring()
            
            # 3. Sauvegarde donn√©es
            await self._save_final_data()
            
            # 4. Notification arr√™t
            await self._notify_shutdown()
            
            # 5. Calcul stats finales
            self._calculate_final_stats()
            
        except Exception as e:
            logger.error(f"Erreur pendant shutdown: {e}")
        
        logger.info("‚úÖ MIA Automation Bot arr√™t√© proprement")
    
    async def _save_final_data(self):
        """Sauvegarde les donn√©es finales"""
        try:
            # Export snapshots
            if hasattr(self.trader, 'snapshotter'):
                self.trader.snapshotter.export_daily_snapshots()
            
            # Sauvegarde config
            config_path = f"data/configs/config_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            Path(config_path).parent.mkdir(parents=True, exist_ok=True)
            self.config.save_to_file(config_path)
            
            # Sauvegarde stats
            stats_path = f"data/stats/stats_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            Path(stats_path).parent.mkdir(parents=True, exist_ok=True)
            with open(stats_path, 'w') as f:
                json.dump(self.stats, f, indent=2)
            
        except Exception as e:
            logger.error(f"Erreur sauvegarde donn√©es: {e}")
    
    async def _notify_shutdown(self):
        """Notification d'arr√™t"""
        uptime = (datetime.now() - self.start_time).total_seconds() / 3600
        
        trader_stats = self.trader.get_statistics()
        
        message = f"""
üõë **MIA AUTOMATION BOT ARR√äT√â**
üìÖ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
‚è±Ô∏è Uptime: {uptime:.1f} heures
üìä Trades: {trader_stats.get('trades_completed', 0)}
üí∞ P&L: ${trader_stats.get('total_pnl', 0):.2f}
üìà Win Rate: {trader_stats.get('win_rate', 0):.1%}
        """
        
        logger.info(message)
        
        if self.discord:
            try:
                await self.discord.send_message(message, alert_type="info")
            except:
                pass
    
    def _calculate_final_stats(self):
        """Calcule les statistiques finales"""
        uptime_hours = (datetime.now() - self.start_time).total_seconds() / 3600
        self.stats['uptime_hours'] = uptime_hours
        
        # Ajouter stats du trader
        trader_stats = self.trader.get_statistics()
        self.stats.update(trader_stats)
        
        # Log r√©sum√© final
        logger.info("=" * 60)
        logger.info("üìä STATISTIQUES FINALES")
        logger.info("=" * 60)
        for key, value in self.stats.items():
            logger.info(f"{key}: {value}")
        logger.info("=" * 60)

# === SIGNAL HANDLERS ===

def setup_signal_handlers(bot: MIAAutomationBot):
    """Configure les handlers de signaux syst√®me"""
    def signal_handler(signum, frame):
        logger.info(f"Signal {signum} re√ßu - Arr√™t demand√©")
        bot.shutdown_requested = True
    
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

# === MAIN FUNCTION ===

def create_config_from_args(args) -> AutomationConfig:
    """Cr√©e configuration depuis arguments ligne de commande"""
    # Configuration de base selon le mode
    if args.mode == "data_collection":
        config = create_data_collection_config()
    elif args.mode == "paper":
        config = create_paper_trading_config()
    elif args.mode == "live":
        if args.conservative:
            config = create_conservative_config()
        else:
            config = create_live_trading_config()
    else:
        config = get_automation_config(args.mode)
    
    # Override avec arguments sp√©cifiques
    if args.daily_loss_limit:
        config.risk.daily_loss_limit = args.daily_loss_limit
    
    if args.max_trades:
        config.risk.max_daily_trades = args.max_trades
    
    if args.min_confidence:
        config.trading.battle_navale_min_confidence = args.min_confidence
    
    if args.min_confluence:
        config.trading.min_confluence_score = args.min_confluence
    
    # Charger depuis fichier si sp√©cifi√©
    if args.config_file:
        try:
            config = AutomationConfig.load_from_file(args.config_file)
            logger.info(f"Configuration charg√©e depuis: {args.config_file}")
        except Exception as e:
            logger.error(f"Erreur chargement config: {e}")
    
    return config

async def main():
    """Fonction principale"""
    # === ARGUMENTS ===
    parser = argparse.ArgumentParser(description='MIA Automation Bot')
    
    parser.add_argument('--mode', 
                       choices=['data_collection', 'paper', 'live'],
                       default='paper',
                       help='Mode de trading')
    
    parser.add_argument('--config-file',
                       type=str,
                       help='Fichier de configuration JSON')
    
    parser.add_argument('--conservative',
                       action='store_true',
                       help='Utiliser configuration conservative (live uniquement)')
    
    parser.add_argument('--daily-loss-limit',
                       type=float,
                       help='Override daily loss limit')
    
    parser.add_argument('--max-trades',
                       type=int,
                       help='Override max daily trades')
    
    parser.add_argument('--min-confidence',
                       type=float,
                       help='Override min Battle Navale confidence')
    
    parser.add_argument('--min-confluence',
                       type=float,
                       help='Override min confluence score')
    
    parser.add_argument('--dry-run',
                       action='store_true',
                       help='Test configuration sans trader')
    
    args = parser.parse_args()
    
    # === BANNER ===
    print("""
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë       MIA_IA_SYSTEM AUTOMATION BOT       ‚ïë
    ‚ïë         Trading Futures ES - v3.0        ‚ïë
    ‚ïë    Architecture: IBKR Data + Sierra      ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """)
    
    # === CR√âATION CONFIG ===
    config = create_config_from_args(args)
    
    # === MODE DRY RUN ===
    if args.dry_run:
        logger.info("üîç MODE DRY RUN - Test configuration")
        logger.info(f"Configuration: {json.dumps(config.to_dict(), indent=2)}")
        
        if validate_config(config):
            logger.info("‚úÖ Configuration valide")
        else:
            logger.error("‚ùå Configuration invalide")
        
        return
    
    # === CR√âATION ET D√âMARRAGE BOT ===
    bot = MIAAutomationBot(config)
    setup_signal_handlers(bot)
    
    # D√©marrage
    await bot.start()

# === ENTRY POINT ===

if __name__ == "__main__":
    # Cr√©er dossiers n√©cessaires
    for folder in ['logs', 'data/snapshots', 'data/configs', 'data/stats']:
        Path(folder).mkdir(parents=True, exist_ok=True)
    
    # Lancer async main
    asyncio.run(main())