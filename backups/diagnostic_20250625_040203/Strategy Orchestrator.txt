"""
MIA_IA_SYSTEM - Strategies Package Integration
Orchestration complète des stratégies avec sélection intelligente
Version: Production Ready
Performance: Intégration seamless des 4 composants

ARCHITECTURE INTÉGRÉE :
1. MarketRegimeDetector → Détermine régime + bias
2. FeatureCalculator → Calcul confluence 8 features
3. TrendStrategy → Signaux tendance si régime approprié
4. RangeStrategy → Signaux range si régime approprié

SÉLECTION STRATEGY AUTOMATIQUE :
- STRONG_TREND_* → TrendStrategy uniquement
- WEAK_TREND_* → TrendStrategy avec prudence
- RANGE_*_BIAS → RangeStrategy avec bias directionnel
- RANGE_NEUTRAL → RangeStrategy both sides
- TRANSITION/UNCLEAR → Aucune stratégie (wait)

ORCHESTRATION SIGNAUX :
- Régime détermine stratégie active
- Features alimentent stratégie sélectionnée
- Confluence score filtre qualité signaux
- Bias compliance forcée pour range
"""

from typing import Dict, List, Tuple, Optional, Any, Union
from dataclasses import dataclass, field
from enum import Enum
import logging
import time

# Local imports - Core
from core.base_types import MarketData, OrderFlowData, ES_TICK_SIZE
from core.market_regime import (
    MarketRegimeDetector, MarketRegime, MarketRegimeData,
    create_market_regime_detector
)

# Local imports - Features  
from features.feature_calculator import (
    FeatureCalculator, FeatureCalculationResult, OptionsData,
    MarketStructureData, ESNQData, create_feature_calculator
)

# Local imports - Strategies
from .trend_strategy import (
    TrendStrategy, TrendSignalData, TrendSignalType,
    create_trend_strategy
)
from .range_strategy import (
    RangeStrategy, RangeSignalData, RangeSignalType, RangeBias,
    create_range_strategy
)

logger = logging.getLogger(__name__)

# === INTEGRATION ENUMS ===

class StrategySelection(Enum):
    """Sélection stratégie selon régime"""
    TREND_ONLY = "trend_only"           # Trends forts
    TREND_CAUTIOUS = "trend_cautious"   # Trends faibles
    RANGE_BIASED = "range_biased"       # Range avec bias
    RANGE_NEUTRAL = "range_neutral"     # Range neutre
    NO_STRATEGY = "no_strategy"         # Wait/transition
    MULTIPLE = "multiple"               # Plusieurs strategies

class SignalPriority(Enum):
    """Priorité des signaux"""
    PREMIUM = "premium"      # 85%+ confluence
    HIGH = "high"           # 70-84% confluence  
    MEDIUM = "medium"       # 60-69% confluence
    LOW = "low"            # <60% confluence (filtré)

# === INTEGRATION DATACLASSES ===

@dataclass
class UnifiedSignalData:
    """Signal unifié des stratégies"""
    timestamp: pd.Timestamp
    
    # Source identification
    strategy_source: str  # "trend" or "range"
    signal_priority: SignalPriority
    
    # Market context
    market_regime: MarketRegime
    regime_confidence: float
    
    # Signal data
    signal_type: str  # Type signal original
    direction: str    # LONG/SHORT/EXIT
    entry_price: float
    stop_loss: float
    take_profit: float
    position_size: float
    
    # Quality metrics
    confluence_score: float
    risk_reward_ratio: float
    bias_compliance: bool
    
    # Reasoning
    entry_reason: str
    strategy_logic: str
    
    # Original signal reference
    original_trend_signal: Optional[TrendSignalData] = None
    original_range_signal: Optional[RangeSignalData] = None
    
    # Performance predictions
    expected_win_rate: float = 0.0
    expected_profit_factor: float = 0.0

@dataclass
class StrategyOrchestrationResult:
    """Résultat orchestration complète"""
    timestamp: pd.Timestamp
    
    # Market analysis
    regime_data: MarketRegimeData
    features_data: FeatureCalculationResult
    
    # Strategy selection
    selected_strategy: StrategySelection
    strategy_reason: str
    
    # Generated signals
    unified_signal: Optional[UnifiedSignalData] = None
    alternative_signals: List[UnifiedSignalData] = field(default_factory=list)
    
    # System performance
    total_processing_time_ms: float = 0.0
    component_timings: Dict[str, float] = field(default_factory=dict)
    
    # Recommendations
    trade_recommendation: str = "NO_TRADE"  # EXECUTE, WAIT, EXIT
    position_sizing_factor: float = 1.0
    risk_assessment: str = "NORMAL"  # LOW, NORMAL, HIGH

# === MAIN STRATEGY ORCHESTRATOR ===

class StrategyOrchestrator:
    """
    Orchestrateur principal des stratégies
    
    Responsabilités :
    1. Coordination des 4 composants système
    2. Sélection automatique stratégie selon régime
    3. Validation croisée des signaux
    4. Génération signal unifié final
    5. Performance monitoring intégré
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """Initialisation orchestrateur"""
        self.config = config or {}
        
        # Initialisation composants
        self.regime_detector = create_market_regime_detector(
            self.config.get('regime_config', {})
        )
        self.feature_calculator = create_feature_calculator(
            self.config.get('features_config', {})
        )
        self.trend_strategy = create_trend_strategy(
            self.config.get('trend_config', {})
        )
        self.range_strategy = create_range_strategy(
            self.config.get('range_config', {})
        )
        
        # Paramètres orchestration
        self.min_confluence_for_execution = self.config.get('min_confluence', 0.60)
        self.regime_confidence_threshold = self.config.get('regime_confidence', 0.65)
        self.enable_multiple_strategies = self.config.get('enable_multiple', False)
        
        # Performance tracking
        self.stats = {
            'total_orchestrations': 0,
            'signals_generated': 0,
            'trend_signals': 0,
            'range_signals': 0,
            'signals_filtered_confluence': 0,
            'signals_filtered_regime': 0,
            'avg_processing_time_ms': 0.0,
            'strategy_selection_counts': {
                'trend_only': 0,
                'trend_cautious': 0,
                'range_biased': 0,
                'range_neutral': 0,
                'no_strategy': 0
            }
        }
        
        logger.info("StrategyOrchestrator initialisé - Intégration complète système")
    
    def orchestrate_trading_decision(self,
                                   market_data: MarketData,
                                   order_flow: Optional[OrderFlowData] = None,
                                   options_data: Optional[OptionsData] = None,
                                   structure_data: Optional[MarketStructureData] = None,
                                   es_nq_data: Optional[ESNQData] = None) -> StrategyOrchestrationResult:
        """
        ORCHESTRATION COMPLÈTE DÉCISION TRADING
        
        Processus intégré :
        1. Analyse régime marché (bias + stratégie)
        2. Calcul features confluence
        3. Sélection stratégie selon régime
        4. Génération signaux stratégie active
        5. Validation croisée + unification
        6. Recommandation finale
        
        Args:
            market_data: Données OHLC + volume obligatoires
            order_flow: Données order flow optionnelles
            options_data: Données options SpotGamma
            structure_data: Market Profile + VWAP data
            es_nq_data: Données corrélation ES/NQ
            
        Returns:
            StrategyOrchestrationResult avec décision unifiée
        """
        start_time = time.perf_counter()
        component_timings = {}
        
        try:
            self.stats['total_orchestrations'] += 1
            
            # === 1. ANALYSE RÉGIME MARCHÉ ===
            
            regime_start = time.perf_counter()
            
            # Préparation données pour régime detector
            regime_structure_data = self._prepare_structure_data(structure_data)
            regime_es_nq_data = self._prepare_es_nq_data(es_nq_data)
            
            regime_data = self.regime_detector.analyze_market_regime(
                market_data=market_data,
                es_nq_data=regime_es_nq_data,
                structure_data=regime_structure_data
            )
            
            component_timings['regime_detection'] = (time.perf_counter() - regime_start) * 1000
            
            # === 2. CALCUL FEATURES CONFLUENCE ===
            
            features_start = time.perf_counter()
            
            # Extraction patterns Sierra Chart (depuis battle_navale si disponible)
            sierra_patterns = self._extract_sierra_patterns(regime_data)
            
            features_data = self.feature_calculator.calculate_all_features(
                market_data=market_data,
                order_flow=order_flow,
                options_data=options_data,
                structure_data=structure_data,
                es_nq_data=es_nq_data,
                sierra_patterns=sierra_patterns
            )
            
            component_timings['feature_calculation'] = (time.perf_counter() - features_start) * 1000
            
            # === 3. SÉLECTION STRATÉGIE SELON RÉGIME ===
            
            selection_start = time.perf_counter()
            
            selected_strategy, strategy_reason = self._select_strategy_from_regime(
                regime_data, features_data
            )
            
            component_timings['strategy_selection'] = (time.perf_counter() - selection_start) * 1000
            
            # === 4. GÉNÉRATION SIGNAUX STRATÉGIE ACTIVE ===
            
            signals_start = time.perf_counter()
            
            unified_signal, alternative_signals = self._generate_unified_signals(
                selected_strategy=selected_strategy,
                regime_data=regime_data,
                features_data=features_data,
                market_data=market_data,
                structure_data=structure_data,
                sierra_patterns=sierra_patterns
            )
            
            component_timings['signal_generation'] = (time.perf_counter() - signals_start) * 1000
            
            # === 5. VALIDATION FINALE + RECOMMANDATION ===
            
            validation_start = time.perf_counter()
            
            trade_recommendation, position_sizing_factor, risk_assessment = self._validate_and_recommend(
                unified_signal=unified_signal,
                regime_data=regime_data,
                features_data=features_data
            )
            
            component_timings['validation'] = (time.perf_counter() - validation_start) * 1000
            
            # === 6. COMPILATION RÉSULTAT FINAL ===
            
            total_time = (time.perf_counter() - start_time) * 1000
            
            result = StrategyOrchestrationResult(
                timestamp=market_data.timestamp,
                regime_data=regime_data,
                features_data=features_data,
                selected_strategy=selected_strategy,
                strategy_reason=strategy_reason,
                unified_signal=unified_signal,
                alternative_signals=alternative_signals,
                total_processing_time_ms=total_time,
                component_timings=component_timings,
                trade_recommendation=trade_recommendation,
                position_sizing_factor=position_sizing_factor,
                risk_assessment=risk_assessment
            )
            
            # Mise à jour statistiques
            self._update_orchestration_stats(result)
            
            # Logging décision
            self._log_trading_decision(result)
            
            return result
            
        except Exception as e:
            logger.error(f"Erreur orchestration trading: {e}")
            
            # Résultat d'erreur minimal
            return StrategyOrchestrationResult(
                timestamp=market_data.timestamp,
                regime_data=MarketRegimeData(timestamp=market_data.timestamp),
                features_data=FeatureCalculationResult(timestamp=market_data.timestamp),
                selected_strategy=StrategySelection.NO_STRATEGY,
                strategy_reason=f"Erreur système: {str(e)}",
                total_processing_time_ms=(time.perf_counter() - start_time) * 1000,
                trade_recommendation="ERROR"
            )
    
    def _select_strategy_from_regime(self,
                                   regime_data: MarketRegimeData,
                                   features_data: FeatureCalculationResult) -> Tuple[StrategySelection, str]:
        """
        SÉLECTION STRATÉGIE SELON RÉGIME MARCHÉ
        
        Logique hiérarchique :
        1. Régime unclear/transition → NO_STRATEGY
        2. Strong trends → TREND_ONLY  
        3. Weak trends → TREND_CAUTIOUS
        4. Range biased → RANGE_BIASED
        5. Range neutral → RANGE_NEUTRAL
        """
        
        regime = regime_data.regime
        confidence = regime_data.regime_confidence
        confluence_score = features_data.confluence_score
        
        # Seuil confidence minimum pour trading
        if confidence < self.regime_confidence_threshold:
            reason = f"Confidence régime trop faible: {confidence:.2f} < {self.regime_confidence_threshold}"
            self.stats['signals_filtered_regime'] += 1
            return StrategySelection.NO_STRATEGY, reason
        
        # Régimes interdisant le trading
        if regime in [MarketRegime.TRANSITION, MarketRegime.UNCLEAR]:
            reason = f"Régime {regime.value} - attendre clarification"
            return StrategySelection.NO_STRATEGY, reason
        
        # === TRENDS FORTS → TREND_ONLY ===
        
        if regime in [MarketRegime.STRONG_TREND_BULLISH, MarketRegime.STRONG_TREND_BEARISH]:
            reason = f"Trend fort détecté ({regime.value}) - TrendStrategy exclusive"
            self.stats['strategy_selection_counts']['trend_only'] += 1
            return StrategySelection.TREND_ONLY, reason
        
        # === TRENDS FAIBLES → TREND_CAUTIOUS ===
        
        elif regime in [MarketRegime.WEAK_TREND_BULLISH, MarketRegime.WEAK_TREND_BEARISH]:
            # Validation confluence plus stricte pour trends faibles
            if confluence_score >= 0.75:
                reason = f"Trend faible ({regime.value}) + confluence forte - TrendStrategy prudente"
                self.stats['strategy_selection_counts']['trend_cautious'] += 1
                return StrategySelection.TREND_CAUTIOUS, reason
            else:
                reason = f"Trend faible + confluence insuffisante ({confluence_score:.2f}) - attendre"
                return StrategySelection.NO_STRATEGY, reason
        
        # === RANGES AVEC BIAS → RANGE_BIASED ===
        
        elif regime in [MarketRegime.RANGE_BULLISH_BIAS, MarketRegime.RANGE_BEARISH_BIAS]:
            reason = f"Range avec bias ({regime.value}) - RangeStrategy directionnelle"
            self.stats['strategy_selection_counts']['range_biased'] += 1
            return StrategySelection.RANGE_BIASED, reason
        
        # === RANGE NEUTRE → RANGE_NEUTRAL ===
        
        elif regime == MarketRegime.RANGE_NEUTRAL:
            reason = f"Range neutre détecté - RangeStrategy both sides"
            self.stats['strategy_selection_counts']['range_neutral'] += 1
            return StrategySelection.RANGE_NEUTRAL, reason
        
        # === FALLBACK ===
        
        else:
            reason = f"Régime non géré: {regime.value}"
            self.stats['strategy_selection_counts']['no_strategy'] += 1
            return StrategySelection.NO_STRATEGY, reason
    
    def _generate_unified_signals(self,
                                selected_strategy: StrategySelection,
                                regime_data: MarketRegimeData,
                                features_data: FeatureCalculationResult,
                                market_data: MarketData,
                                structure_data: Optional[MarketStructureData],
                                sierra_patterns: Dict[str, float]) -> Tuple[Optional[UnifiedSignalData], List[UnifiedSignalData]]:
        """
        GÉNÉRATION SIGNAUX UNIFIÉS
        
        Exécute stratégie sélectionnée et unifie les signaux
        """
        
        unified_signal = None
        alternative_signals = []
        
        # === EXÉCUTION TREND STRATEGY ===
        
        if selected_strategy in [StrategySelection.TREND_ONLY, StrategySelection.TREND_CAUTIOUS]:
            
            trend_signal = self.trend_strategy.analyze_trend_signal(
                features=features_data,
                market_data=market_data,
                structure_data=self._convert_structure_for_trend(structure_data),
                sierra_patterns=sierra_patterns
            )
            
            if trend_signal:
                unified_signal = self._convert_trend_to_unified(
                    trend_signal, regime_data, features_data, selected_strategy
                )
                self.stats['trend_signals'] += 1
                self.stats['signals_generated'] += 1
        
        # === EXÉCUTION RANGE STRATEGY ===
        
        elif selected_strategy in [StrategySelection.RANGE_BIASED, StrategySelection.RANGE_NEUTRAL]:
            
            # Préparation contexte tendance pour bias
            trend_context = self._prepare_trend_context(regime_data)
            
            range_signal = self.range_strategy.analyze_range_signal(
                features=features_data,
                market_data=market_data,
                trend_context=trend_context,
                structure_data=self._convert_structure_for_range(structure_data),
                sierra_patterns=sierra_patterns
            )
            
            if range_signal:
                unified_signal = self._convert_range_to_unified(
                    range_signal, regime_data, features_data, selected_strategy
                )
                self.stats['range_signals'] += 1
                self.stats['signals_generated'] += 1
        
        # === MULTIPLES STRATEGIES (si activé) ===
        
        elif selected_strategy == StrategySelection.MULTIPLE and self.enable_multiple_strategies:
            
            # Exécution parallèle (pour comparaison)
            trend_signal = self.trend_strategy.analyze_trend_signal(
                features=features_data,
                market_data=market_data,
                sierra_patterns=sierra_patterns
            )
            
            range_signal = self.range_strategy.analyze_range_signal(
                features=features_data,
                market_data=market_data,
                sierra_patterns=sierra_patterns
            )
            
            # Sélection meilleur signal
            if trend_signal and range_signal:
                if trend_signal.confluence_score >= range_signal.confluence_score:
                    unified_signal = self._convert_trend_to_unified(trend_signal, regime_data, features_data, selected_strategy)
                    alternative_signals.append(self._convert_range_to_unified(range_signal, regime_data, features_data, selected_strategy))
                else:
                    unified_signal = self._convert_range_to_unified(range_signal, regime_data, features_data, selected_strategy)
                    alternative_signals.append(self._convert_trend_to_unified(trend_signal, regime_data, features_data, selected_strategy))
            elif trend_signal:
                unified_signal = self._convert_trend_to_unified(trend_signal, regime_data, features_data, selected_strategy)
            elif range_signal:
                unified_signal = self._convert_range_to_unified(range_signal, regime_data, features_data, selected_strategy)
        
        return unified_signal, alternative_signals
    
    def _convert_trend_to_unified(self,
                                trend_signal: TrendSignalData,
                                regime_data: MarketRegimeData,
                                features_data: FeatureCalculationResult,
                                strategy_selection: StrategySelection) -> UnifiedSignalData:
        """Conversion signal tendance vers unifié"""
        
        # Détermination priorité
        if trend_signal.confluence_score >= 0.85:
            priority = SignalPriority.PREMIUM
        elif trend_signal.confluence_score >= 0.70:
            priority = SignalPriority.HIGH
        elif trend_signal.confluence_score >= 0.60:
            priority = SignalPriority.MEDIUM
        else:
            priority = SignalPriority.LOW
        
        # Direction
        direction = "LONG" if trend_signal.direction.value == "bullish" else "SHORT"
        
        # Strategy logic
        strategy_logic = f"Trend {trend_signal.signal_type.value} - {trend_signal.entry_reason}"
        
        # Prédictions performance (basées sur type signal)
        expected_win_rate = self._estimate_trend_win_rate(trend_signal.signal_type)
        expected_profit_factor = self._estimate_trend_profit_factor(trend_signal.signal_type)
        
        return UnifiedSignalData(
            timestamp=trend_signal.timestamp,
            strategy_source="trend",
            signal_priority=priority,
            market_regime=regime_data.regime,
            regime_confidence=regime_data.regime_confidence,
            signal_type=trend_signal.signal_type.value,
            direction=direction,
            entry_price=trend_signal.entry_price,
            stop_loss=trend_signal.stop_loss,
            take_profit=trend_signal.take_profit,
            position_size=trend_signal.position_size,
            confluence_score=trend_signal.confluence_score,
            risk_reward_ratio=trend_signal.risk_reward_ratio(),
            bias_compliance=True,  # Trends toujours compliance
            entry_reason=trend_signal.entry_reason,
            strategy_logic=strategy_logic,
            original_trend_signal=trend_signal,
            expected_win_rate=expected_win_rate,
            expected_profit_factor=expected_profit_factor
        )
    
    def _convert_range_to_unified(self,
                                range_signal: RangeSignalData,
                                regime_data: MarketRegimeData,
                                features_data: FeatureCalculationResult,
                                strategy_selection: StrategySelection) -> UnifiedSignalData:
        """Conversion signal range vers unifié"""
        
        # Détermination priorité
        if range_signal.confluence_score >= 0.85:
            priority = SignalPriority.PREMIUM
        elif range_signal.confluence_score >= 0.70:
            priority = SignalPriority.HIGH
        elif range_signal.confluence_score >= 0.60:
            priority = SignalPriority.MEDIUM
        else:
            priority = SignalPriority.LOW
        
        # Strategy logic
        strategy_logic = f"Range {range_signal.signal_type.value} - {range_signal.entry_reason}"
        if range_signal.bias != RangeBias.NEUTRAL:
            strategy_logic += f" (bias: {range_signal.bias.value})"
        
        # Prédictions performance
        expected_win_rate = self._estimate_range_win_rate(range_signal.signal_type)
        expected_profit_factor = self._estimate_range_profit_factor(range_signal.signal_type)
        
        return UnifiedSignalData(
            timestamp=range_signal.timestamp,
            strategy_source="range",
            signal_priority=priority,
            market_regime=regime_data.regime,
            regime_confidence=regime_data.regime_confidence,
            signal_type=range_signal.signal_type.value,
            direction=range_signal.direction,
            entry_price=range_signal.entry_price,
            stop_loss=range_signal.stop_loss,
            take_profit=range_signal.take_profit,
            position_size=range_signal.position_size,
            confluence_score=range_signal.confluence_score,
            risk_reward_ratio=range_signal.risk_reward_ratio(),
            bias_compliance=range_signal.bias_compliance,
            entry_reason=range_signal.entry_reason,
            strategy_logic=strategy_logic,
            original_range_signal=range_signal,
            expected_win_rate=expected_win_rate,
            expected_profit_factor=expected_profit_factor
        )
    
    def _validate_and_recommend(self,
                               unified_signal: Optional[UnifiedSignalData],
                               regime_data: MarketRegimeData,
                               features_data: FeatureCalculationResult) -> Tuple[str, float, str]:
        """
        VALIDATION FINALE + RECOMMANDATION
        
        Returns:
            (trade_recommendation, position_sizing_factor, risk_assessment)
        """
        
        # Pas de signal généré
        if not unified_signal:
            return "NO_TRADE", 0.0, "NORMAL"
        
        # Validation confluence minimum
        if unified_signal.confluence_score < self.min_confluence_for_execution:
            self.stats['signals_filtered_confluence'] += 1
            return "WAIT", 0.0, "NORMAL"
        
        # Validation bias compliance pour range
        if unified_signal.strategy_source == "range" and not unified_signal.bias_compliance:
            return "WAIT", 0.0, "NORMAL"
        
        # Validation R:R minimum
        if unified_signal.risk_reward_ratio < 1.2:
            return "WAIT", 0.5, "HIGH"  # Signal faible
        
        # === RECOMMANDATIONS SELON PRIORITÉ ===
        
        if unified_signal.signal_priority == SignalPriority.PREMIUM:
            return "EXECUTE", 1.5, "LOW"   # Signal premium - size boost
        
        elif unified_signal.signal_priority == SignalPriority.HIGH:
            return "EXECUTE", 1.0, "NORMAL"  # Signal standard
        
        elif unified_signal.signal_priority == SignalPriority.MEDIUM:
            return "EXECUTE", 0.7, "NORMAL"  # Signal réduit
        
        else:  # LOW priority
            return "WAIT", 0.0, "HIGH"   # Trop faible - skip
    
    # === HELPER METHODS ===
    
    def _prepare_structure_data(self, structure_data: Optional[MarketStructureData]) -> Optional[Dict[str, Any]]:
        """Préparation données structure pour regime detector"""
        if not structure_data:
            return None
        
        return {
            'vwap_price': structure_data.vwap_price,
            'vwap_slope': structure_data.vwap_slope,
            'poc_price': structure_data.poc_price,
            'vah_price': structure_data.vah_price,
            'val_price': structure_data.val_price
        }
    
    def _prepare_es_nq_data(self, es_nq_data: Optional[ESNQData]) -> Optional[Dict[str, float]]:
        """Préparation données ES/NQ pour regime detector"""
        if not es_nq_data:
            return None
        
        return {
            'es_price': es_nq_data.es_price,
            'nq_price': es_nq_data.nq_price,
            'correlation': es_nq_data.correlation,
            'divergence': es_nq_data.divergence_signal
        }
    
    def _extract_sierra_patterns(self, regime_data: MarketRegimeData) -> Dict[str, float]:
        """Extraction patterns Sierra Chart du régime"""
        # Simulation - en production, viendrait de battle_navale.py
        return {
            'battle_navale_signal': 0.7,
            'base_quality': 0.6,
            'trend_continuation': 0.8,
            'battle_strength': 0.65
        }
    
    def _convert_structure_for_trend(self, structure_data: Optional[MarketStructureData]) -> Optional[Dict[str, Any]]:
        """Conversion structure data pour TrendStrategy"""
        if not structure_data:
            return None
        
        return {
            'vwap_price': structure_data.vwap_price,
            'vwap_slope': structure_data.vwap_slope,
            'poc_price': structure_data.poc_price,
            'es_nq_correlation': 0.8  # Default
        }
    
    def _convert_structure_for_range(self, structure_data: Optional[MarketStructureData]) -> Optional[Dict[str, Any]]:
        """Conversion structure data pour RangeStrategy"""
        if not structure_data:
            return None
        
        return {
            'vwap_price': structure_data.vwap_price,
            'val_price': structure_data.val_price,
            'vah_price': structure_data.vah_price,
            'poc_price': structure_data.poc_price
        }
    
    def _prepare_trend_context(self, regime_data: MarketRegimeData) -> Dict[str, Any]:
        """Préparation contexte tendance pour RangeStrategy bias"""
        
        # Extraction info tendance du régime
        trend_direction = "sideways"
        trend_strength = 0.0
        vwap_slope = 0.0
        
        if regime_data.regime in [MarketRegime.STRONG_TREND_BULLISH, MarketRegime.WEAK_TREND_BULLISH]:
            trend_direction = "bullish"
            trend_strength = 0.8 if "strong" in regime_data.regime.value else 0.5
            vwap_slope = 0.6
            
        elif regime_data.regime in [MarketRegime.STRONG_TREND_BEARISH, MarketRegime.WEAK_TREND_BEARISH]:
            trend_direction = "bearish"
            trend_strength = 0.8 if "strong" in regime_data.regime.value else 0.5
            vwap_slope = -0.6
            
        elif "bias" in regime_data.regime.value:
            if "bullish" in regime_data.regime.value:
                trend_direction = "bullish"
                trend_strength = 0.4
                vwap_slope = 0.3
            elif "bearish" in regime_data.regime.value:
                trend_direction = "bearish"
                trend_strength = 0.4
                vwap_slope = -0.3
        
        return {
            'dow_trend_direction': trend_direction,
            'trend_strength': trend_strength,
            'vwap_slope': vwap_slope
        }
    
    def _estimate_trend_win_rate(self, signal_type: TrendSignalType) -> float:
        """Estimation win rate pour signaux tendance"""
        win_rates = {
            TrendSignalType.PREMIUM_PULLBACK: 0.78,
            TrendSignalType.STRONG_PULLBACK: 0.72,
            TrendSignalType.PREMIUM_BREAKOUT: 0.68,
            TrendSignalType.STRONG_TREND: 0.65,
            TrendSignalType.WEAK_SIGNAL: 0.55
        }
        return win_rates.get(signal_type, 0.60)
    
    def _estimate_trend_profit_factor(self, signal_type: TrendSignalType) -> float:
        """Estimation profit factor pour signaux tendance"""
        profit_factors = {
            TrendSignalType.PREMIUM_PULLBACK: 2.2,
            TrendSignalType.STRONG_PULLBACK: 1.9,
            TrendSignalType.PREMIUM_BREAKOUT: 1.7,
            TrendSignalType.STRONG_TREND: 1.6,
            TrendSignalType.WEAK_SIGNAL: 1.3
        }
        return profit_factors.get(signal_type, 1.5)
    
    def _estimate_range_win_rate(self, signal_type: RangeSignalType) -> float:
        """Estimation win rate pour signaux range"""
        win_rates = {
            RangeSignalType.PREMIUM_BOUNCE: 0.75,
            RangeSignalType.STRONG_BOUNCE: 0.68,
            RangeSignalType.WEAK_BOUNCE: 0.58,
            RangeSignalType.EXIT_SPECIAL: 0.85
        }
        return win_rates.get(signal_type, 0.65)
    
    def _estimate_range_profit_factor(self, signal_type: RangeSignalType) -> float:
        """Estimation profit factor pour signaux range"""
        profit_factors = {
            RangeSignalType.PREMIUM_BOUNCE: 1.8,
            RangeSignalType.STRONG_BOUNCE: 1.6,
            RangeSignalType.WEAK_BOUNCE: 1.4,
            RangeSignalType.EXIT_SPECIAL: 2.5
        }
        return profit_factors.get(signal_type, 1.5)
    
    def _update_orchestration_stats(self, result: StrategyOrchestrationResult):
        """Mise à jour statistiques orchestration"""
        
        # Performance timing
        total_time = result.total_processing_time_ms
        count = self.stats['total_orchestrations']
        prev_avg = self.stats['avg_processing_time_ms']
        self.stats['avg_processing_time_ms'] = ((prev_avg * (count - 1)) + total_time) / count
    
    def _log_trading_decision(self, result: StrategyOrchestrationResult):
        """Logging décision trading"""
        
        regime = result.regime_data.regime.value
        confidence = result.regime_data.regime_confidence
        strategy = result.selected_strategy.value
        recommendation = result.trade_recommendation
        
        if result.unified_signal:
            signal = result.unified_signal
            logger.info(f"DÉCISION: {recommendation} | Régime: {regime} ({confidence:.2f}) | "
                       f"Stratégie: {strategy} | Signal: {signal.signal_type} {signal.direction} "
                       f"@ {signal.entry_price:.2f} | Confluence: {signal.confluence_score:.2f}")
        else:
            logger.info(f"DÉCISION: {recommendation} | Régime: {regime} ({confidence:.2f}) | "
                       f"Stratégie: {strategy} | Aucun signal généré")
    
    def get_system_statistics(self) -> Dict[str, Any]:
        """Statistiques système complet"""
        
        # Compilation stats de tous les composants
        regime_stats = self.regime_detector.get_statistics()
        feature_stats = self.feature_calculator.get_statistics()
        trend_stats = self.trend_strategy.get_statistics()
        range_stats = self.range_strategy.get_statistics()
        
        total_orchestrations = self.stats['total_orchestrations']
        
        return {
            # Performance globale
            'total_orchestrations': total_orchestrations,
            'avg_processing_time_ms': round(self.stats['avg_processing_time_ms'], 2),
            'signals_generated': self.stats['signals_generated'],
            'signal_generation_rate': (self.stats['signals_generated'] / total_orchestrations * 100) if total_orchestrations > 0 else 0,
            
            # Breakdown par stratégie
            'trend_signals_pct': (self.stats['trend_signals'] / self.stats['signals_generated'] * 100) if self.stats['signals_generated'] > 0 else 0,
            'range_signals_pct': (self.stats['range_signals'] / self.stats['signals_generated'] * 100) if self.stats['signals_generated'] > 0 else 0,
            
            # Filtrage qualité
            'signals_filtered_confluence': self.stats['signals_filtered_confluence'],
            'signals_filtered_regime': self.stats['signals_filtered_regime'],
            'filter_efficiency_pct': ((self.stats['signals_filtered_confluence'] + self.stats['signals_filtered_regime']) / total_orchestrations * 100) if total_orchestrations > 0 else 0,
            
            # Sélection stratégies
            'strategy_selection_breakdown': self.stats['strategy_selection_counts'],
            
            # Stats composants
            'regime_detector_stats': regime_stats,
            'feature_calculator_stats': feature_stats,
            'trend_strategy_stats': trend_stats,
            'range_strategy_stats': range_stats
        }

# === FACTORY FUNCTIONS ===

def create_strategy_orchestrator(config: Optional[Dict[str, Any]] = None) -> StrategyOrchestrator:
    """Factory function pour orchestrateur"""
    return StrategyOrchestrator(config)

def execute_trading_decision(market_data: MarketData,
                           order_flow: Optional[OrderFlowData] = None,
                           options_data: Optional[OptionsData] = None,
                           structure_data: Optional[MarketStructureData] = None,
                           es_nq_data: Optional[ESNQData] = None,
                           orchestrator: Optional[StrategyOrchestrator] = None) -> StrategyOrchestrationResult:
    """Helper function pour exécution décision trading"""
    
    if orchestrator is None:
        orchestrator = create_strategy_orchestrator()
    
    return orchestrator.orchestrate_trading_decision(
        market_data=market_data,
        order_flow=order_flow,
        options_data=options_data,
        structure_data=structure_data,
        es_nq_data=es_nq_data
    )

# === EXPORTS ===

from .trend_strategy import TrendStrategy, TrendSignalData, TrendSignalType
from .range_strategy import RangeStrategy, RangeSignalData, RangeSignalType, RangeBias

__all__ = [
    # Main orchestrator
    'StrategyOrchestrator',
    'create_strategy_orchestrator',
    'execute_trading_decision',
    
    # Data classes
    'UnifiedSignalData',
    'StrategyOrchestrationResult',
    
    # Enums
    'StrategySelection',
    'SignalPriority',
    
    # Strategy classes
    'TrendStrategy',
    'RangeStrategy',
    
    # Signal data classes
    'TrendSignalData',
    'RangeSignalData',
    
    # Signal types
    'TrendSignalType',
    'RangeSignalType',
    'RangeBias'
]