"""
scripts/start_automation.py

SCRIPT DÃ‰MARRAGE AUTOMATION - OBJECTIF PRIORITÃ‰ 9
Interface simple pour lancer l'automation Battle Navale en diffÃ©rents modes
Point d'entrÃ©e unique pour production, test, et collection de donnÃ©es

FONCTIONNALITÃ‰S :
1. start_paper_trading() - DÃ©marrage paper trading sÃ©curisÃ©
2. start_data_collection() - Collection donnÃ©es sans trading
3. start_live_trading() - Trading live avec capitaux rÃ©els
4. emergency_stop_all() - ArrÃªt d'urgence systÃ¨me complet
5. Monitoring intÃ©grÃ© et gestion erreurs
6. Configuration dynamique par mode
7. Logging dÃ©taillÃ© et alertes

ARCHITECTURE : Production-ready, failsafe, monitoring complet
"""

# === STDLIB ===
import os
import sys
import time
import signal
import logging
import argparse
import threading
import subprocess
from typing import Dict, List, Optional, Any
from pathlib import Path
from datetime import datetime, timezone
from enum import Enum
import json
import psutil

# === THIRD-PARTY ===
import numpy as np
import pandas as pd

# === LOCAL IMPORTS ===
# Configuration
from config import get_trading_config, get_automation_config

# Core Battle Navale
from core.base_types import (
    MarketData, TradingSignal, SignalType,
    TradeResult, ES_TICK_SIZE, ES_TICK_VALUE
)

# Logger
logger = logging.getLogger(__name__)

# === AUTOMATION ENUMS ===

class AutomationMode(Enum):
    """Modes d'automation"""
    PAPER_TRADING = "paper_trading"      # Paper trading sÃ©curisÃ©
    DATA_COLLECTION = "data_collection"  # Collection donnÃ©es uniquement
    LIVE_TRADING = "live_trading"        # Trading avec capital rÃ©el
    BACKTEST = "backtest"               # Backtest historique
    VALIDATION = "validation"           # Validation modÃ¨les

class SystemStatus(Enum):
    """Ã‰tats du systÃ¨me"""
    STOPPED = "stopped"
    STARTING = "starting"
    RUNNING = "running"
    STOPPING = "stopping"
    ERROR = "error"
    EMERGENCY_STOP = "emergency_stop"

class AutomationHealth(Enum):
    """SantÃ© de l'automation"""
    HEALTHY = "healthy"
    WARNING = "warning"
    CRITICAL = "critical"
    FAILURE = "failure"

# === AUTOMATION MANAGER ===

class AutomationManager:
    """
    GESTIONNAIRE CENTRAL D'AUTOMATION
    
    Orchestrateur principal pour tous les modes d'automation :
    - Gestion lifecycle (start/stop/restart)
    - Monitoring temps rÃ©el
    - Gestion erreurs et recovery
    - Coordination composants
    - SÃ©curitÃ© et failsafes
    """
    
    def __init__(self):
        """Initialisation du gestionnaire d'automation"""
        
        # Configuration
        self.trading_config = get_trading_config()
        self.auto_config = get_automation_config()
        
        # Ã‰tat systÃ¨me
        self.status = SystemStatus.STOPPED
        self.current_mode: Optional[AutomationMode] = None
        self.health = AutomationHealth.HEALTHY
        self.start_time: Optional[datetime] = None
        
        # Composants principaux (simulÃ©s pour cette phase)
        self.trader = None
        self.snapshotter = None
        self.monitor = None
        self.performance_tracker = None
        self.alert_system = None
        self.data_collector = None
        self.ml_model = None
        
        # Threads de monitoring
        self.monitoring_thread: Optional[threading.Thread] = None
        self.health_check_thread: Optional[threading.Thread] = None
        
        # Flags de contrÃ´le
        self.shutdown_requested = False
        self.emergency_stop_triggered = False
        
        # Paths et logging
        self.log_dir = Path("logs/automation")
        self.log_dir.mkdir(parents=True, exist_ok=True)
        
        # Setup signal handlers pour arrÃªt propre
        self._setup_signal_handlers()
        
        logger.info("AutomationManager initialisÃ©")
    
    def start_paper_trading(self, 
                           duration_hours: Optional[int] = None,
                           max_trades: Optional[int] = None) -> bool:
        """
        DÃ©marrage paper trading sÃ©curisÃ©
        
        Args:
            duration_hours: DurÃ©e maximale en heures (None = illimitÃ©)
            max_trades: Nombre maximum de trades (None = illimitÃ©)
            
        Returns:
            True si dÃ©marrage rÃ©ussi, False sinon
        """
        logger.info("=== DÃ‰MARRAGE PAPER TRADING ===")
        
        if self.status != SystemStatus.STOPPED:
            logger.error(f"Impossible de dÃ©marrer - Status actuel: {self.status.value}")
            return False
        
        try:
            self.status = SystemStatus.STARTING
            self.current_mode = AutomationMode.PAPER_TRADING
            
            # 1. Initialisation composants paper trading
            self._initialize_paper_trading_components()
            
            # 2. Validation configuration
            if not self._validate_paper_trading_config():
                self.status = SystemStatus.ERROR
                return False
            
            # 3. Setup monitoring
            self._setup_monitoring()
            
            # 4. Configuration limites sÃ©curitÃ©
            self._setup_paper_trading_limits(duration_hours, max_trades)
            
            # 5. DÃ©marrage trader (simulÃ©)
            logger.info("DÃ©marrage trader en mode PAPER...")
            
            # 6. DÃ©marrage monitoring
            self._start_monitoring_threads()
            
            # 7. Finalisation
            self.status = SystemStatus.RUNNING
            self.start_time = datetime.now(timezone.utc)
            
            logger.info("âœ… Paper trading dÃ©marrÃ© avec succÃ¨s")
            logger.info(f"Configuration: DurÃ©e={duration_hours}h, Max trades={max_trades}")
            
            return True
            
        except Exception as e:
            logger.error(f"Erreur dÃ©marrage paper trading: {e}")
            self.status = SystemStatus.ERROR
            self.emergency_stop_all()
            return False
    
    def start_data_collection(self, 
                             collection_hours: Optional[int] = None,
                             target_samples: Optional[int] = None) -> bool:
        """
        DÃ©marrage collection de donnÃ©es sans trading
        
        Args:
            collection_hours: DurÃ©e collection en heures
            target_samples: Nombre cible d'Ã©chantillons
            
        Returns:
            True si dÃ©marrage rÃ©ussi, False sinon
        """
        logger.info("=== DÃ‰MARRAGE DATA COLLECTION ===")
        
        if self.status != SystemStatus.STOPPED:
            logger.error(f"Impossible de dÃ©marrer - Status actuel: {self.status.value}")
            return False
        
        try:
            self.status = SystemStatus.STARTING
            self.current_mode = AutomationMode.DATA_COLLECTION
            
            # 1. Initialisation composants collection
            self._initialize_data_collection_components()
            
            # 2. Configuration collection
            collection_config = {
                "duration_hours": collection_hours or 8,
                "target_samples": target_samples or 1000,
                "include_market_data": True,
                "include_signals": True,
                "include_snapshots": True
            }
            
            # 3. DÃ©marrage collection
            logger.info("DÃ©marrage collection donnÃ©es...")
            
            # 4. Setup monitoring lÃ©ger
            self._setup_data_collection_monitoring()
            
            # 5. Finalisation
            self.status = SystemStatus.RUNNING
            self.start_time = datetime.now(timezone.utc)
            
            logger.info("âœ… Data collection dÃ©marrÃ©e avec succÃ¨s")
            logger.info(f"Configuration: {collection_config}")
            
            return True
            
        except Exception as e:
            logger.error(f"Erreur dÃ©marrage data collection: {e}")
            self.status = SystemStatus.ERROR
            return False
    
    def start_live_trading(self, 
                          capital_limit: Optional[float] = None,
                          max_position_size: Optional[int] = None) -> bool:
        """
        DÃ©marrage trading live avec capital rÃ©el - SÃ‰CURITÃ‰ MAXIMALE
        
        Args:
            capital_limit: Limite de capital Ã  risquer
            max_position_size: Taille maximale position
            
        Returns:
            True si dÃ©marrage rÃ©ussi, False sinon
        """
        logger.info("=== DÃ‰MARRAGE LIVE TRADING ===")
        logger.warning("âš ï¸  ATTENTION: TRADING AVEC CAPITAL RÃ‰EL âš ï¸")
        
        if self.status != SystemStatus.STOPPED:
            logger.error(f"Impossible de dÃ©marrer - Status actuel: {self.status.value}")
            return False
        
        try:
            self.status = SystemStatus.STARTING
            self.current_mode = AutomationMode.LIVE_TRADING
            
            # 1. VALIDATIONS SÃ‰CURITÃ‰ CRITIQUES
            if not self._validate_live_trading_safety():
                logger.error("ðŸš¨ VALIDATION SÃ‰CURITÃ‰ Ã‰CHEC - ARRÃŠT")
                self.status = SystemStatus.ERROR
                return False
            
            # 2. Confirmation utilisateur obligatoire
            if not self._confirm_live_trading():
                logger.info("Live trading annulÃ© par utilisateur")
                self.status = SystemStatus.STOPPED
                return False
            
            # 3. Initialisation composants live trading
            self._initialize_live_trading_components()
            
            # 4. Configuration limites strictes
            self._setup_live_trading_limits(capital_limit, max_position_size)
            
            # 5. Test connexions critiques
            if not self._test_live_connections():
                logger.error("Test connexions live Ã©chec")
                self.status = SystemStatus.ERROR
                return False
            
            # 6. DÃ©marrage avec monitoring renforcÃ©
            self._setup_live_monitoring()
            
            # 7. DÃ©marrage trader live
            logger.info("ðŸš€ DÃ©marrage trader en mode LIVE...")
            
            # 8. Monitoring threads
            self._start_monitoring_threads()
            
            # 9. Finalisation
            self.status = SystemStatus.RUNNING
            self.start_time = datetime.now(timezone.utc)
            
            logger.info("âœ… Live trading dÃ©marrÃ© avec CAPITAL RÃ‰EL")
            logger.warning("ðŸ”´ SURVEILLANCE CONTINUE REQUISE")
            
            return True
            
        except Exception as e:
            logger.error(f"Erreur critique live trading: {e}")
            self.status = SystemStatus.ERROR
            self.emergency_stop_all()
            return False
    
    def emergency_stop_all(self) -> bool:
        """
        ArrÃªt d'urgence complet du systÃ¨me
        
        Returns:
            True si arrÃªt rÃ©ussi, False sinon
        """
        logger.warning("ðŸš¨ ARRÃŠT D'URGENCE DÃ‰CLENCHÃ‰ ðŸš¨")
        
        self.emergency_stop_triggered = True
        self.status = SystemStatus.EMERGENCY_STOP
        
        try:
            # 1. ArrÃªt immÃ©diat trader
            if self.trader:
                logger.info("ArrÃªt d'urgence trader...")
                # self.trader.emergency_stop()
            
            # 2. Fermeture positions ouvertes
            self._close_all_positions_emergency()
            
            # 3. ArrÃªt composants
            self._stop_all_components()
            
            # 4. ArrÃªt threads
            self._stop_monitoring_threads()
            
            # 5. Sauvegarde Ã©tat d'urgence
            self._save_emergency_state()
            
            # 6. Finalisation
            self.status = SystemStatus.STOPPED
            self.current_mode = None
            
            logger.info("âœ… ArrÃªt d'urgence terminÃ©")
            return True
            
        except Exception as e:
            logger.error(f"Erreur lors arrÃªt d'urgence: {e}")
            return False
    
    def get_system_status(self) -> Dict[str, Any]:
        """
        Statut complet du systÃ¨me
        
        Returns:
            Dictionnaire avec statut dÃ©taillÃ©
        """
        runtime = None
        if self.start_time:
            runtime = (datetime.now(timezone.utc) - self.start_time).total_seconds()
        
        return {
            "status": self.status.value,
            "mode": self.current_mode.value if self.current_mode else None,
            "health": self.health.value,
            "start_time": self.start_time.isoformat() if self.start_time else None,
            "runtime_seconds": runtime,
            "emergency_stop": self.emergency_stop_triggered,
            "components": {
                "trader": self.trader is not None,
                "monitor": self.monitor is not None,
                "data_collector": self.data_collector is not None,
            },
            "system_resources": self._get_system_resources()
        }
    
    def stop_automation(self) -> bool:
        """
        ArrÃªt propre de l'automation
        
        Returns:
            True si arrÃªt rÃ©ussi, False sinon
        """
        logger.info("DÃ©but arrÃªt propre automation...")
        
        if self.status == SystemStatus.STOPPED:
            logger.info("SystÃ¨me dÃ©jÃ  arrÃªtÃ©")
            return True
        
        try:
            self.status = SystemStatus.STOPPING
            self.shutdown_requested = True
            
            # 1. ArrÃªt propre trader
            if self.trader:
                logger.info("ArrÃªt propre trader...")
                # self.trader.stop_trading()
            
            # 2. Finalisation snapshots
            if self.snapshotter:
                logger.info("Finalisation snapshots...")
                # self.snapshotter.finalize_session()
            
            # 3. ArrÃªt monitoring
            self._stop_monitoring_threads()
            
            # 4. Sauvegarde finale
            self._save_final_state()
            
            # 5. Finalisation
            self.status = SystemStatus.STOPPED
            self.current_mode = None
            
            logger.info("âœ… ArrÃªt propre terminÃ©")
            return True
            
        except Exception as e:
            logger.error(f"Erreur arrÃªt propre: {e}")
            return self.emergency_stop_all()
    
    # === MÃ‰THODES PRIVÃ‰ES ===
    
    def _setup_signal_handlers(self):
        """Configuration gestionnaires de signaux"""
        def signal_handler(signum, frame):
            logger.warning(f"Signal {signum} reÃ§u - arrÃªt propre...")
            self.stop_automation()
            sys.exit(0)
        
        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)
    
    def _initialize_paper_trading_components(self):
        """Initialisation composants pour paper trading"""
        logger.info("Initialisation composants paper trading...")
        
        # Simulation des composants (Ã  remplacer par vrais imports)
        self.trader = "SimulatedTrader"
        self.snapshotter = "SimulatedSnapshotter"
        self.monitor = "SimulatedMonitor"
        
        logger.info("Composants paper trading initialisÃ©s")
    
    def _initialize_data_collection_components(self):
        """Initialisation composants pour collection donnÃ©es"""
        logger.info("Initialisation composants data collection...")
        
        # Simulation des composants
        self.data_collector = "SimulatedDataCollector"
        self.snapshotter = "SimulatedSnapshotter"
        
        logger.info("Composants data collection initialisÃ©s")
    
    def _initialize_live_trading_components(self):
        """Initialisation composants pour live trading"""
        logger.info("Initialisation composants live trading...")
        
        # Simulation des composants
        self.trader = "LiveTrader"
        self.snapshotter = "LiveSnapshotter"
        self.monitor = "LiveMonitor"
        self.alert_system = "LiveAlertSystem"
        
        logger.info("Composants live trading initialisÃ©s")
    
    def _validate_paper_trading_config(self) -> bool:
        """Validation configuration paper trading"""
        logger.info("Validation configuration paper trading...")
        
        # Validations basiques
        if not self.trading_config:
            logger.error("Configuration trading manquante")
            return False
        
        if not self.auto_config:
            logger.error("Configuration automation manquante")
            return False
        
        logger.info("âœ… Configuration paper trading validÃ©e")
        return True
    
    def _validate_live_trading_safety(self) -> bool:
        """Validation sÃ©curitÃ© critique pour live trading"""
        logger.info("ðŸ” Validation sÃ©curitÃ© live trading...")
        
        safety_checks = []
        
        # 1. Configuration prÃ©sente
        if self.trading_config and self.auto_config:
            safety_checks.append("Configuration OK")
        else:
            logger.error("âŒ Configuration manquante")
            return False
        
        # 2. Limites de risque configurÃ©es
        if hasattr(self.auto_config, 'max_daily_loss') and self.auto_config.max_daily_loss > 0:
            safety_checks.append("Limites risque configurÃ©es")
        else:
            logger.error("âŒ Limites de risque non configurÃ©es")
            return False
        
        # 3. Mode paper validÃ© avant
        # TODO: VÃ©rifier historique paper trading
        safety_checks.append("Paper trading prerequis OK")
        
        # 4. Validation modÃ¨le
        # TODO: VÃ©rifier performance modÃ¨le ML
        safety_checks.append("ModÃ¨le validÃ©")
        
        logger.info(f"âœ… Validation sÃ©curitÃ©: {len(safety_checks)} checks OK")
        for check in safety_checks:
            logger.info(f"  âœ“ {check}")
        
        return True
    
    def _confirm_live_trading(self) -> bool:
        """Confirmation utilisateur pour live trading"""
        logger.warning("âš ï¸  CONFIRMATION REQUISE POUR LIVE TRADING âš ï¸")
        
        # En production, demander confirmation interactive
        # Pour ce script, on simule une confirmation
        
        confirmation_text = """
        ðŸš¨ ATTENTION: TRADING AVEC CAPITAL RÃ‰EL ðŸš¨
        
        Vous Ãªtes sur le point de dÃ©marrer le trading automatique
        avec de l'argent rÃ©el. Ceci peut entraÃ®ner des pertes.
        
        Confirmez-vous vouloir continuer ? (yes/no): 
        """
        
        # Simulation: en production, utiliser input()
        # response = input(confirmation_text).lower().strip()
        # return response == "yes"
        
        # Pour cette dÃ©mo, on simule une confirmation
        logger.warning("Confirmation automatique activÃ©e pour dÃ©mo")
        return True
    
    def _setup_monitoring(self):
        """Configuration monitoring standard"""
        logger.info("Configuration monitoring...")
        
        # Setup monitoring components (simulÃ©)
        self.monitor = "StandardMonitor"
        self.performance_tracker = "StandardPerformanceTracker"
        
        logger.info("Monitoring configurÃ©")
    
    def _setup_data_collection_monitoring(self):
        """Configuration monitoring pour data collection"""
        logger.info("Configuration monitoring data collection...")
        
        # Monitoring lÃ©ger pour collection donnÃ©es
        self.monitor = "DataCollectionMonitor"
        
        logger.info("Monitoring data collection configurÃ©")
    
    def _setup_live_monitoring(self):
        """Configuration monitoring renforcÃ© pour live trading"""
        logger.info("Configuration monitoring live renforcÃ©...")
        
        # Monitoring complet pour live trading
        self.monitor = "LiveMonitorReinforced"
        self.performance_tracker = "LivePerformanceTracker"
        self.alert_system = "LiveAlertSystem"
        
        logger.info("Monitoring live renforcÃ© configurÃ©")
    
    def _setup_paper_trading_limits(self, duration_hours, max_trades):
        """Configuration limites paper trading"""
        limits = {
            "duration_hours": duration_hours or 24,
            "max_trades": max_trades or 100,
            "max_position_size": 1,  # 1 contrat max en paper
            "max_daily_loss": 500   # $500 max loss simulÃ©
        }
        
        logger.info(f"Limites paper trading: {limits}")
    
    def _setup_live_trading_limits(self, capital_limit, max_position_size):
        """Configuration limites strictes live trading"""
        limits = {
            "capital_limit": capital_limit or 5000,  # $5000 max par dÃ©faut
            "max_position_size": max_position_size or 1,  # 1 contrat max
            "max_daily_loss": 200,  # $200 max loss par jour
            "max_daily_trades": 10,  # 10 trades max par jour
            "stop_loss_mandatory": True
        }
        
        logger.warning(f"ðŸ”’ Limites STRICTES live trading: {limits}")
    
    def _test_live_connections(self) -> bool:
        """Test connexions critiques pour live trading"""
        logger.info("Test connexions live...")
        
        # Test connexions broker, donnÃ©es, etc.
        connections_ok = [
            "Broker connection OK",
            "Market data feed OK", 
            "Risk management system OK"
        ]
        
        for connection in connections_ok:
            logger.info(f"âœ“ {connection}")
        
        return True
    
    def _start_monitoring_threads(self):
        """DÃ©marrage threads de monitoring"""
        logger.info("DÃ©marrage threads monitoring...")
        
        # Thread monitoring principal
        self.monitoring_thread = threading.Thread(
            target=self._monitoring_loop,
            daemon=True
        )
        self.monitoring_thread.start()
        
        # Thread health check
        self.health_check_thread = threading.Thread(
            target=self._health_check_loop,
            daemon=True
        )
        self.health_check_thread.start()
        
        logger.info("Threads monitoring dÃ©marrÃ©s")
    
    def _monitoring_loop(self):
        """Boucle principale de monitoring"""
        logger.info("DÃ©marrage boucle monitoring...")
        
        while not self.shutdown_requested and self.status == SystemStatus.RUNNING:
            try:
                # Monitoring des composants
                self._check_components_health()
                
                # Monitoring performance
                self._check_performance_metrics()
                
                # Monitoring ressources systÃ¨me
                self._check_system_resources()
                
                # Pause
                time.sleep(30)  # Check toutes les 30 secondes
                
            except Exception as e:
                logger.error(f"Erreur monitoring loop: {e}")
                time.sleep(10)
        
        logger.info("ArrÃªt boucle monitoring")
    
    def _health_check_loop(self):
        """Boucle de vÃ©rification santÃ© systÃ¨me"""
        logger.info("DÃ©marrage health check...")
        
        while not self.shutdown_requested and self.status == SystemStatus.RUNNING:
            try:
                # Health check complet
                self._perform_health_check()
                
                # Pause plus longue pour health check
                time.sleep(60)  # Check toutes les minutes
                
            except Exception as e:
                logger.error(f"Erreur health check: {e}")
                time.sleep(30)
        
        logger.info("ArrÃªt health check")
    
    def _check_components_health(self):
        """VÃ©rification santÃ© des composants"""
        # Simulation check composants
        if self.current_mode == AutomationMode.LIVE_TRADING:
            # Checks plus stricts en live
            pass
        
        # logger.debug("Components health OK")
    
    def _check_performance_metrics(self):
        """VÃ©rification mÃ©triques de performance"""
        # Simulation check performance
        # logger.debug("Performance metrics OK")
        pass
    
    def _check_system_resources(self):
        """VÃ©rification ressources systÃ¨me"""
        try:
            cpu_percent = psutil.cpu_percent()
            memory = psutil.virtual_memory()
            
            if cpu_percent > 90:
                logger.warning(f"âš ï¸ CPU Ã©levÃ©: {cpu_percent}%")
                self.health = AutomationHealth.WARNING
            
            if memory.percent > 90:
                logger.warning(f"âš ï¸ MÃ©moire Ã©levÃ©e: {memory.percent}%")
                self.health = AutomationHealth.WARNING
                
        except Exception as e:
            logger.error(f"Erreur check ressources: {e}")
    
    def _perform_health_check(self):
        """Health check complet du systÃ¨me"""
        try:
            # Reset health status
            self.health = AutomationHealth.HEALTHY
            
            # VÃ©rifications selon le mode
            if self.current_mode == AutomationMode.LIVE_TRADING:
                self._live_trading_health_check()
            elif self.current_mode == AutomationMode.PAPER_TRADING:
                self._paper_trading_health_check()
            elif self.current_mode == AutomationMode.DATA_COLLECTION:
                self._data_collection_health_check()
            
        except Exception as e:
            logger.error(f"Erreur health check: {e}")
            self.health = AutomationHealth.FAILURE
    
    def _live_trading_health_check(self):
        """Health check spÃ©cifique live trading"""
        # Checks critiques pour live trading
        checks_passed = 0
        total_checks = 5
        
        # 1. Connexion broker
        if self.trader:
            checks_passed += 1
        
        # 2. DonnÃ©es marchÃ©
        checks_passed += 1
        
        # 3. SystÃ¨me risque
        checks_passed += 1
        
        # 4. Performance dans limites
        checks_passed += 1
        
        # 5. Pas de situations d'urgence
        if not self.emergency_stop_triggered:
            checks_passed += 1
        
        # Ã‰valuation santÃ©
        if checks_passed == total_checks:
            self.health = AutomationHealth.HEALTHY
        elif checks_passed >= 4:
            self.health = AutomationHealth.WARNING
        else:
            self.health = AutomationHealth.CRITICAL
            logger.error(f"ðŸš¨ SANTÃ‰ CRITIQUE: {checks_passed}/{total_checks} checks OK")
    
    def _paper_trading_health_check(self):
        """Health check pour paper trading"""
        self.health = AutomationHealth.HEALTHY  # Moins critique
    
    def _data_collection_health_check(self):
        """Health check pour data collection"""
        self.health = AutomationHealth.HEALTHY  # Moins critique
    
    def _stop_monitoring_threads(self):
        """ArrÃªt des threads de monitoring"""
        logger.info("ArrÃªt threads monitoring...")
        
        self.shutdown_requested = True
        
        # Attendre arrÃªt threads
        if self.monitoring_thread and self.monitoring_thread.is_alive():
            self.monitoring_thread.join(timeout=5)
        
        if self.health_check_thread and self.health_check_thread.is_alive():
            self.health_check_thread.join(timeout=5)
        
        logger.info("Threads monitoring arrÃªtÃ©s")
    
    def _close_all_positions_emergency(self):
        """Fermeture d'urgence toutes positions"""
        logger.warning("ðŸš¨ Fermeture d'urgence positions...")
        
        if self.current_mode == AutomationMode.LIVE_TRADING:
            # En live, fermeture rÃ©elle des positions
            logger.warning("FERMETURE POSITIONS RÃ‰ELLES")
            # TODO: ImplÃ©mentation fermeture positions
        
        logger.info("Positions fermÃ©es (simulation)")
    
    def _stop_all_components(self):
        """ArrÃªt de tous les composants"""
        logger.info("ArrÃªt composants...")
        
        # ArrÃªt simulÃ© des composants
        self.trader = None
        self.snapshotter = None
        self.monitor = None
        self.data_collector = None
        
        logger.info("Composants arrÃªtÃ©s")
    
    def _save_emergency_state(self):
        """Sauvegarde Ã©tat d'urgence"""
        emergency_state = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "mode": self.current_mode.value if self.current_mode else None,
            "reason": "emergency_stop_triggered",
            "system_status": self.get_system_status()
        }
        
        emergency_file = self.log_dir / f"emergency_state_{int(time.time())}.json"
        
        try:
            with open(emergency_file, 'w') as f:
                json.dump(emergency_state, f, indent=2)
            
            logger.info(f"Ã‰tat d'urgence sauvegardÃ©: {emergency_file}")
            
        except Exception as e:
            logger.error(f"Erreur sauvegarde Ã©tat urgence: {e}")
    
    def _save_final_state(self):
        """Sauvegarde Ã©tat final"""
        final_state = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "mode": self.current_mode.value if self.current_mode else None,
            "runtime_seconds": (datetime.now(timezone.utc) - self.start_time).total_seconds() if self.start_time else 0,
            "system_status": self.get_system_status()
        }
        
        final_file = self.log_dir / f"final_state_{int(time.time())}.json"
        
        try:
            with open(final_file, 'w') as f:
                json.dump(final_state, f, indent=2)
            
            logger.info(f"Ã‰tat final sauvegardÃ©: {final_file}")
            
        except Exception as e:
            logger.error(f"Erreur sauvegarde Ã©tat final: {e}")
    
    def _get_system_resources(self) -> Dict[str, Any]:
        """Informations ressources systÃ¨me"""
        try:
            return {
                "cpu_percent": psutil.cpu_percent(),
                "memory_percent": psutil.virtual_memory().percent,
                "disk_usage": psutil.disk_usage('/').percent if os.name != 'nt' else psutil.disk_usage('C:').percent,
                "process_count": len(psutil.pids())
            }
        except Exception:
            return {"error": "Unable to get system resources"}

# === GLOBAL AUTOMATION MANAGER ===

# Instance globale du gestionnaire
automation_manager = AutomationManager()

# === FONCTIONS PRINCIPALES ===

def start_paper_trading(duration_hours: Optional[int] = None, max_trades: Optional[int] = None) -> bool:
    """
    DÃ©marrage paper trading sÃ©curisÃ©
    
    Args:
        duration_hours: DurÃ©e en heures (None = illimitÃ©)
        max_trades: Nombre max trades (None = illimitÃ©)
        
    Returns:
        True si succÃ¨s, False sinon
    """
    return automation_manager.start_paper_trading(duration_hours, max_trades)

def start_data_collection(collection_hours: Optional[int] = None, target_samples: Optional[int] = None) -> bool:
    """
    DÃ©marrage collection donnÃ©es sans trading
    
    Args:
        collection_hours: DurÃ©e collection en heures
        target_samples: Nombre cible Ã©chantillons
        
    Returns:
        True si succÃ¨s, False sinon
    """
    return automation_manager.start_data_collection(collection_hours, target_samples)

def start_live_trading(capital_limit: Optional[float] = None, max_position_size: Optional[int] = None) -> bool:
    """
    DÃ©marrage trading live avec capital rÃ©el
    
    Args:
        capital_limit: Limite capital Ã  risquer
        max_position_size: Taille max position
        
    Returns:
        True si succÃ¨s, False sinon
    """
    return automation_manager.start_live_trading(capital_limit, max_position_size)

def emergency_stop_all() -> bool:
    """
    ArrÃªt d'urgence complet du systÃ¨me
    
    Returns:
        True si succÃ¨s, False sinon
    """
    return automation_manager.emergency_stop_all()

def get_automation_status() -> Dict[str, Any]:
    """
    Statut actuel de l'automation
    
    Returns:
        Dictionnaire avec statut dÃ©taillÃ©
    """
    return automation_manager.get_system_status()

def stop_automation() -> bool:
    """
    ArrÃªt propre de l'automation
    
    Returns:
        True si succÃ¨s, False sinon
    """
    return automation_manager.stop_automation()

# === CLI INTERFACE ===

def main():
    """Interface en ligne de commande"""
    
    parser = argparse.ArgumentParser(description="MIA Trading Automation Starter")
    parser.add_argument("mode", choices=["paper", "data", "live", "status", "stop", "emergency"],
                       help="Mode d'automation")
    
    # Arguments optionnels
    parser.add_argument("--duration", type=int, help="DurÃ©e en heures")
    parser.add_argument("--max-trades", type=int, help="Nombre max de trades")
    parser.add_argument("--capital-limit", type=float, help="Limite de capital")
    parser.add_argument("--max-position", type=int, help="Taille max position")
    parser.add_argument("--samples", type=int, help="Nombre cible Ã©chantillons")
    parser.add_argument("--verbose", "-v", action="store_true", help="Logging verbose")
    
    args = parser.parse_args()
    
    # Configuration logging
    log_level = logging.DEBUG if args.verbose else logging.INFO
    logging.basicConfig(
        level=log_level,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(f"logs/automation/automation_{datetime.now().strftime('%Y%m%d')}.log"),
            logging.StreamHandler()
        ]
    )
    
    logger.info("=== MIA TRADING AUTOMATION STARTER ===")
    
    try:
        # ExÃ©cution selon mode
        if args.mode == "paper":
            success = start_paper_trading(args.duration, args.max_trades)
            if success:
                print("âœ… Paper trading dÃ©marrÃ© avec succÃ¨s")
                # Maintenir le processus actif
                try:
                    while automation_manager.status == SystemStatus.RUNNING:
                        time.sleep(10)
                except KeyboardInterrupt:
                    logger.info("Interruption clavier - arrÃªt propre...")
                    stop_automation()
            else:
                print("âŒ Ã‰chec dÃ©marrage paper trading")
                sys.exit(1)
        
        elif args.mode == "data":
            success = start_data_collection(args.duration, args.samples)
            if success:
                print("âœ… Data collection dÃ©marrÃ©e avec succÃ¨s")
                # Maintenir le processus actif
                try:
                    while automation_manager.status == SystemStatus.RUNNING:
                        time.sleep(10)
                except KeyboardInterrupt:
                    logger.info("Interruption clavier - arrÃªt propre...")
                    stop_automation()
            else:
                print("âŒ Ã‰chec dÃ©marrage data collection")
                sys.exit(1)
        
        elif args.mode == "live":
            success = start_live_trading(args.capital_limit, args.max_position)
            if success:
                print("âœ… Live trading dÃ©marrÃ© avec succÃ¨s")
                print("ðŸ”´ SURVEILLANCE CONTINUE REQUISE")
                # Maintenir le processus actif
                try:
                    while automation_manager.status == SystemStatus.RUNNING:
                        time.sleep(10)
                except KeyboardInterrupt:
                    logger.info("Interruption clavier - arrÃªt propre...")
                    stop_automation()
            else:
                print("âŒ Ã‰chec dÃ©marrage live trading")
                sys.exit(1)
        
        elif args.mode == "status":
            status = get_automation_status()
            print("ðŸ“Š STATUT AUTOMATION:")
            print(json.dumps(status, indent=2))
        
        elif args.mode == "stop":
            success = stop_automation()
            if success:
                print("âœ… Automation arrÃªtÃ©e proprement")
            else:
                print("âŒ Erreur arrÃªt automation")
                sys.exit(1)
        
        elif args.mode == "emergency":
            success = emergency_stop_all()
            if success:
                print("ðŸš¨ ARRÃŠT D'URGENCE EFFECTUÃ‰")
            else:
                print("âŒ Erreur arrÃªt d'urgence")
                sys.exit(1)
    
    except Exception as e:
        logger.error(f"Erreur critique: {e}")
        print(f"âŒ Erreur critique: {e}")
        emergency_stop_all()
        sys.exit(1)

# === TEST FUNCTION ===

def test_automation_starter():
    """Test complet du starter d'automation"""
    logger.info("=== TEST AUTOMATION STARTER ===")
    
    print("Test 1: Paper Trading")
    success = start_paper_trading(duration_hours=1, max_trades=5)
    print(f"Paper trading: {'âœ…' if success else 'âŒ'}")
    
    if success:
        time.sleep(2)
        
        status = get_automation_status()
        print(f"Status: {status['status']}")
        
        stop_success = stop_automation()
        print(f"Stop: {'âœ…' if stop_success else 'âŒ'}")
    
    print("\nTest 2: Data Collection")
    success = start_data_collection(collection_hours=1, target_samples=100)
    print(f"Data collection: {'âœ…' if success else 'âŒ'}")
    
    if success:
        time.sleep(2)
        stop_success = stop_automation()
        print(f"Stop: {'âœ…' if stop_success else 'âŒ'}")
    
    print("\nTest 3: Emergency Stop")
    emergency_success = emergency_stop_all()
    print(f"Emergency stop: {'âœ…' if emergency_success else 'âŒ'}")
    
    logger.info("=== TEST TERMINÃ‰ ===")

if __name__ == "__main__":
    if len(sys.argv) > 1:
        main()
    else:
        print("Usage: python start_automation.py {paper|data|live|status|stop|emergency}")
        print("Ou lancez test_automation_starter() pour tests")