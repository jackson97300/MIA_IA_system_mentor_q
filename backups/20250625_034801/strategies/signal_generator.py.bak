#!/usr/bin/env python3
"""
MIA_IA_SYSTEM - Signal Generator 
üß† CERVEAU CENTRAL DU BOT - Orchestrateur Signaux Master
Version: Production Ready
Performance: G√©n√©ration signal compl√®te <5ms

RESPONSABILIT√âS CRITIQUES :
1. üé™ ORCHESTRATION COMPL√àTE - Combine tous vos composants
2. üéØ D√âCISION INTELLIGENTE - 1 signal final unifi√©  
3. üîç VALIDATION QUALIT√â - Filtres confluence + coh√©rence
4. ‚ö° ADAPTATION R√âGIME - Trend vs Range vs Wait
5. üõ°Ô∏è GESTION RISQUE - Position sizing + stops
6. üìä PERFORMANCE TRACKING - M√©triques temps r√©el

WORKFLOW COMPLET :
MarketData ‚Üí Features ‚Üí R√©gime ‚Üí Strat√©gie ‚Üí Bataille Navale ‚Üí Confluence ‚Üí Signal Final

SIGNAUX G√âN√âR√âS :
- LONG_TREND/SHORT_TREND : Setups tendance confirm√©s
- LONG_RANGE/SHORT_RANGE : Setups range confirm√©s  
- EXIT_PROFIT/EXIT_STOP : Sorties positions
- NO_SIGNAL : Attendre meilleur setup

INPUT : MarketData + OrderFlow + Options + Structure
OUTPUT : 1 TradingSignal unifi√© pr√™t pour ex√©cution
"""

import time
import logging
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Any, Union
from dataclasses import dataclass, field
from enum import Enum
from collections import deque, defaultdict

# === IMPORTS CORE ===
from core.base_types import (
    StructureData,
    MarketData, OrderFlowData, TradingSignal, SignalType, 
    MarketRegime, PatternType, SignalStrength, TradingFeatures,
    ES_TICK_SIZE, ES_TICK_VALUE
)

# === IMPORTS COMPONENTS ===
from features.market_regime import MarketRegimeDetector
try:
    from core.battle_navale import BattleNavaleAnalyzer, BattleNavaleResult
except ImportError:
    from core.battle_navale import BattleNavaleDetector as BattleNavaleAnalyzer

from features.feature_calculator import (
    FeatureCalculator, FeatureCalculationResult, SignalQuality
)
from features.confluence_analyzer import (
    ConfluenceAnalyzer, ConfluenceAnalysis, ConfluenceZone
)
from features.market_regime import (
    MarketRegimeDetector, MarketRegimeData
)
from strategies.trend_strategy import (
    TrendStrategy, TrendSignalData, TrendSignalType
)
from strategies.range_strategy import (
    RangeStrategy, RangeSignalData, RangeSignalType
)

logger = logging.getLogger(__name__)

# === SIGNAL GENERATOR ENUMS ===

class SignalDecision(Enum):
    """D√©cisions finales possibles"""
    EXECUTE_LONG = "execute_long"
    EXECUTE_SHORT = "execute_short"
    EXIT_POSITION = "exit_position"
    WAIT_BETTER_SETUP = "wait_better_setup"
    INSUFFICIENT_CONFLUENCE = "insufficient_confluence"
    REGIME_UNCLEAR = "regime_unclear"

class SignalSource(Enum):
    """Sources de signaux"""
    BATTLE_NAVALE = "battle_navale"
    TREND_STRATEGY = "trend_strategy"
    RANGE_STRATEGY = "range_strategy"
    CONFLUENCE_FILTER = "confluence_filter"
    RISK_MANAGER = "risk_manager"

class QualityLevel(Enum):
    """Niveaux de qualit√© signal"""
    PREMIUM = "premium"      # 90-100% - Best setups
    STRONG = "strong"        # 80-89%  - Good setups
    MODERATE = "moderate"    # 70-79%  - Acceptable
    WEAK = "weak"           # 60-69%  - Reduced size
    REJECT = "reject"       # 0-59%   - No trade

# === SIGNAL GENERATOR DATACLASSES ===

@dataclass
class SignalComponents:
    """Composants d'analyse d'un signal"""
    timestamp: pd.Timestamp
    
    # R√©sultats composants
    features: Optional[FeatureCalculationResult] = None
    battle_navale: Optional[Any] = None  # BattleNavaleResult
    market_regime: Optional[MarketRegimeData] = None
    confluence: Optional[ConfluenceAnalysis] = None
    trend_signal: Optional[TrendSignalData] = None
    range_signal: Optional[RangeSignalData] = None
    
    # M√©triques qualit√©
    overall_confidence: float = 0.0
    confluence_boost: float = 0.0
    regime_alignment: float = 0.0
    
    # Performance
    analysis_time_ms: float = 0.0

@dataclass
class FinalSignal:
    """Signal final g√©n√©r√©"""
    timestamp: pd.Timestamp
    decision: SignalDecision
    signal_type: SignalType
    
    # Pricing
    entry_price: float
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    
    # Risk
    position_size: float = 1.0
    risk_reward_ratio: float = 0.0
    
    # Quality metrics
    confidence: float = 0.0
    quality_level: QualityLevel = QualityLevel.WEAK
    confluence_score: float = 0.0
    
    # Sources & reasoning
    primary_source: SignalSource = SignalSource.BATTLE_NAVALE
    reasoning: str = ""
    components: Optional[SignalComponents] = None
    
    # Metadata
    metadata: Dict[str, Any] = field(default_factory=dict)

# === MAIN SIGNAL GENERATOR ===

class SignalGenerator:
    """
    üß† CERVEAU CENTRAL - G√©n√©rateur de signaux master
    
    Orchestration compl√®te :
    1. Analyse tous les composants (bataille navale, features, confluence, etc.)
    2. D√©termine r√©gime march√© et strat√©gie appropri√©e
    3. Valide qualit√© et coh√©rence des signaux
    4. G√©n√®re 1 signal final unifi√© pour ex√©cution
    
    Performance garantie : <5ms pour analyse compl√®te
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """Initialisation du g√©n√©rateur de signaux"""
        self.config = config or {}
        
        # === COMPOSANTS SYST√àME ===
        self.feature_calculator = FeatureCalculator(config)
        self.confluence_analyzer = ConfluenceAnalyzer(config)
        self.market_regime = MarketRegimeDetector(config)
        self.battle_navale = BattleNavaleAnalyzer(config)
        self.trend_strategy = TrendStrategy(config)
        self.range_strategy = RangeStrategy(config)
        
        # === PARAM√àTRES G√âN√âRATION ===
        self.min_confidence = self.config.get('min_signal_confidence', 0.70)
        self.min_confluence = self.config.get('min_confluence_score', 0.60)
        self.min_risk_reward = self.config.get('min_risk_reward', 1.5)
        self.max_position_size = self.config.get('max_position_size', 3.0)
        
        # === √âTAT SYST√àME ===
        self.last_signal: Optional[FinalSignal] = None
        self.signal_history: deque = deque(maxlen=100)
        self.current_regime: Optional[MarketRegimeData] = None
        
        # === PERFORMANCE TRACKING ===
        self.stats = {
            'signals_generated': 0,
            'signals_executed': 0,
            'avg_generation_time_ms': 0.0,
            'quality_distribution': defaultdict(int),
            'regime_distribution': defaultdict(int),
            'success_by_source': defaultdict(list)
        }
        
        logger.info("SignalGenerator initialis√© - Cerveau central pr√™t")
    
    def generate_signal(self,
                       market_data: MarketData,
                       order_flow: Optional[OrderFlowData] = None,
                       options_data: Optional[Dict[str, Any]] = None,
                       structure_data: Optional[Dict[str, Any]] = None,
                       sierra_patterns: Optional[Dict[str, float]] = None) -> FinalSignal:
        """
        üéØ G√âN√âRATION SIGNAL PRINCIPAL
        
        Workflow complet d'analyse et g√©n√©ration signal final :
        1. Calcul features avec confluence
        2. Analyse bataille navale (votre m√©thode signature)
        3. D√©tection r√©gime march√© (trend vs range)
        4. S√©lection et ex√©cution strat√©gie appropri√©e
        5. Validation confluence et qualit√©
        6. G√©n√©ration signal final unifi√©
        
        Args:
            market_data: Donn√©es OHLC + volume obligatoires
            order_flow: Donn√©es order flow optionnelles
            options_data: Donn√©es options pour gamma (SpotGamma)
            structure_data: Market profile + VWAP levels
            sierra_patterns: Patterns Sierra Chart
            
        Returns:
            FinalSignal : Signal final pr√™t pour ex√©cution
        """
        start_time = time.perf_counter()
        
        try:
            # === √âTAPE 1: ANALYSE COMPOSANTS ===
            components = self._analyze_all_components(
                market_data, order_flow, options_data, structure_data, sierra_patterns
            )
            
            # === √âTAPE 2: VALIDATION COMPOSANTS ===
            if not self._validate_components(components):
                return self._create_wait_signal(
                    market_data, "Composants insuffisants", components
                )
            
            # === √âTAPE 3: D√âTERMINATION STRAT√âGIE ===
            strategy_decision = self._determine_strategy(components)
            
            # === √âTAPE 4: G√âN√âRATION SIGNAL PRIMAIRE ===
            primary_signal = self._generate_primary_signal(
                components, strategy_decision, market_data
            )
            
            # === √âTAPE 5: VALIDATION CONFLUENCE ===
            confluence_validated = self._validate_confluence(
                primary_signal, components.confluence
            )
            
            if not confluence_validated:
                return self._create_wait_signal(
                    market_data, "Confluence insuffisante", components
                )
            
            # === √âTAPE 6: CALCUL QUALIT√â FINALE ===
            final_quality = self._calculate_final_quality(primary_signal, components)
            
            # === √âTAPE 7: SIGNAL FINAL ===
            final_signal = self._create_final_signal(
                primary_signal, components, final_quality, market_data
            )
            
            # === √âTAPE 8: TRACKING PERFORMANCE ===
            execution_time = (time.perf_counter() - start_time) * 1000
            components.analysis_time_ms = execution_time
            final_signal.components = components
            
            self._update_stats(final_signal, execution_time)
            self.last_signal = final_signal
            self.signal_history.append(final_signal)
            
            logger.info(f"Signal g√©n√©r√© en {execution_time:.2f}ms: "
                       f"{final_signal.decision.value} "
                       f"(Confidence: {final_signal.confidence:.3f})")
            
            return final_signal
            
        except Exception as e:
            logger.error(f"Erreur g√©n√©ration signal: {e}")
            return self._create_error_signal(market_data, str(e))
    
    def _analyze_all_components(self,
                               market_data: MarketData,
                               order_flow: Optional[OrderFlowData],
                               options_data: Optional[Dict[str, Any]],
                               structure_data: Optional[Dict[str, Any]],
                               sierra_patterns: Optional[Dict[str, float]]) -> SignalComponents:
        """Analyse compl√®te de tous les composants"""
        
        components = SignalComponents(timestamp=market_data.timestamp)
        
        try:
            # 1. CALCUL FEATURES AVEC CONFLUENCE
            components.features = self.feature_calculator.calculate_all_features(
                market_data=market_data,
                order_flow=order_flow,
                options_data=options_data,
                structure_data=structure_data,
                sierra_patterns=sierra_patterns
            )
            
            # 2. ANALYSE BATAILLE NAVALE (votre m√©thode signature)
            components.battle_navale = self.battle_navale.analyze_battle_navale(market_data, order_flow)
            
            # 3. D√âTECTION R√âGIME MARCH√â
            components.market_regime = self.market_regime.analyze_market_regime(market_data)
            self.current_regime = components.market_regime
            
            # 4. ANALYSE CONFLUENCE 
            # Confluence temporairement simplifi√©e
            if self.confluence_analyzer and hasattr(self.confluence_analyzer, 'analyze_confluence'):
                try:
                    components.confluence = self.confluence_analyzer.analyze_confluence(
                        price=market_data.close,
                        levels=structure_data if structure_data else {}
                    )
                except:
                    # Cr√©er une confluence par d√©faut si erreur
                    from dataclasses import dataclass
                    @dataclass
                    class DefaultConfluence:
                        max_confluence_score: float = 0.5
                        zones: list = None
                    components.confluence = DefaultConfluence()
            else:
                # Confluence par d√©faut si analyzer manquant
                from dataclasses import dataclass
                @dataclass
                class DefaultConfluence:
                    max_confluence_score: float = 0.5
                    zones: list = None
                components.confluence = DefaultConfluence()
            
            # 5. SIGNAUX STRAT√âGIES (selon r√©gime d√©tect√©)
            if components.market_regime:
                regime = components.market_regime.regime
                
                # Signal Trend si r√©gime trend
                if regime in [MarketRegime.TREND_BULLISH, MarketRegime.TREND_BEARISH]:
                    components.trend_signal = self.trend_strategy.analyze_trend_signal(
                        components.features, market_data, components.market_regime
                    )
                
                # Signal Range si r√©gime range  
                elif regime in [MarketRegime.RANGE_TIGHT, MarketRegime.RANGE_WIDE]:
                    components.range_signal = self.range_strategy.analyze_range_signal(
                        components.features, market_data, components.market_regime
                    )
            
            logger.debug(f"Composants analys√©s: "
                        f"Features={'‚úÖ' if components.features else '‚ùå'}, "
                        f"Bataille={'‚úÖ' if components.battle_navale else '‚ùå'}, "
                        f"R√©gime={'‚úÖ' if components.market_regime else '‚ùå'}, "
                        f"Confluence={'‚úÖ' if components.confluence else '‚ùå'}")
            
        except Exception as e:
            logger.error(f"Erreur analyse composants: {e}")
        
        return components
    
    def _validate_components(self, components: SignalComponents) -> bool:
        """Validation des composants essentiels"""
        
        # Composants obligatoires
        required_components = [
            components.features,
            components.market_regime
        ]
        
        if not all(required_components):
            logger.warning("Composants essentiels manquants")
            return False
        
        # Validation qualit√© features
        if components.features.confluence_score < 0.1:  # R√©duit de 0.3 √† 0.1 pour debug
            logger.debug("Score confluence trop faible pour trading")
            return False
        
        # Validation r√©gime clair
        if components.market_regime.regime == MarketRegime.UNKNOWN and False:  # D√©sactiv√© temporairement
            logger.debug("R√©gime march√© unclear")
            return False
        
        return True
    
    def _determine_strategy(self, components: SignalComponents) -> str:
        """D√©termine la strat√©gie √† utiliser selon le r√©gime"""
        
        if not components.market_regime:
            return "wait"
        
        regime = components.market_regime.regime
        confidence = components.market_regime.regime_confidence
        
        # R√©gimes trend -> Trend strategy
        if regime in [MarketRegime.TREND_BULLISH, MarketRegime.TREND_BEARISH]:
            if confidence >= 0.7:
                return "trend_strong"
            else:
                return "trend_weak"
        
        # R√©gimes range -> Range strategy
        elif regime in [MarketRegime.RANGE_TIGHT, MarketRegime.RANGE_WIDE]:
            if confidence >= 0.7:
                return "range_strong"
            else:
                return "range_weak"
        
        # Transition ou unclear -> Wait
        else:
            return "wait"
    
    def _generate_primary_signal(self,
                                components: SignalComponents,
                                strategy_decision: str,
                                market_data: MarketData) -> Optional[Dict[str, Any]]:
        """G√©n√®re le signal primaire selon la strat√©gie choisie"""
        
        if strategy_decision.startswith("trend"):
            return self._generate_trend_signal(components, market_data)
        elif strategy_decision.startswith("range"):
            return self._generate_range_signal(components, market_data)
        else:
            return None
    
    def _generate_trend_signal(self, 
                              components: SignalComponents, 
                              market_data: MarketData) -> Optional[Dict[str, Any]]:
        """G√©n√®re signal trend bas√© sur bataille navale + trend strategy"""
        
        try:
            # Prioriser bataille navale pour direction
            battle_signal = components.battle_navale
            trend_signal = components.trend_signal
            regime = components.market_regime.regime
            
            signal_direction = None
            confidence = 0.0
            
            # D√©tecter direction depuis bataille navale
            if battle_signal:
                if hasattr(battle_signal, 'signal_type'):
                    if battle_signal.signal_type in ['LONG', 'LONG_TREND']:
                        signal_direction = "LONG"
                        confidence += 0.3
                    elif battle_signal.signal_type in ['SHORT', 'SHORT_TREND']:
                        signal_direction = "SHORT" 
                        confidence += 0.3
            
            # Confirmer avec trend strategy
            if trend_signal and signal_direction:
                if (signal_direction == "LONG" and 
                    trend_signal.signal_type in [TrendSignalType.PREMIUM_PULLBACK, TrendSignalType.STRONG_PULLBACK]):
                    confidence += 0.4
                elif (signal_direction == "SHORT" and 
                      trend_signal.signal_type in [TrendSignalType.PREMIUM_PULLBACK, TrendSignalType.STRONG_PULLBACK]):
                    confidence += 0.4
            
            # Confirmer avec r√©gime
            if regime == MarketRegime.TREND_BULLISH and signal_direction == "LONG":
                confidence += 0.2
            elif regime == MarketRegime.TREND_BEARISH and signal_direction == "SHORT":
                confidence += 0.2
            
            if signal_direction and confidence >= self.min_confidence:
                return {
                    'direction': signal_direction,
                    'type': f"{signal_direction}_TREND",
                    'confidence': min(confidence, 1.0),
                    'entry_price': market_data.close,
                    'source': SignalSource.TREND_STRATEGY,
                    'reasoning': f"Bataille navale {signal_direction} + Trend confirm√©"
                }
            
        except Exception as e:
            logger.error(f"Erreur g√©n√©ration signal trend: {e}")
        
        return None
    
    def _generate_range_signal(self, 
                              components: SignalComponents, 
                              market_data: MarketData) -> Optional[Dict[str, Any]]:
        """G√©n√®re signal range bas√© sur confluence + range strategy"""
        
        try:
            range_signal = components.range_signal
            confluence = components.confluence
            
            if not range_signal:
                return None
            
            confidence = 0.5  # Base range confidence
            
            # Boost si confluence forte aux niveaux cl√©s
            if confluence and confluence.max_confluence_score > 0.7:
                confidence += 0.2
            
            # Validation range strategy
            if range_signal.signal_type in [RangeSignalType.STRONG_SUPPORT, RangeSignalType.STRONG_RESISTANCE]:
                confidence += 0.2
            
            if confidence >= self.min_confidence:
                direction = "LONG" if "SUPPORT" in range_signal.signal_type.value.upper() else "SHORT"
                
                return {
                    'direction': direction,
                    'type': f"{direction}_RANGE",
                    'confidence': min(confidence, 1.0),
                    'entry_price': market_data.close,
                    'source': SignalSource.RANGE_STRATEGY,
                    'reasoning': f"Range {direction} + Confluence confirm√©e"
                }
            
        except Exception as e:
            logger.error(f"Erreur g√©n√©ration signal range: {e}")
        
        return None
    
    def _validate_confluence(self, 
                           primary_signal: Optional[Dict[str, Any]], 
                           confluence: Optional[ConfluenceAnalysis]) -> bool:
        """Valide que le signal a une confluence suffisante"""
        
        if not primary_signal:  # confluence rendue optionnelle
            return False
        
        if not confluence:  # Si pas de confluence, on accepte quand m√™me
            return True
        
        # Score confluence minimum requis
        if confluence.max_confluence_score < self.min_confluence:
            logger.debug(f"Confluence insuffisante: {confluence.max_confluence_score:.3f} < {self.min_confluence}")
            return False
        
        return True
    
    def _calculate_final_quality(self, 
                               primary_signal: Dict[str, Any], 
                               components: SignalComponents) -> QualityLevel:
        """Calcule la qualit√© finale du signal"""
        
        base_confidence = primary_signal['confidence']
        
        # Boost confluence
        confluence_boost = 0.0
        if components.confluence:
            confluence_boost = components.confluence.max_confluence_score * 0.15
        
        # Boost bataille navale
        battle_boost = 0.0
        if components.battle_navale and hasattr(components.battle_navale, 'confidence'):
            battle_boost = components.battle_navale.confidence * 0.1
        
        # Score final
        final_score = min(base_confidence + confluence_boost + battle_boost, 1.0)
        
        # Classification qualit√©
        if final_score >= 0.90:
            return QualityLevel.PREMIUM
        elif final_score >= 0.80:
            return QualityLevel.STRONG
        elif final_score >= 0.70:
            return QualityLevel.MODERATE
        elif final_score >= 0.60:
            return QualityLevel.WEAK
        else:
            return QualityLevel.REJECT
    
    def _create_final_signal(self,
                           primary_signal: Dict[str, Any],
                           components: SignalComponents,
                           quality: QualityLevel,
                           market_data: MarketData) -> FinalSignal:
        """Cr√©e le signal final avec tous les param√®tres"""
        
        # D√©terminer signal type
        signal_type_map = {
            'LONG_TREND': SignalType.LONG_TREND,
            'SHORT_TREND': SignalType.SHORT_TREND,
            'LONG_RANGE': SignalType.LONG_RANGE,
            'SHORT_RANGE': SignalType.SHORT_RANGE
        }
        
        signal_type = signal_type_map.get(primary_signal['type'], SignalType.NO_SIGNAL)
        
        # Position sizing selon qualit√©
        position_size_map = {
            QualityLevel.PREMIUM: 3.0,
            QualityLevel.STRONG: 2.0,
            QualityLevel.MODERATE: 1.5,
            QualityLevel.WEAK: 1.0,
            QualityLevel.REJECT: 0.0
        }
        
        position_size = min(position_size_map[quality], self.max_position_size)
        
        # Calcul stops et targets (logique simplifi√©e)
        entry_price = primary_signal['entry_price']
        direction = primary_signal['direction']
        
        if direction == "LONG":
            stop_loss = entry_price - (10 * ES_TICK_SIZE)  # 10 ticks stop
            take_profit = entry_price + (15 * ES_TICK_SIZE)  # 15 ticks target
        else:
            stop_loss = entry_price + (10 * ES_TICK_SIZE)
            take_profit = entry_price - (15 * ES_TICK_SIZE)
        
        risk_reward = abs(take_profit - entry_price) / abs(entry_price - stop_loss)
        
        # D√©cision finale
        if quality == QualityLevel.REJECT or risk_reward < self.min_risk_reward:
            decision = SignalDecision.WAIT_BETTER_SETUP
        else:
            decision = SignalDecision.EXECUTE_LONG if direction == "LONG" else SignalDecision.EXECUTE_SHORT
        
        return FinalSignal(
            timestamp=market_data.timestamp,
            decision=decision,
            signal_type=signal_type,
            entry_price=entry_price,
            stop_loss=stop_loss,
            take_profit=take_profit,
            position_size=position_size,
            risk_reward_ratio=risk_reward,
            confidence=primary_signal['confidence'],
            quality_level=quality,
            confluence_score=components.confluence.max_confluence_score if components.confluence else 0.0,
            primary_source=primary_signal['source'],
            reasoning=primary_signal['reasoning'],
            metadata={
                'regime': components.market_regime.regime.value if components.market_regime else "unknown",
                'strategy_used': primary_signal['source'].value,
                'confluence_zones': len(components.confluence.zones) if components.confluence else 0
            }
        )
    
    def _create_wait_signal(self, 
                           market_data: MarketData, 
                           reason: str, 
                           components: Optional[SignalComponents] = None) -> FinalSignal:
        """Cr√©e un signal d'attente"""
        
        return FinalSignal(
            timestamp=market_data.timestamp,
            decision=SignalDecision.WAIT_BETTER_SETUP,
            signal_type=SignalType.NO_SIGNAL,
            entry_price=market_data.close,
            confidence=0.0,
            quality_level=QualityLevel.REJECT,
            reasoning=reason,
            components=components
        )
    
    def _create_error_signal(self, market_data: MarketData, error: str) -> FinalSignal:
        """Cr√©e un signal d'erreur"""
        
        return FinalSignal(
            timestamp=market_data.timestamp,
            decision=SignalDecision.WAIT_BETTER_SETUP,
            signal_type=SignalType.NO_SIGNAL,
            entry_price=market_data.close,
            confidence=0.0,
            quality_level=QualityLevel.REJECT,
            reasoning=f"Erreur: {error}"
        )
    
    def _update_stats(self, signal: FinalSignal, execution_time: float):
        """Mise √† jour statistiques performance"""
        
        self.stats['signals_generated'] += 1
        
        if signal.decision in [SignalDecision.EXECUTE_LONG, SignalDecision.EXECUTE_SHORT]:
            self.stats['signals_executed'] += 1
        
        # Moyenne mobile temps ex√©cution
        current_avg = self.stats['avg_generation_time_ms']
        count = self.stats['signals_generated']
        self.stats['avg_generation_time_ms'] = (
            (current_avg * (count - 1) + execution_time) / count
        )
        
        # Distribution qualit√©
        self.stats['quality_distribution'][signal.quality_level.value] += 1
        
        # Distribution r√©gime
        if signal.metadata.get('regime'):
            self.stats['regime_distribution'][signal.metadata['regime']] += 1
    
    # === M√âTHODES PUBLIQUES UTILITAIRES ===
    
    def get_last_signal(self) -> Optional[FinalSignal]:
        """Retourne le dernier signal g√©n√©r√©"""
        return self.last_signal
    
    def get_signal_history(self, count: int = 10) -> List[FinalSignal]:
        """Retourne l'historique des signaux"""
        return list(self.signal_history)[-count:]
    
    def get_current_regime(self) -> Optional[MarketRegimeData]:
        """Retourne le r√©gime march√© actuel"""
        return self.current_regime
    
    def get_performance_stats(self) -> Dict[str, Any]:
        """Retourne les statistiques de performance"""
        return {
            'signals_generated': self.stats['signals_generated'],
            'signals_executed': self.stats['signals_executed'],
            'execution_rate': (self.stats['signals_executed'] / max(self.stats['signals_generated'], 1)) * 100,
            'avg_generation_time_ms': round(self.stats['avg_generation_time_ms'], 2),
            'quality_distribution': dict(self.stats['quality_distribution']),
            'regime_distribution': dict(self.stats['regime_distribution']),
            'current_regime': self.current_regime.regime.value if self.current_regime else "unknown"
        }
    
    def reset_stats(self):
        """Remet √† z√©ro les statistiques"""
        self.stats = {
            'signals_generated': 0,
            'signals_executed': 0,
            'avg_generation_time_ms': 0.0,
            'quality_distribution': defaultdict(int),
            'regime_distribution': defaultdict(int),
            'success_by_source': defaultdict(list)
        }
        logger.info("Statistiques r√©initialis√©es")

# === FACTORY FUNCTIONS ===

def create_signal_generator(config: Optional[Dict[str, Any]] = None) -> SignalGenerator:
    """Factory function pour cr√©er un SignalGenerator"""
    return SignalGenerator(config)

def generate_trading_signal(market_data: MarketData,
                           order_flow: Optional[OrderFlowData] = None,
                           options_data: Optional[Dict[str, Any]] = None,
                           structure_data: Optional[Dict[str, Any]] = None,
                           sierra_patterns: Optional[Dict[str, float]] = None,
                           generator: Optional[SignalGenerator] = None) -> FinalSignal:
    """
    üéØ FONCTION PRINCIPALE - Point d'entr√©e unique
    
    G√©n√®re un signal de trading complet en utilisant tous les composants
    du syst√®me (bataille navale, features, confluence, etc.)
    
    Usage:
        signal = generate_trading_signal(market_data, order_flow, options_data)
        if signal.decision == SignalDecision.EXECUTE_LONG:
            execute_trade(signal)
    """
    
    if generator is None:
        generator = create_signal_generator()
    
    return generator.generate_signal(
        market_data=market_data,
        order_flow=order_flow,
        options_data=options_data,
        structure_data=structure_data,
        sierra_patterns=sierra_patterns
    )

# === EXPORTS ===

__all__ = [
    # Classes principales
    'SignalGenerator',
    'FinalSignal',
    'SignalComponents',
    
    # Enums
    'SignalDecision',
    'SignalSource', 
    'QualityLevel',
    
    # Factory functions
    'create_signal_generator',
    'generate_trading_signal'
]

if __name__ == "__main__":
    # Test basique
    import sys
    from pathlib import Path
    
    # Ajouter le dossier parent au path
    sys.path.append(str(Path(__file__).parent.parent))
    
    print("üß† Test SignalGenerator...")
    
    try:
        # Test cr√©ation
        generator = create_signal_generator()
        print("‚úÖ SignalGenerator cr√©√© avec succ√®s")
        
        # Test donn√©es factices
        test_data = MarketData(
            timestamp=pd.Timestamp.now(),
            symbol="ES",
            open=4500.0,
            high=4505.0,
            low=4495.0,
            close=4502.0,
            volume=1000
        )
        
        # Test g√©n√©ration signal
        signal = generator.generate_signal(test_data)
        print(f"‚úÖ Signal g√©n√©r√©: {signal.decision.value}")
        print(f"   ‚îî‚îÄ Confiance: {signal.confidence:.3f}")
        print(f"   ‚îî‚îÄ Qualit√©: {signal.quality_level.value}")
        
        # Test stats
        stats = generator.get_performance_stats()
        print(f"‚úÖ Stats: {stats['signals_generated']} signaux g√©n√©r√©s")
        
    except Exception as e:
        print(f"‚ùå Erreur test: {e}")
    
    print("\nüéØ SignalGenerator pr√™t pour int√©gration compl√®te!")