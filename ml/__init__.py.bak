"""
MIA_IA_SYSTEM - Machine Learning Module
Module ML complet pour trading Battle Navale automatis√©
Version: Complete ML Pipeline v1.0.0
# Configuration encodage UTF-8
import sys
import io
if sys.platform == "win32":
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')



ARCHITECTURE ML COMPL√àTE (4 fichiers) :
‚îú‚îÄ‚îÄ simple_model.py         # Mod√®le ML lin√©aire simple (~400 lignes)
‚îú‚îÄ‚îÄ data_processor.py       # Pr√©paration donn√©es ML (~250 lignes) 
‚îú‚îÄ‚îÄ model_validator.py      # Validation mod√®les robuste (~200 lignes)
‚îî‚îÄ‚îÄ model_trainer.py        # Pipeline training complet (~300 lignes)

FONCTIONNALIT√âS INT√âGR√âES :
- Mod√®les ML simples (Linear/Logistic Regression)
- Pipeline de pr√©paration donn√©es depuis snapshots Battle Navale
- Validation rigoureuse avec cross-validation et tests out-of-sample
- Training automatis√© avec gestion versions et d√©ploiement
- Apprentissage continu et monitoring performance
- Int√©gration native avec syst√®me Battle Navale

USAGE PRINCIPAL :
```python
from ml import ModelTrainer, create_battle_navale_trainer
trainer = create_battle_navale_trainer()
session = trainer.train_model_from_snapshots()
model = trainer.get_model_for_trading()
```
"""

# === SIMPLE MODEL (Mod√®les ML de base) ===
from .simple_model import (
    # Classe principale
    SimpleLinearModel,
    
    # Enums et types
    ModelType,
    ModelStatus,
    ModelPerformance,
    ModelConfig,
    TrainingResult,
    
    # Factory functions
    create_signal_classifier,
    create_profitability_predictor,
    create_signal_strength_model,
    
    # Test function
    test_simple_model
)

# === DATA PROCESSOR (Pr√©paration donn√©es ML) ===
from .data_processor import (
    # Classe principale
    MLDataProcessor,
    
    # Data structures
    ProcessedDataset,
    DataQualityReport,
    FeatureStats,
    ProcessingConfig,
    
    # Enums
    DataQuality,
    FeatureType,
    ScalingMethod,
    SplitMethod,
    
    # Factory functions
    create_ml_data_processor,
    create_battle_navale_processor,
    
    # Test function
    test_ml_data_processor
)

# === MODEL VALIDATOR (Validation robuste mod√®les) ===
from .model_validator import (
    # Classe principale
    ModelValidator,
    
    # Data structures
    ValidationReport,
    CrossValidationResult,
    OutOfSampleResult,
    FeatureImportanceAnalysis,
    OverfittingAnalysis,
    ModelStabilityTest,
    
    # Enums
    ValidationMethod,
    ValidationLevel,
    OverfittingLevel,
    ModelHealth,
    
    # Factory functions
    create_model_validator,
    create_rigorous_validator,
    create_exhaustive_validator,
    
    # Test function
    test_model_validator
)

# === MODEL TRAINER (Pipeline training complet) ===
from .model_trainer import (
    # Classe principale
    ModelTrainer,
    
    # Data structures
    TrainingSession,
    TrainingConfig,
    ModelVersion,
    
    # Enums
    TrainingMode,
    ModelStage,
    TrainingStatus,
    PerformanceThreshold,
    
    # Factory functions
    create_model_trainer,
    create_battle_navale_trainer,
    train_model_from_recent_data,
    
    # Test function
    test_model_trainer
)

# === ALIAS POUR COMPATIBILIT√â ===
# Maintien compatibilit√© avec imports existants
SimpleMLModel = SimpleLinearModel  # Alias principal pour __init__.py original

# Version info
__version__ = "1.0.0"
__author__ = "MIA Trading System - ML Team"

# === EXPORTS COMPLETS ===
__all__ = [
    # === COMPATIBILIT√â ORIGINALE ===
    'SimpleMLModel',        # Alias vers SimpleLinearModel
    'ModelTrainer',         # Classe principale training
    
    # === SIMPLE MODEL ===
    'SimpleLinearModel',
    'ModelType',
    'ModelStatus', 
    'ModelPerformance',
    'ModelConfig',
    'TrainingResult',
    'create_signal_classifier',
    'create_profitability_predictor',
    'create_signal_strength_model',
    'test_simple_model',
    
    # === DATA PROCESSOR ===
    'MLDataProcessor',
    'ProcessedDataset',
    'DataQualityReport',
    'FeatureStats',
    'ProcessingConfig',
    'DataQuality',
    'FeatureType',
    'ScalingMethod',
    'SplitMethod',
    'create_ml_data_processor',
    'create_battle_navale_processor',
    'test_ml_data_processor',
    
    # === MODEL VALIDATOR ===
    'ModelValidator',
    'ValidationReport',
    'CrossValidationResult',
    'OutOfSampleResult',
    'FeatureImportanceAnalysis',
    'OverfittingAnalysis',
    'ModelStabilityTest',
    'ValidationMethod',
    'ValidationLevel',
    'OverfittingLevel',
    'ModelHealth',
    'create_model_validator',
    'create_rigorous_validator',
    'create_exhaustive_validator',
    'test_model_validator',
    
    # === MODEL TRAINER ===
    'TrainingSession',
    'TrainingConfig',
    'ModelVersion',
    'TrainingMode',
    'ModelStage',
    'TrainingStatus',
    'PerformanceThreshold',
    'create_model_trainer',
    'create_battle_navale_trainer',
    'train_model_from_recent_data',
    'test_model_trainer'
]

# === INFORMATIONS MODULE ===
def get_ml_module_info() -> dict:
    """Information compl√®te du module ML"""
    return {
        'version': __version__,
        'components_count': 4,
        'components': [
            'SimpleLinearModel (Mod√®les ML de base)',
            'MLDataProcessor (Pr√©paration donn√©es)', 
            'ModelValidator (Validation robuste)',
            'ModelTrainer (Pipeline training)'
        ],
        'capabilities': {
            'model_types': ['Linear Regression', 'Logistic Regression'],
            'data_processing': 'Battle Navale snapshots ‚Üí ML-ready datasets',
            'validation': 'Cross-validation + Out-of-sample + Feature analysis',
            'training': 'Automated pipeline + Continuous learning',
            'deployment': 'Staging ‚Üí Production avec versioning'
        },
        'integration': {
            'battle_navale': 'Native integration avec votre m√©thode',
            'snapshots': 'Direct depuis trade_snapshotter.py',
            'automation': 'Compatible avec simple_trader.py',
            'features': '8 features Battle Navale + Market structure'
        },
        'production_ready': True,
        'testing': 'Test functions dans chaque composant'
    }

def get_ml_workflow_info() -> dict:
    """Workflow ML complet"""
    return {
        'pipeline_steps': [
            '1. Snapshots collect√©s (trade_snapshotter)',
            '2. Donn√©es pr√©par√©es (MLDataProcessor)', 
            '3. Mod√®le entra√Æn√© (SimpleLinearModel)',
            '4. Validation rigoureuse (ModelValidator)',
            '5. D√©ploiement automatique (ModelTrainer)',
            '6. Monitoring continu (ModelTrainer)'
        ],
        'data_flow': 'Battle Navale ‚Üí Snapshots ‚Üí Features ‚Üí Model ‚Üí Validation ‚Üí Production',
        'automation_level': 'Fully automated avec intervention optionnelle',
        'performance_monitoring': 'Automatic retraining si d√©gradation d√©tect√©e',
        'safety_mechanisms': [
            'Validation rigoureuse avant d√©ploiement',
            'Staging environment pour tests',
            'Backup automatique mod√®les pr√©c√©dents',
            'Performance thresholds configurables'
        ]
    }

def test_ml_module():
    """Test rapide de tous les composants ML"""
    print("=== TEST MODULE ML COMPLET ===")
    
    try:
        # Test 1: SimpleLinearModel
        print("Test 1: SimpleLinearModel")
        model = create_signal_classifier()
        print(f"‚úÖ SimpleLinearModel: {type(model).__name__}")
        
        # Test 2: MLDataProcessor
        print("Test 2: MLDataProcessor")
        processor = create_battle_navale_processor()
        print(f"‚úÖ MLDataProcessor: {type(processor).__name__}")
        
        # Test 3: ModelValidator
        print("Test 3: ModelValidator")
        validator = create_model_validator()
        print(f"‚úÖ ModelValidator: {type(validator).__name__}")
        
        # Test 4: ModelTrainer
        print("Test 4: ModelTrainer")
        trainer = create_battle_navale_trainer()
        print(f"‚úÖ ModelTrainer: {type(trainer).__name__}")
        
        # Test 5: Alias compatibility
        print("Test 5: Compatibilit√© alias")
        simple_ml = SimpleMLModel()
        print(f"‚úÖ SimpleMLModel alias: {type(simple_ml).__name__}")
        
        print("\nüéâ TOUS LES COMPOSANTS ML FONCTIONNELS")
        
        # Informations module
        info = get_ml_module_info()
        print(f"\nModule ML v{info['version']}")
        print(f"Composants: {info['components_count']}")
        print(f"Production ready: {info['production_ready']}")
        
    except Exception as e:
        print(f"‚ùå Erreur test module: {e}")

# === SHORTCUTS POUR USAGE RAPIDE ===

def quick_train_model(days_back: int = 30) -> 'TrainingSession':
    """
    Training rapide d'un mod√®le Battle Navale
    
    Args:
        days_back: Nombre de jours de donn√©es √† utiliser
        
    Returns:
        Session d'entra√Ænement
    """
    return train_model_from_recent_data(days_back)

def get_production_model() -> 'SimpleLinearModel':
    """
    R√©cup√©ration rapide du mod√®le en production
    
    Returns:
        Mod√®le ML pr√™t pour trading
    """
    trainer = create_battle_navale_trainer()
    return trainer.get_model_for_trading()

def setup_automated_ml(check_hours: int = 24) -> bool:
    """
    Setup ML automatis√© complet
    
    Args:
        check_hours: Intervalle v√©rification performance
        
    Returns:
        True si setup r√©ussi
    """
    trainer = create_battle_navale_trainer()
    return trainer.setup_continuous_learning(check_hours)

# Message de bienvenue
if __name__ == "__main__":
    print("ü§ñ MIA Trading ML Module")
    print("Module ML complet pour trading Battle Navale")
    print("Lancez test_ml_module() pour v√©rifier l'installation")