"""
MIA_IA_SYSTEM - Emergency Restore
Restauration d'urgence apres regression critique
Version: Recovery from vectorization damage
"""

import shutil
from pathlib import Path
from typing import List, Tuple

def find_backup_files():
    """Trouve tous les fichiers de backup"""
    print("ðŸ” RECHERCHE FICHIERS BACKUP")
    print("=" * 40)
    
    project_root = Path(".")
    
    # Chercher fichiers backup
    backup_patterns = [
        "*.before_vectorization*",
        "*.original",
        "*.backup"
    ]
    
    found_backups = []
    
    for pattern in backup_patterns:
        backups = list(project_root.rglob(pattern))
        found_backups.extend(backups)
    
    print(f"Fichiers backup trouvÃ©s: {len(found_backups)}")
    for backup in found_backups:
        print(f"  â€¢ {backup}")
    
    return found_backups

def restore_from_backups():
    """Restaure fichiers depuis backups"""
    print("\nðŸ”„ RESTAURATION DEPUIS BACKUPS")
    print("=" * 40)
    
    backups = find_backup_files()
    
    if not backups:
        print("âŒ Aucun backup trouvÃ©!")
        return False
    
    restored_count = 0
    
    for backup_file in backups:
        # DÃ©terminer fichier original
        original_name = str(backup_file)
        
        # Patterns de backup Ã  nettoyer
        patterns_to_remove = [
            '.before_vectorization',
            '.before_vectorization_' + str(int(backup_file.stat().st_mtime)),
            '.original',
            '.backup'
        ]
        
        original_path = None
        for pattern in patterns_to_remove:
            if pattern in original_name:
                original_path = Path(original_name.replace(pattern, ''))
                break
        
        if original_path and original_path.exists():
            try:
                # Backup du fichier cassÃ©
                broken_backup = original_path.with_suffix(f'.py.broken_{int(backup_file.stat().st_mtime)}')
                shutil.copy2(original_path, broken_backup)
                
                # Restaurer depuis backup
                shutil.copy2(backup_file, original_path)
                print(f"âœ… RestaurÃ©: {original_path}")
                print(f"   Backup cassÃ©: {broken_backup}")
                
                restored_count += 1
                
            except Exception as e:
                print(f"âŒ Erreur restauration {original_path}: {e}")
    
    print(f"\nðŸ“Š RESTAURATION: {restored_count} fichiers restaurÃ©s")
    return restored_count > 0

def verify_restoration():
    """VÃ©rifie que la restauration a fonctionnÃ©"""
    print("\nðŸ§ª VÃ‰RIFICATION RESTAURATION")
    print("=" * 40)
    
    # Test imports critiques
    import sys
    project_root = Path(".").absolute()
    if str(project_root) not in sys.path:
        sys.path.insert(0, str(project_root))
    
    critical_imports = [
        "config.trading_config",
        "core.base_types",
        "config",
        "core"
    ]
    
    success_count = 0
    
    for module_name in critical_imports:
        try:
            # Clear cache
            if module_name in sys.modules:
                del sys.modules[module_name]
            
            __import__(module_name)
            print(f"âœ… {module_name}")
            success_count += 1
            
        except Exception as e:
            print(f"âŒ {module_name}: {e}")
    
    # Test fonctionnalitÃ©
    try:
        from config import get_trading_config
        from core import MarketData, ES_TICK_SIZE
        
        config = get_trading_config()
        print(f"âœ… Config test: {config.trading_mode.value}")
        print(f"âœ… Core test: ES_TICK_SIZE = {ES_TICK_SIZE}")
        
        functionality_ok = True
        
    except Exception as e:
        print(f"âŒ Functionality test: {e}")
        functionality_ok = False
    
    # RÃ©sumÃ©
    print(f"\nðŸ“Š VÃ‰RIFICATION:")
    print(f"   â€¢ Imports: {success_count}/{len(critical_imports)}")
    print(f"   â€¢ FonctionnalitÃ©: {'OK' if functionality_ok else 'ERROR'}")
    
    overall_ok = success_count == len(critical_imports) and functionality_ok
    
    if overall_ok:
        print("âœ… RESTAURATION RÃ‰USSIE!")
        return True
    else:
        print("âŒ RESTAURATION INCOMPLÃˆTE")
        return False

def clean_optimization_artifacts():
    """Nettoie les artefacts d'optimisation"""
    print("\nðŸ§¹ NETTOYAGE ARTEFACTS OPTIMISATION")
    print("=" * 40)
    
    # Fichiers crÃ©Ã©s par les optimisations
    artifact_patterns = [
        "*vectorization_optimizer*",
        "*precise_vectorization*",
        "*performance_patch*",
        "*.broken_*"
    ]
    
    project_root = Path(".")
    cleaned_count = 0
    
    for pattern in artifact_patterns:
        artifacts = list(project_root.rglob(pattern))
        
        for artifact in artifacts:
            if artifact.exists() and artifact.is_file():
                try:
                    artifact.unlink()
                    print(f"ðŸ—‘ï¸ SupprimÃ©: {artifact}")
                    cleaned_count += 1
                except Exception as e:
                    print(f"âš ï¸ Erreur suppression {artifact}: {e}")
    
    print(f"ðŸ“Š NETTOYAGE: {cleaned_count} artefacts supprimÃ©s")
    return cleaned_count

def emergency_restore_procedure():
    """ProcÃ©dure complÃ¨te de restauration d'urgence"""
    print("ðŸš¨ PROCÃ‰DURE RESTAURATION D'URGENCE")
    print("=" * 50)
    print("OBJECTIF: Revenir Ã  l'Ã©tat stable 87.5%")
    
    # 1. Restaurer depuis backups
    if not restore_from_backups():
        print("âŒ Restauration backup Ã©chouÃ©e")
        return False
    
    # 2. VÃ©rifier restauration
    if not verify_restoration():
        print("âŒ VÃ©rification Ã©chouÃ©e")
        return False
    
    # 3. Nettoyer artefacts
    clean_optimization_artifacts()
    
    # 4. Instructions finales
    print("\nðŸŽ¯ RESTAURATION COMPLÃˆTE")
    print("=" * 30)
    print("ACTIONS EFFECTUÃ‰ES:")
    print("  âœ… Fichiers restaurÃ©s depuis backup")
    print("  âœ… Imports vÃ©rifiÃ©s")
    print("  âœ… FonctionnalitÃ© testÃ©e")
    print("  âœ… Artefacts nettoyÃ©s")
    
    print("\nPROCHAINES Ã‰TAPES:")
    print("  1. python technical_audit.py")
    print("  2. VÃ©rifier retour Ã  87.5%")
    print("  3. NE PAS re-optimiser sans backup complet")
    
    return True

def create_analysis_report():
    """CrÃ©e rapport d'analyse de la rÃ©gression"""
    print("\nðŸ“‹ RAPPORT ANALYSE RÃ‰GRESSION")
    print("=" * 40)
    
    report = """
ðŸš¨ RÃ‰GRESSION ANALYSIS REPORT

PROBLÃˆME:
  â€¢ Score: 87.5% â†’ 37.5% (-50 points)
  â€¢ Imports: 17/17 â†’ 9/17 (8 cassÃ©s)
  â€¢ Syntax: OK â†’ ERROR

CAUSE PROBABLE:
  â€¢ Optimisation vectorisation trop agressive
  â€¢ Modification fonctions sans tests appropriÃ©s
  â€¢ Patterns regex incorrects
  â€¢ Imports NumPy mal injectÃ©s

LEÃ‡ONS APPRISES:
  1. TOUJOURS tester aprÃ¨s chaque changement
  2. Optimisations par petits incrÃ©ments
  3. Backup complet avant modifications
  4. Validation imports aprÃ¨s changements

RECOMMANDATIONS FUTURES:
  â€¢ Score 87.5% est dÃ©jÃ  EXCELLENT
  â€¢ Optimisations = bonus, pas critique
  â€¢ PrioritÃ©: StabilitÃ© > Performance
  â€¢ Phase 3 possible avec 87.5%
"""
    
    report_file = Path("regression_analysis_report.txt")
    report_file.write_text(report, encoding='utf-8')
    
    print(f"ðŸ“„ Rapport sauvÃ©: {report_file}")
    print(report)

def main():
    """Restauration d'urgence principale"""
    print("ðŸš¨ EMERGENCY RESTORE - MIA_IA_SYSTEM")
    print("=" * 60)
    
    # Restauration d'urgence
    if emergency_restore_procedure():
        create_analysis_report()
        
        print("\nâœ… RESTAURATION D'URGENCE RÃ‰USSIE!")
        print("ðŸŽ¯ SystÃ¨me devrait Ãªtre de retour Ã  87.5%")
        
        return True
    else:
        print("\nðŸ’€ RESTAURATION D'URGENCE Ã‰CHOUÃ‰E")
        print("ðŸ”§ Intervention manuelle requise")
        
        return False

if __name__ == "__main__":
    success = main()
    
    if success:
        print("\nðŸš€ LANCER MAINTENANT:")
        print("python technical_audit.py")
        print("\nðŸŽ¯ ATTENDU: Retour Ã  87.5% score")
    else:
        print("\nðŸ’€ SYSTÃˆME EN PANNE - Debug manuel requis")