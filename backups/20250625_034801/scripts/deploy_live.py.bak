#!/usr/bin/env python3
"""
🚀 MIA_IA_SYSTEM - DEPLOY LIVE SCRIPT
🎯 Déploiement Live Trading Production-Ready
Version: Production Ready v3.0
Performance: Déploiement sécurisé, monitoring intégré, rollback automatique

RESPONSABILITÉS CRITIQUES :
1. 🔍 PRE-DEPLOYMENT CHECKS - Validation complète système
2. 🏥 HEALTH VERIFICATION - Integration Health Checker complet
3. ⚙️ ENVIRONMENT SETUP - Configuration production optimisée
4. 🔐 SECURITY VALIDATION - Vérifications sécurité multi-niveaux
5. 📊 STAGED DEPLOYMENT - Déploiement progressif par étapes
6. 📈 REAL-TIME MONITORING - Surveillance continue déploiement
7. 🔄 ROLLBACK AUTOMATION - Retour arrière automatique si problème
8. 📋 DEPLOYMENT REPORTING - Rapports détaillés et alertes

WORKFLOW DÉPLOIEMENT :
Pre-Checks → Environment Setup → Components Start → Health Verification → 
Go-Live Decision → Monitoring → Success/Rollback

MODES DÉPLOIEMENT :
- VALIDATION : Vérification système sans démarrage
- PAPER_TO_LIVE : Transition paper trading → live
- COLD_START : Démarrage à froid système complet
- HOT_UPGRADE : Upgrade système en cours de fonctionnement
- EMERGENCY_STOP : Arrêt d'urgence système live

INTÉGRATION SYSTÈME :
- Health Checker : Orchestrateur surveillance
- Performance Tracker : Métriques temps réel
- Discord Notifier : Alertes déploiement
- Simple Trader : Core automation
- Battle Navale : Méthode signature
"""

import sys
import os
import time
import json
import logging
import argparse
import subprocess
import threading
import signal
import shutil
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple, Union
from dataclasses import dataclass, field, asdict
from enum import Enum
from datetime import datetime, timedelta, timezone
from collections import defaultdict, deque
import psutil
import requests

# === THIRD-PARTY ===
import pandas as pd
import numpy as np

# === MIA_IA_SYSTEM IMPORTS ===
try:
    # Configuration système
    from config import get_trading_config, get_automation_config
    
    # Core components
    from core import (
        MarketData, TradingSignal, SignalType,
        ES_TICK_SIZE, ES_TICK_VALUE
    )
    
    # Monitoring & Health Checker (critiques pour déploiement)
    from monitoring import (
        start_production_monitoring, create_health_checker,
        emergency_health_check, get_health_status
    )
    
    # Strategies (cerveau central)
    from strategies import get_signal_now, create_signal_generator
    
    SYSTEM_INTEGRATION = True
    
except ImportError as e:
    SYSTEM_INTEGRATION = False
    print(f"⚠️ Intégration MIA_IA_SYSTEM limitée: {e}")
    print("🔄 Mode déploiement standalone activé")

# Logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('logs/deploy_live.log')
    ]
)
logger = logging.getLogger(__name__)

# === DEPLOYMENT ENUMS ===

class DeploymentMode(Enum):
    """Modes de déploiement"""
    VALIDATION = "validation"         # Validation seulement, pas de démarrage
    PAPER_TO_LIVE = "paper_to_live"   # Transition paper → live
    COLD_START = "cold_start"         # Démarrage à froid complet
    HOT_UPGRADE = "hot_upgrade"       # Upgrade système running
    EMERGENCY_STOP = "emergency_stop"  # Arrêt d'urgence

class DeploymentStage(Enum):
    """Étapes de déploiement"""
    INIT = "init"
    PRE_CHECKS = "pre_checks"
    ENVIRONMENT_SETUP = "environment_setup"
    COMPONENTS_START = "components_start"
    HEALTH_VERIFICATION = "health_verification"
    GO_LIVE = "go_live"
    MONITORING = "monitoring"
    COMPLETED = "completed"
    FAILED = "failed"
    ROLLED_BACK = "rolled_back"

class DeploymentStatus(Enum):
    """Status déploiement"""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    SUCCESS = "success"
    WARNING = "warning"
    FAILED = "failed"
    ROLLED_BACK = "rolled_back"

class CheckSeverity(Enum):
    """Sévérité des checks"""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"

# === STRUCTURES DE DONNÉES ===

@dataclass
class DeploymentCheck:
    """Résultat d'un check de déploiement"""
    check_name: str
    status: DeploymentStatus
    severity: CheckSeverity
    message: str
    details: Dict[str, Any] = field(default_factory=dict)
    execution_time_ms: float = 0.0
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))

@dataclass
class DeploymentConfig:
    """Configuration déploiement"""
    mode: DeploymentMode
    target_environment: str = "production"
    
    # Safety settings
    enable_rollback: bool = True
    max_deployment_time_minutes: int = 30
    health_check_interval_seconds: int = 30
    failure_threshold: int = 3
    
    # Capital & Risk
    max_position_size: int = 1
    daily_loss_limit: float = 500.0
    max_drawdown_percent: float = 5.0
    
    # Trading settings
    enable_live_execution: bool = False
    paper_trading_first: bool = True
    validation_trades_count: int = 10
    
    # Notifications
    discord_notifications: bool = True
    email_notifications: bool = False
    
    # Advanced
    backup_before_deployment: bool = True
    enable_circuit_breakers: bool = True
    require_manual_approval: bool = True

@dataclass
class DeploymentReport:
    """Rapport de déploiement complet"""
    deployment_id: str
    start_time: datetime
    end_time: Optional[datetime] = None
    
    # Configuration
    config: DeploymentConfig = None
    target_environment: str = "production"
    
    # Status
    current_stage: DeploymentStage = DeploymentStage.INIT
    overall_status: DeploymentStatus = DeploymentStatus.PENDING
    
    # Checks
    pre_checks: List[DeploymentCheck] = field(default_factory=list)
    health_checks: List[DeploymentCheck] = field(default_factory=list)
    post_checks: List[DeploymentCheck] = field(default_factory=list)
    
    # Métriques
    total_execution_time_seconds: float = 0.0
    components_deployed: List[str] = field(default_factory=list)
    components_failed: List[str] = field(default_factory=list)
    
    # Rollback
    rollback_triggered: bool = False
    rollback_reason: str = ""
    rollback_successful: bool = False
    
    # Monitoring post-deployment
    health_score_pre_deployment: float = 0.0
    health_score_post_deployment: float = 0.0
    trading_started: bool = False
    first_trade_timestamp: Optional[datetime] = None

# === CLASSE PRINCIPALE DEPLOYER ===

class LiveDeployer:
    """
    🚀 LIVE DEPLOYER MIA_IA_SYSTEM
    
    Gestionnaire de déploiement live trading production avec sécurité maximale.
    Intégration complète Health Checker et monitoring pour déploiement sûr.
    """
    
    def __init__(self, config: DeploymentConfig):
        """Initialisation deployer"""
        self.config = config
        self.deployment_id = f"deploy_{int(time.time())}"
        self.start_time = datetime.now(timezone.utc)
        
        # État déploiement
        self.current_stage = DeploymentStage.INIT
        self.deployment_status = DeploymentStatus.PENDING
        self.is_running = False
        self.rollback_triggered = False
        
        # Composants système
        self.health_checker = None
        self.signal_generator = None
        self.simple_trader = None
        self.monitoring_system = None
        
        # Monitoring déploiement
        self.deployment_thread: Optional[threading.Thread] = None
        self.monitoring_thread: Optional[threading.Thread] = None
        self.deployed_components: List[str] = []
        self.failed_components: List[str] = []
        
        # Checks et rapport
        self.pre_checks: List[DeploymentCheck] = []
        self.health_checks: List[DeploymentCheck] = []
        self.post_checks: List[DeploymentCheck] = []
        
        # Backup state
        self.backup_path: Optional[Path] = None
        self.pre_deployment_state: Dict[str, Any] = {}
        
        logger.info(f"🚀 LiveDeployer initialisé - ID: {self.deployment_id}")
        logger.info(f"Mode: {config.mode.value}, Environment: {config.target_environment}")
    
    # === POINT D'ENTRÉE PRINCIPAL ===
    
    def deploy(self) -> DeploymentReport:
        """
        DÉPLOIEMENT PRINCIPAL
        
        Orchestration complète du déploiement avec toutes les sécurités
        """
        try:
            logger.info("🚀 DÉMARRAGE DÉPLOIEMENT LIVE MIA_IA_SYSTEM")
            logger.info("=" * 60)
            
            self.is_running = True
            self._update_stage(DeploymentStage.PRE_CHECKS)
            
            # === 1. PRE-DEPLOYMENT CHECKS ===
            if not self._run_pre_deployment_checks():
                return self._handle_deployment_failure("Pre-deployment checks failed")
            
            # === 2. ENVIRONMENT SETUP ===
            self._update_stage(DeploymentStage.ENVIRONMENT_SETUP)
            if not self._setup_deployment_environment():
                return self._handle_deployment_failure("Environment setup failed")
            
            # === 3. BACKUP (si activé) ===
            if self.config.backup_before_deployment:
                if not self._create_deployment_backup():
                    return self._handle_deployment_failure("Backup creation failed")
            
            # === 4. COMPONENTS DEPLOYMENT ===
            self._update_stage(DeploymentStage.COMPONENTS_START)
            if not self._deploy_system_components():
                return self._handle_deployment_failure("Components deployment failed")
            
            # === 5. HEALTH VERIFICATION ===
            self._update_stage(DeploymentStage.HEALTH_VERIFICATION)
            if not self._verify_system_health():
                return self._handle_deployment_failure("Health verification failed")
            
            # === 6. GO-LIVE DECISION ===
            self._update_stage(DeploymentStage.GO_LIVE)
            if not self._make_go_live_decision():
                return self._handle_deployment_failure("Go-live decision negative")
            
            # === 7. START MONITORING ===
            self._update_stage(DeploymentStage.MONITORING)
            self._start_deployment_monitoring()
            
            # === 8. SUCCESS ===
            self._update_stage(DeploymentStage.COMPLETED)
            self.deployment_status = DeploymentStatus.SUCCESS
            
            logger.info("✅ DÉPLOIEMENT LIVE RÉUSSI!")
            return self._generate_deployment_report()
            
        except Exception as e:
            logger.error(f"❌ Erreur critique déploiement: {e}")
            return self._handle_deployment_failure(f"Critical error: {e}")
        
        finally:
            self.is_running = False
    
    # === PRE-DEPLOYMENT CHECKS ===
    
    def _run_pre_deployment_checks(self) -> bool:
        """Exécute tous les checks pré-déploiement"""
        logger.info("🔍 Exécution pre-deployment checks...")
        
        checks = [
            ("system_requirements", self._check_system_requirements),
            ("python_environment", self._check_python_environment),
            ("dependencies", self._check_dependencies),
            ("configuration_files", self._check_configuration_files),
            ("data_directories", self._check_data_directories),
            ("network_connectivity", self._check_network_connectivity),
            ("broker_connectivity", self._check_broker_connectivity),
            ("disk_space", self._check_disk_space),
            ("security_settings", self._check_security_settings),
            ("existing_processes", self._check_existing_processes)
        ]
        
        all_passed = True
        
        for check_name, check_func in checks:
            check_result = self._execute_check(check_name, check_func)
            self.pre_checks.append(check_result)
            
            if check_result.status == DeploymentStatus.FAILED:
                if check_result.severity in [CheckSeverity.ERROR, CheckSeverity.CRITICAL]:
                    all_passed = False
                    logger.error(f"❌ Critical check failed: {check_name}")
                else:
                    logger.warning(f"⚠️ Check warning: {check_name}")
        
        # Résumé
        passed_count = len([c for c in self.pre_checks if c.status == DeploymentStatus.SUCCESS])
        total_count = len(self.pre_checks)
        
        logger.info(f"📊 Pre-deployment checks: {passed_count}/{total_count} passed")
        
        if all_passed:
            logger.info("✅ Tous les checks critiques passed")
        else:
            logger.error("❌ Échec des checks critiques")
        
        return all_passed
    
    def _execute_check(self, check_name: str, check_func: callable) -> DeploymentCheck:
        """Exécute un check individuel avec timing"""
        start_time = time.perf_counter()
        
        try:
            result = check_func()
            execution_time = (time.perf_counter() - start_time) * 1000
            
            if isinstance(result, tuple):
                status, severity, message, details = result
            else:
                # Assume boolean result
                status = DeploymentStatus.SUCCESS if result else DeploymentStatus.FAILED
                severity = CheckSeverity.CRITICAL if not result else CheckSeverity.INFO
                message = f"Check {check_name}: {'passed' if result else 'failed'}"
                details = {}
            
            return DeploymentCheck(
                check_name=check_name,
                status=status,
                severity=severity,
                message=message,
                details=details,
                execution_time_ms=execution_time
            )
            
        except Exception as e:
            execution_time = (time.perf_counter() - start_time) * 1000
            
            return DeploymentCheck(
                check_name=check_name,
                status=DeploymentStatus.FAILED,
                severity=CheckSeverity.CRITICAL,
                message=f"Check {check_name} error: {e}",
                details={"exception": str(e)},
                execution_time_ms=execution_time
            )
    
    def _check_system_requirements(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """Vérifie requirements système"""
        details = {}
        
        # Python version
        python_version = sys.version_info
        details['python_version'] = f"{python_version.major}.{python_version.minor}.{python_version.micro}"
        
        if python_version < (3, 8):
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   f"Python {details['python_version']} < 3.8 required", details)
        
        # System resources
        cpu_count = psutil.cpu_count()
        memory = psutil.virtual_memory()
        disk = psutil.disk_usage('/')
        
        details.update({
            'cpu_count': cpu_count,
            'memory_total_gb': round(memory.total / (1024**3), 2),
            'memory_available_gb': round(memory.available / (1024**3), 2),
            'disk_total_gb': round(disk.total / (1024**3), 2),
            'disk_free_gb': round(disk.free / (1024**3), 2)
        })
        
        # Minimum requirements check
        warnings = []
        if cpu_count < 2:
            warnings.append("CPU count < 2")
        if memory.available < 2 * (1024**3):  # 2GB
            warnings.append("Available memory < 2GB")
        if disk.free < 10 * (1024**3):  # 10GB
            warnings.append("Free disk space < 10GB")
        
        if warnings:
            severity = CheckSeverity.WARNING
            message = f"System requirements met with warnings: {', '.join(warnings)}"
        else:
            severity = CheckSeverity.INFO
            message = "System requirements fully satisfied"
        
        return (DeploymentStatus.SUCCESS, severity, message, details)
    
    def _check_python_environment(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """Vérifie environnement Python"""
        details = {}
        
        # Virtual environment check
        in_venv = hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix)
        details['virtual_environment'] = in_venv
        details['python_executable'] = sys.executable
        details['python_path'] = sys.path[:3]  # First 3 entries
        
        # Check if we're in project directory
        project_indicators = ['core', 'strategies', 'config', 'monitoring']
        current_dir = Path.cwd()
        has_project_structure = all((current_dir / indicator).exists() for indicator in project_indicators)
        details['project_structure_detected'] = has_project_structure
        details['current_directory'] = str(current_dir)
        
        warnings = []
        if not in_venv:
            warnings.append("Not in virtual environment")
        if not has_project_structure:
            warnings.append("Project structure not detected")
        
        if not has_project_structure:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   "Project structure not found", details)
        
        message = "Python environment OK"
        if warnings:
            message += f" (warnings: {', '.join(warnings)})"
        
        severity = CheckSeverity.WARNING if warnings else CheckSeverity.INFO
        return (DeploymentStatus.SUCCESS, severity, message, details)
    
    def _check_dependencies(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """Vérifie dépendances Python"""
        details = {}
        
        required_packages = [
            'pandas', 'numpy', 'psutil', 'flask',
            'plotly', 'requests', 'tqdm'
        ]
        
        available_packages = []
        missing_packages = []
        
        for package in required_packages:
            try:
                __import__(package)
                available_packages.append(package)
            except ImportError:
                missing_packages.append(package)
        
        details['available_packages'] = available_packages
        details['missing_packages'] = missing_packages
        details['total_required'] = len(required_packages)
        details['available_count'] = len(available_packages)
        
        if missing_packages:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   f"Missing packages: {', '.join(missing_packages)}", details)
        
        # Check MIA_IA_SYSTEM integration
        details['system_integration'] = SYSTEM_INTEGRATION
        
        if not SYSTEM_INTEGRATION:
            return (DeploymentStatus.SUCCESS, CheckSeverity.WARNING,
                   "Dependencies OK but MIA_IA_SYSTEM integration limited", details)
        
        return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
               "All dependencies available", details)
    
    def _check_configuration_files(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """Vérifie fichiers de configuration"""
        details = {}
        
        required_configs = [
            'config/trading_config.py',
            'config/__init__.py'
        ]
        
        optional_configs = [
            'config/automation_config.py',
            'config/sierra_config.py',
            '.env.live',
            '.env.production'
        ]
        
        available_required = []
        missing_required = []
        available_optional = []
        missing_optional = []
        
        for config_file in required_configs:
            if Path(config_file).exists():
                available_required.append(config_file)
            else:
                missing_required.append(config_file)
        
        for config_file in optional_configs:
            if Path(config_file).exists():
                available_optional.append(config_file)
            else:
                missing_optional.append(config_file)
        
        details.update({
            'required_available': available_required,
            'required_missing': missing_required,
            'optional_available': available_optional,
            'optional_missing': missing_optional
        })
        
        if missing_required:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   f"Missing required configs: {', '.join(missing_required)}", details)
        
        # Test configuration loading
        try:
            if SYSTEM_INTEGRATION:
                config = get_trading_config()
                details['config_loading'] = 'success'
                details['config_mode'] = getattr(config, 'trading_mode', 'unknown')
            else:
                details['config_loading'] = 'limited_integration'
        except Exception as e:
            return (DeploymentStatus.FAILED, CheckSeverity.ERROR,
                   f"Configuration loading failed: {e}", details)
        
        warnings = []
        if missing_optional:
            warnings.append(f"Missing optional configs: {', '.join(missing_optional[:3])}")
        
        message = "Configuration files OK"
        if warnings:
            message += f" ({', '.join(warnings)})"
        
        severity = CheckSeverity.WARNING if warnings else CheckSeverity.INFO
        return (DeploymentStatus.SUCCESS, severity, message, details)
    
    def _check_data_directories(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """Vérifie structure des répertoires données"""
        details = {}
        
        required_dirs = [
            'data',
            'logs',
            'config'
        ]
        
        recommended_dirs = [
            'data/snapshots',
            'data/live',
            'data/historical',
            'logs/live_trading',
            'logs/system',
            'reports'
        ]
        
        existing_required = []
        missing_required = []
        existing_recommended = []
        missing_recommended = []
        
        for dir_path in required_dirs:
            path = Path(dir_path)
            if path.exists() and path.is_dir():
                existing_required.append(dir_path)
            else:
                missing_required.append(dir_path)
        
        for dir_path in recommended_dirs:
            path = Path(dir_path)
            if path.exists() and path.is_dir():
                existing_recommended.append(dir_path)
            else:
                missing_recommended.append(dir_path)
        
        details.update({
            'required_existing': existing_required,
            'required_missing': missing_required,
            'recommended_existing': existing_recommended,
            'recommended_missing': missing_recommended
        })
        
        # Create missing required directories
        created_dirs = []
        for dir_path in missing_required:
            try:
                Path(dir_path).mkdir(parents=True, exist_ok=True)
                created_dirs.append(dir_path)
                existing_required.append(dir_path)
                missing_required.remove(dir_path)
            except Exception as e:
                details['creation_error'] = str(e)
        
        if created_dirs:
            details['created_directories'] = created_dirs
        
        if missing_required:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   f"Cannot create required directories: {', '.join(missing_required)}", details)
        
        # Check disk permissions
        try:
            test_file = Path('logs/deploy_test.tmp')
            test_file.write_text('test')
            test_file.unlink()
            details['write_permissions'] = True
        except Exception as e:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   f"No write permissions: {e}", details)
        
        warnings = []
        if missing_recommended:
            warnings.append(f"Missing recommended dirs: {len(missing_recommended)}")
        
        message = "Data directories OK"
        if created_dirs:
            message += f" (created: {len(created_dirs)})"
        if warnings:
            message += f" (warnings: {', '.join(warnings)})"
        
        severity = CheckSeverity.WARNING if warnings else CheckSeverity.INFO
        return (DeploymentStatus.SUCCESS, severity, message, details)
    
    def _check_network_connectivity(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """Vérifie connectivité réseau"""
        details = {}
        
        # Test basic internet connectivity
        test_urls = [
            ('google.com', 80),
            ('discord.com', 443),
            ('github.com', 443)
        ]
        
        connectivity_results = {}
        successful_connections = 0
        
        for host, port in test_urls:
            try:
                import socket
                sock = socket.create_connection((host, port), timeout=5)
                sock.close()
                connectivity_results[f"{host}:{port}"] = True
                successful_connections += 1
            except Exception as e:
                connectivity_results[f"{host}:{port}"] = False
                details[f"{host}_error"] = str(e)
        
        details['connectivity_tests'] = connectivity_results
        details['successful_connections'] = successful_connections
        details['total_tests'] = len(test_urls)
        
        if successful_connections == 0:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   "No internet connectivity", details)
        elif successful_connections < len(test_urls):
            return (DeploymentStatus.SUCCESS, CheckSeverity.WARNING,
                   f"Partial connectivity: {successful_connections}/{len(test_urls)}", details)
        else:
            return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
                   "Full internet connectivity", details)
    
    def _check_broker_connectivity(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """Vérifie connectivité broker (simulé)"""
        details = {}
        
        # Note: En production, ici on testerait vraiment IBKR/Sierra Chart
        # Pour l'instant, simulation
        
        if self.config.mode == DeploymentMode.VALIDATION:
            details['broker_check'] = 'skipped_validation_mode'
            return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
                   "Broker connectivity skipped (validation mode)", details)
        
        # Simulation test IBKR
        try:
            # Simulation: vérifier si IBKR gateway possible
            details['ibkr_gateway_port'] = 7497  # TWS port
            details['ibkr_test'] = 'simulated'
            
            # En production : test connexion réelle
            # if SYSTEM_INTEGRATION:
            #     from core.ibkr_connector import IBKRConnector
            #     connector = IBKRConnector()
            #     connection_result = connector.test_connection()
            
            return (DeploymentStatus.SUCCESS, CheckSeverity.WARNING,
                   "Broker connectivity simulated (not tested)", details)
            
        except Exception as e:
            details['broker_error'] = str(e)
            return (DeploymentStatus.FAILED, CheckSeverity.ERROR,
                   f"Broker connectivity test failed: {e}", details)
    
    def _check_disk_space(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """Vérifie espace disque disponible"""
        details = {}
        
        # Check current directory disk usage
        disk_usage = psutil.disk_usage('.')
        
        total_gb = disk_usage.total / (1024**3)
        free_gb = disk_usage.free / (1024**3)
        used_gb = disk_usage.used / (1024**3)
        usage_percent = (used_gb / total_gb) * 100
        
        details.update({
            'total_gb': round(total_gb, 2),
            'free_gb': round(free_gb, 2),
            'used_gb': round(used_gb, 2),
            'usage_percent': round(usage_percent, 2)
        })
        
        # Minimum requirements
        min_free_gb = 5.0  # 5GB minimum
        warning_threshold = 85  # 85% usage warning
        critical_threshold = 95  # 95% usage critical
        
        if free_gb < min_free_gb:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   f"Insufficient disk space: {free_gb:.1f}GB < {min_free_gb}GB required", details)
        
        if usage_percent >= critical_threshold:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   f"Disk usage critical: {usage_percent:.1f}% >= {critical_threshold}%", details)
        
        if usage_percent >= warning_threshold:
            return (DeploymentStatus.SUCCESS, CheckSeverity.WARNING,
                   f"Disk usage high: {usage_percent:.1f}%", details)
        
        return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
               f"Disk space OK: {free_gb:.1f}GB free ({usage_percent:.1f}% used)", details)
    
    def _check_security_settings(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """Vérifie paramètres de sécurité"""
        details = {}
        
        # Check environment variables for sensitive data
        sensitive_vars = ['IBKR_USERNAME', 'IBKR_PASSWORD', 'DISCORD_TOKEN', 'EMAIL_PASSWORD']
        env_vars_present = {}
        
        for var in sensitive_vars:
            env_vars_present[var] = var in os.environ
        
        details['environment_variables'] = env_vars_present
        
        # Check .env files
        env_files = ['.env', '.env.live', '.env.production']
        env_files_present = {}
        
        for env_file in env_files:
            env_files_present[env_file] = Path(env_file).exists()
        
        details['env_files'] = env_files_present
        
        # Security recommendations
        warnings = []
        
        # Check if running as root (dangerous)
        if os.getuid() == 0:  # Unix only
            warnings.append("Running as root user")
        
        # Check file permissions on sensitive files
        sensitive_files = ['config/trading_config.py', '.env.live']
        for file_path in sensitive_files:
            path = Path(file_path)
            if path.exists():
                # Unix permissions check
                try:
                    stat = path.stat()
                    permissions = oct(stat.st_mode)[-3:]
                    if permissions != '600':  # Should be readable only by owner
                        warnings.append(f"{file_path} permissions not secure: {permissions}")
                except:
                    pass
        
        # Risk parameters validation for live trading
        if self.config.mode != DeploymentMode.VALIDATION:
            if self.config.daily_loss_limit > 1000:
                warnings.append(f"Daily loss limit high: ${self.config.daily_loss_limit}")
            
            if self.config.max_position_size > 2:
                warnings.append(f"Max position size high: {self.config.max_position_size}")
        
        details['security_warnings'] = warnings
        
        message = "Security settings checked"
        if warnings:
            message += f" ({len(warnings)} warnings)"
        
        severity = CheckSeverity.WARNING if warnings else CheckSeverity.INFO
        return (DeploymentStatus.SUCCESS, severity, message, details)
    
    def _check_existing_processes(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """Vérifie processus existants"""
        details = {}
        
        # Look for existing MIA_IA_SYSTEM processes
        current_pid = os.getpid()
        python_processes = []
        
        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                if proc.info['name'] and 'python' in proc.info['name'].lower():
                    if proc.info['cmdline']:
                        cmdline = ' '.join(proc.info['cmdline'])
                        if any(keyword in cmdline.lower() for keyword in ['automation_main', 'deploy_live', 'mia_ia']):
                            if proc.info['pid'] != current_pid:
                                python_processes.append({
                                    'pid': proc.info['pid'],
                                    'cmdline': cmdline[:100]  # Truncate
                                })
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                pass
        
        details['existing_processes'] = python_processes
        details['current_pid'] = current_pid
        
        if python_processes:
            if self.config.mode == DeploymentMode.HOT_UPGRADE:
                return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
                       f"Found {len(python_processes)} existing processes (hot upgrade mode)", details)
            else:
                return (DeploymentStatus.SUCCESS, CheckSeverity.WARNING,
                       f"Found {len(python_processes)} existing processes", details)
        
        return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
               "No conflicting processes found", details)
    
    # === ENVIRONMENT SETUP ===
    
    def _setup_deployment_environment(self) -> bool:
        """Configure l'environnement pour le déploiement"""
        logger.info("⚙️ Configuration environnement déploiement...")
        
        try:
            # 1. Set environment variables
            os.environ['MIA_TRADING_ENV'] = self.config.target_environment
            os.environ['MIA_DEPLOYMENT_ID'] = self.deployment_id
            os.environ['MIA_DEPLOYMENT_MODE'] = self.config.mode.value
            
            # 2. Create necessary directories
            directories = [
                'logs/live_trading',
                'data/snapshots/daily',
                'data/live/current_session',
                'reports/deployment',
                'backups'
            ]
            
            for directory in directories:
                Path(directory).mkdir(parents=True, exist_ok=True)
            
            # 3. Setup logging for deployment
            self._setup_deployment_logging()
            
            # 4. Load and validate configuration
            if SYSTEM_INTEGRATION:
                self._load_trading_configuration()
            
            logger.info("✅ Environnement configuré avec succès")
            return True
            
        except Exception as e:
            logger.error(f"❌ Erreur configuration environnement: {e}")
            return False
    
    def _setup_deployment_logging(self):
        """Configure logging spécifique au déploiement"""
        log_file = Path(f"logs/live_trading/deployment_{self.deployment_id}.log")
        
        # Add deployment-specific handler
        handler = logging.FileHandler(log_file)
        handler.setFormatter(logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        ))
        
        # Add to all loggers
        logging.getLogger().addHandler(handler)
        
        logger.info(f"📋 Deployment logging configuré: {log_file}")
    
    def _load_trading_configuration(self):
        """Charge et valide la configuration trading"""
        try:
            trading_config = get_trading_config()
            
            # Validate configuration for live trading
            if self.config.enable_live_execution:
                # Additional validation for live trading
                if not hasattr(trading_config, 'max_position_size'):
                    raise ValueError("max_position_size not configured")
                
                if trading_config.max_position_size > self.config.max_position_size:
                    logger.warning(f"Adjusting position size: {trading_config.max_position_size} → {self.config.max_position_size}")
            
            logger.info("✅ Configuration trading validée")
            
        except Exception as e:
            logger.error(f"❌ Erreur configuration trading: {e}")
            raise
    
    # === BACKUP ===
    
    def _create_deployment_backup(self) -> bool:
        """Crée backup avant déploiement"""
        logger.info("💾 Création backup pré-déploiement...")
        
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            self.backup_path = Path(f"backups/pre_deployment_{timestamp}")
            self.backup_path.mkdir(parents=True, exist_ok=True)
            
            # Backup critical files
            files_to_backup = [
                'config/',
                'logs/system/',
                'data/snapshots/',
                '.env*'
            ]
            
            for item in files_to_backup:
                source_path = Path(item)
                if source_path.exists():
                    if source_path.is_dir():
                        shutil.copytree(source_path, self.backup_path / source_path.name, dirs_exist_ok=True)
                    else:
                        shutil.copy2(source_path, self.backup_path)
            
            # Store current system state
            self.pre_deployment_state = {
                'timestamp': datetime.now(timezone.utc).isoformat(),
                'deployment_id': self.deployment_id,
                'system_health': self._get_current_health_score(),
                'running_processes': len(list(psutil.process_iter())),
                'memory_usage': psutil.virtual_memory().percent,
                'cpu_usage': psutil.cpu_percent(interval=1)
            }
            
            # Save state to backup
            state_file = self.backup_path / 'pre_deployment_state.json'
            with open(state_file, 'w') as f:
                json.dump(self.pre_deployment_state, f, indent=2)
            
            logger.info(f"✅ Backup créé: {self.backup_path}")
            return True
            
        except Exception as e:
            logger.error(f"❌ Erreur création backup: {e}")
            return False
    
    # === COMPONENTS DEPLOYMENT ===
    
    def _deploy_system_components(self) -> bool:
        """Déploie les composants système dans l'ordre"""
        logger.info("🔧 Déploiement composants système...")
        
        # Ordre critique de déploiement
        components = [
            ("health_checker", self._deploy_health_checker),
            ("signal_generator", self._deploy_signal_generator),
            ("monitoring_system", self._deploy_monitoring_system),
            ("simple_trader", self._deploy_simple_trader)
        ]
        
        for component_name, deploy_func in components:
            logger.info(f"🔧 Déploiement {component_name}...")
            
            try:
                success = deploy_func()
                if success:
                    self.deployed_components.append(component_name)
                    logger.info(f"✅ {component_name} déployé")
                else:
                    self.failed_components.append(component_name)
                    logger.error(f"❌ Échec déploiement {component_name}")
                    return False
                    
            except Exception as e:
                logger.error(f"❌ Erreur déploiement {component_name}: {e}")
                self.failed_components.append(component_name)
                return False
        
        logger.info(f"✅ Tous les composants déployés: {len(self.deployed_components)}")
        return True
    
    def _deploy_health_checker(self) -> bool:
        """Déploie Health Checker (priorité absolue)"""
        try:
            if not SYSTEM_INTEGRATION:
                logger.warning("Health Checker non disponible - mode standalone")
                return True
            
            self.health_checker = create_health_checker({
                'auto_recovery_enabled': True,
                'dashboard_enabled': True,
                'dashboard_port': 8080,
                'emergency_alert_threshold': 2
            })
            
            # Démarrage Health Checker
            self.health_checker.start()
            
            # Wait for startup
            time.sleep(5)
            
            # Verify health checker is running
            if self.health_checker.is_running:
                logger.info("✅ Health Checker opérationnel")
                return True
            else:
                logger.error("❌ Health Checker non démarré")
                return False
                
        except Exception as e:
            logger.error(f"❌ Erreur Health Checker: {e}")
            return False
    
    def _deploy_signal_generator(self) -> bool:
        """Déploie Signal Generator (cerveau central)"""
        try:
            if not SYSTEM_INTEGRATION:
                logger.warning("Signal Generator non disponible - mode standalone")
                return True
            
            self.signal_generator = create_signal_generator()
            
            # Test signal generation
            test_data = MarketData(
                timestamp=pd.Timestamp.now(),
                symbol="ES",
                close=4500.0,
                open=4500.0,
                high=4502.0,
                low=4498.0,
                volume=1000
            )
            
            signal = get_signal_now(test_data)
            if signal is not None:
                logger.info("✅ Signal Generator opérationnel")
                return True
            else:
                logger.warning("⚠️ Signal Generator retourne None - config possible")
                return True  # Not critical for deployment
                
        except Exception as e:
            logger.error(f"❌ Erreur Signal Generator: {e}")
            return False
    
    def _deploy_monitoring_system(self) -> bool:
        """Déploie système monitoring complet"""
        try:
            if not SYSTEM_INTEGRATION:
                logger.warning("Monitoring system non disponible - mode standalone")
                return True
            
            self.monitoring_system = start_production_monitoring({
                'auto_start_health_monitoring': False,  # Déjà démarré
                'dashboard_enabled': True,
                'dashboard_port': 8081  # Port différent du Health Checker
            })
            
            if self.monitoring_system:
                logger.info("✅ Monitoring system opérationnel")
                return True
            else:
                logger.warning("⚠️ Monitoring system partiellement disponible")
                return True  # Not critical
                
        except Exception as e:
            logger.error(f"❌ Erreur monitoring system: {e}")
            return False
    
    def _deploy_simple_trader(self) -> bool:
        """Déploie Simple Trader (automation core)"""
        try:
            # Note: En production, ici on démarrerait vraiment SimpleBattleNavaleTrader
            # Pour l'instant, simulation du déploiement
            
            if self.config.mode == DeploymentMode.VALIDATION:
                logger.info("✅ Simple Trader validé (mode validation)")
                return True
            
            # Simulation déploiement
            logger.info("🔧 Déploiement Simple Trader...")
            time.sleep(2)  # Simulation startup time
            
            # En production:
            # from execution.simple_trader import SimpleBattleNavaleTrader
            # self.simple_trader = SimpleBattleNavaleTrader(mode="LIVE" if self.config.enable_live_execution else "PAPER")
            # self.simple_trader.start()
            
            logger.info("✅ Simple Trader déployé (simulé)")
            return True
            
        except Exception as e:
            logger.error(f"❌ Erreur Simple Trader: {e}")
            return False
    
    # === HEALTH VERIFICATION ===
    
    def _verify_system_health(self) -> bool:
        """Vérifie la santé complète du système après déploiement"""
        logger.info("🏥 Vérification santé système...")
        
        health_checks = [
            ("system_resources", self._health_check_system_resources),
            ("components_status", self._health_check_components_status),
            ("signal_generation", self._health_check_signal_generation),
            ("data_flow", self._health_check_data_flow),
            ("monitoring", self._health_check_monitoring)
        ]
        
        all_healthy = True
        
        for check_name, check_func in health_checks:
            health_result = self._execute_check(check_name, check_func)
            self.health_checks.append(health_result)
            
            if health_result.status == DeploymentStatus.FAILED:
                if health_result.severity in [CheckSeverity.ERROR, CheckSeverity.CRITICAL]:
                    all_healthy = False
                    logger.error(f"❌ Health check failed: {check_name}")
        
        # Integration avec Health Checker si disponible
        if self.health_checker:
            try:
                health_status = self.health_checker.get_health_status()
                overall_health = health_status['overall_health']
                
                logger.info(f"🏥 Health Checker score: {overall_health:.1f}%")
                
                if overall_health < 70:
                    logger.error(f"❌ Health score trop bas: {overall_health:.1f}%")
                    all_healthy = False
                elif overall_health < 85:
                    logger.warning(f"⚠️ Health score modéré: {overall_health:.1f}%")
                else:
                    logger.info(f"✅ Health score excellent: {overall_health:.1f}%")
                
            except Exception as e:
                logger.error(f"❌ Erreur Health Checker verification: {e}")
                all_healthy = False
        
        logger.info(f"🏥 Health verification: {'✅ PASSED' if all_healthy else '❌ FAILED'}")
        return all_healthy
    
    def _health_check_system_resources(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """Health check ressources système"""
        details = {}
        
        # CPU usage
        cpu_percent = psutil.cpu_percent(interval=1)
        memory = psutil.virtual_memory()
        
        details.update({
            'cpu_percent': cpu_percent,
            'memory_percent': memory.percent,
            'memory_available_gb': round(memory.available / (1024**3), 2)
        })
        
        if cpu_percent > 90:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   f"CPU usage critical: {cpu_percent}%", details)
        
        if memory.percent > 90:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   f"Memory usage critical: {memory.percent}%", details)
        
        if cpu_percent > 70 or memory.percent > 70:
            return (DeploymentStatus.SUCCESS, CheckSeverity.WARNING,
                   f"Resources moderate: CPU {cpu_percent}%, Memory {memory.percent}%", details)
        
        return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
               f"Resources optimal: CPU {cpu_percent}%, Memory {memory.percent}%", details)
    
    def _health_check_components_status(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """Health check status des composants"""
        details = {
            'deployed_components': self.deployed_components,
            'failed_components': self.failed_components
        }
        
        if self.failed_components:
            return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                   f"Failed components: {', '.join(self.failed_components)}", details)
        
        if len(self.deployed_components) < 2:
            return (DeploymentStatus.FAILED, CheckSeverity.ERROR,
                   f"Insufficient components deployed: {len(self.deployed_components)}", details)
        
        return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
               f"All {len(self.deployed_components)} components healthy", details)
    
    def _health_check_signal_generation(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """Health check génération de signaux"""
        details = {}
        
        if not SYSTEM_INTEGRATION:
            details['integration'] = 'limited'
            return (DeploymentStatus.SUCCESS, CheckSeverity.WARNING,
                   "Signal generation not tested (limited integration)", details)
        
        try:
            # Test signal generation avec données simulées
            test_data = MarketData(
                timestamp=pd.Timestamp.now(),
                symbol="ES",
                close=4500.0 + np.random.normal(0, 2),
                open=4499.0,
                high=4503.0,
                low=4497.0,
                volume=1500
            )
            
            start_time = time.perf_counter()
            signal = get_signal_now(test_data)
            generation_time_ms = (time.perf_counter() - start_time) * 1000
            
            details.update({
                'signal_generated': signal is not None,
                'generation_time_ms': round(generation_time_ms, 2),
                'signal_type': signal.signal_type.value if signal else None
            })
            
            if generation_time_ms > 100:  # >100ms est lent
                return (DeploymentStatus.SUCCESS, CheckSeverity.WARNING,
                       f"Signal generation slow: {generation_time_ms:.1f}ms", details)
            
            if signal is None:
                return (DeploymentStatus.SUCCESS, CheckSeverity.WARNING,
                       "Signal generation returns None (expected with random data)", details)
            
            return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
                   f"Signal generation OK: {generation_time_ms:.1f}ms", details)
            
        except Exception as e:
            details['error'] = str(e)
            return (DeploymentStatus.FAILED, CheckSeverity.ERROR,
                   f"Signal generation failed: {e}", details)
    
    def _health_check_data_flow(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """Health check flux de données"""
        details = {}
        
        # Check data directories accessibility
        data_dirs = ['data', 'logs', 'data/snapshots']
        accessible_dirs = []
        
        for dir_path in data_dirs:
            path = Path(dir_path)
            if path.exists() and path.is_dir():
                try:
                    # Test write access
                    test_file = path / 'health_check_test.tmp'
                    test_file.write_text('test')
                    test_file.unlink()
                    accessible_dirs.append(dir_path)
                except:
                    pass
        
        details.update({
            'data_directories_accessible': accessible_dirs,
            'total_directories': len(data_dirs)
        })
        
        if len(accessible_dirs) < len(data_dirs):
            return (DeploymentStatus.FAILED, CheckSeverity.ERROR,
                   f"Data directories not accessible: {len(accessible_dirs)}/{len(data_dirs)}", details)
        
        return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
               "Data flow paths verified", details)
    
    def _health_check_monitoring(self) -> Tuple[DeploymentStatus, CheckSeverity, str, Dict]:
        """Health check système monitoring"""
        details = {}
        
        if self.health_checker:
            try:
                health_status = self.health_checker.get_health_status()
                details['health_checker_available'] = True
                details['overall_health'] = health_status['overall_health']
                details['components_total'] = health_status['components_total']
                
                if health_status['overall_health'] < 70:
                    return (DeploymentStatus.FAILED, CheckSeverity.CRITICAL,
                           f"Health Checker reports low health: {health_status['overall_health']:.1f}%", details)
                
                return (DeploymentStatus.SUCCESS, CheckSeverity.INFO,
                       f"Monitoring operational: {health_status['overall_health']:.1f}% health", details)
                
            except Exception as e:
                details['health_checker_error'] = str(e)
                return (DeploymentStatus.FAILED, CheckSeverity.ERROR,
                       f"Health Checker error: {e}", details)
        else:
            details['health_checker_available'] = False
            return (DeploymentStatus.SUCCESS, CheckSeverity.WARNING,
                   "Health Checker not available", details)
    
    # === GO-LIVE DECISION ===
    
    def _make_go_live_decision(self) -> bool:
        """Prend la décision de go-live"""
        logger.info("🎯 Prise de décision go-live...")
        
        # Analyse des résultats de checks
        critical_failures = len([c for c in self.health_checks 
                               if c.status == DeploymentStatus.FAILED and 
                               c.severity == CheckSeverity.CRITICAL])
        
        total_health_checks = len(self.health_checks)
        success_rate = len([c for c in self.health_checks 
                           if c.status == DeploymentStatus.SUCCESS]) / total_health_checks if total_health_checks > 0 else 0
        
        logger.info(f"📊 Health checks success rate: {success_rate:.1%}")
        logger.info(f"🚨 Critical failures: {critical_failures}")
        
        # Critères de décision
        go_live_criteria = {
            'no_critical_failures': critical_failures == 0,
            'success_rate_sufficient': success_rate >= 0.8,
            'all_components_deployed': len(self.failed_components) == 0,
            'health_score_acceptable': self._get_current_health_score() >= 70
        }
        
        logger.info("📋 Go-live criteria:")
        for criterion, met in go_live_criteria.items():
            status = "✅" if met else "❌"
            logger.info(f"   {status} {criterion}: {met}")
        
        # Décision
        all_criteria_met = all(go_live_criteria.values())
        
        if all_criteria_met:
            logger.info("✅ GO-LIVE APPROUVÉ - Tous les critères satisfaits")
            
            # Manual approval si requis
            if self.config.require_manual_approval and self.config.mode != DeploymentMode.VALIDATION:
                approval = self._request_manual_approval()
                if not approval:
                    logger.warning("❌ GO-LIVE REFUSÉ - Approbation manuelle refusée")
                    return False
            
            return True
        else:
            failed_criteria = [k for k, v in go_live_criteria.items() if not v]
            logger.error(f"❌ GO-LIVE REFUSÉ - Critères échoués: {', '.join(failed_criteria)}")
            return False
    
    def _request_manual_approval(self) -> bool:
        """Demande approbation manuelle"""
        if self.config.mode == DeploymentMode.VALIDATION:
            return True
        
        logger.info("⏳ Approbation manuelle requise pour go-live...")
        
        try:
            # En production, ici on pourrait envoyer notification Discord
            # et attendre approbation, ou utiliser une interface web
            
            print("\n" + "="*60)
            print("🚨 MANUAL APPROVAL REQUIRED FOR LIVE TRADING")
            print("="*60)
            print(f"Deployment ID: {self.deployment_id}")
            print(f"Mode: {self.config.mode.value}")
            print(f"Max Position Size: {self.config.max_position_size}")
            print(f"Daily Loss Limit: ${self.config.daily_loss_limit}")
            print(f"Live Execution: {self.config.enable_live_execution}")
            print("="*60)
            
            if self.config.enable_live_execution:
                print("⚠️  WARNING: LIVE TRADING WITH REAL MONEY")
                print("⚠️  VERIFY ALL SETTINGS BEFORE APPROVAL")
                print("="*60)
            
            response = input("Approve deployment? (YES/no): ").strip()
            
            if response.upper() == "YES":
                logger.info("✅ Approbation manuelle accordée")
                return True
            else:
                logger.warning("❌ Approbation manuelle refusée")
                return False
                
        except Exception as e:
            logger.error(f"❌ Erreur approbation manuelle: {e}")
            return False
    
    # === MONITORING ===
    
    def _start_deployment_monitoring(self):
        """Démarre monitoring post-déploiement"""
        logger.info("📊 Démarrage monitoring post-déploiement...")
        
        self.monitoring_thread = threading.Thread(
            target=self._deployment_monitoring_loop,
            daemon=True
        )
        self.monitoring_thread.start()
        
        logger.info("✅ Monitoring post-déploiement démarré")
    
    def _deployment_monitoring_loop(self):
        """Loop monitoring post-déploiement"""
        logger.info("🔄 Loop monitoring post-déploiement actif")
        
        monitoring_start = time.time()
        max_monitoring_time = self.config.max_deployment_time_minutes * 60
        
        while self.is_running and (time.time() - monitoring_start) < max_monitoring_time:
            try:
                # Health check périodique
                current_health = self._get_current_health_score()
                
                if current_health < 50:
                    logger.error(f"🚨 Health critique détectée: {current_health:.1f}%")
                    self._trigger_emergency_rollback("Critical health degradation")
                    break
                
                # Check composants
                if self.health_checker and not self.health_checker.is_running:
                    logger.error("🚨 Health Checker arrêté")
                    self._trigger_emergency_rollback("Health Checker stopped")
                    break
                
                # Log status
                if int(time.time()) % 300 == 0:  # Tous les 5 minutes
                    logger.info(f"📊 Monitoring: Health {current_health:.1f}%, Uptime {int(time.time() - monitoring_start)}s")
                
                time.sleep(self.config.health_check_interval_seconds)
                
            except Exception as e:
                logger.error(f"❌ Erreur monitoring loop: {e}")
                time.sleep(30)
    
    # === ROLLBACK ===
    
    def _trigger_emergency_rollback(self, reason: str):
        """Déclenche rollback d'urgence"""
        logger.error(f"🚨 DÉCLENCHEMENT ROLLBACK D'URGENCE: {reason}")
        
        self.rollback_triggered = True
        self.deployment_status = DeploymentStatus.FAILED
        
        try:
            if self.config.enable_rollback:
                success = self._execute_rollback(reason)
                if success:
                    self.deployment_status = DeploymentStatus.ROLLED_BACK
                    logger.info("✅ Rollback exécuté avec succès")
                else:
                    logger.error("❌ Échec rollback - intervention manuelle requise")
            else:
                logger.warning("⚠️ Rollback désactivé - arrêt système")
                self._emergency_shutdown()
                
        except Exception as e:
            logger.error(f"❌ Erreur critique rollback: {e}")
            self._emergency_shutdown()
    
    def _execute_rollback(self, reason: str) -> bool:
        """Exécute procédure de rollback"""
        logger.info(f"🔄 Exécution rollback: {reason}")
        
        try:
            # 1. Stop tous les composants déployés
            self._stop_deployed_components()
            
            # 2. Restore backup si disponible
            if self.backup_path and self.backup_path.exists():
                self._restore_from_backup()
            
            # 3. Cleanup
            self._cleanup_deployment()
            
            logger.info("✅ Rollback terminé")
            return True
            
        except Exception as e:
            logger.error(f"❌ Erreur rollback: {e}")
            return False
    
    def _stop_deployed_components(self):
        """Arrête tous les composants déployés"""
        logger.info("🛑 Arrêt composants déployés...")
        
        # Arrêt dans l'ordre inverse du déploiement
        if self.simple_trader:
            try:
                # self.simple_trader.stop()
                logger.info("✅ Simple Trader arrêté")
            except Exception as e:
                logger.error(f"❌ Erreur arrêt Simple Trader: {e}")
        
        if self.health_checker:
            try:
                self.health_checker.stop()
                logger.info("✅ Health Checker arrêté")
            except Exception as e:
                logger.error(f"❌ Erreur arrêt Health Checker: {e}")
        
        logger.info("✅ Composants arrêtés")
    
    def _restore_from_backup(self):
        """Restore depuis backup"""
        logger.info(f"📦 Restoration depuis backup: {self.backup_path}")
        
        try:
            # Restore critical directories
            backup_dirs = ['config', 'logs/system']
            
            for dir_name in backup_dirs:
                backup_dir = self.backup_path / dir_name
                target_dir = Path(dir_name)
                
                if backup_dir.exists():
                    if target_dir.exists():
                        shutil.rmtree(target_dir)
                    shutil.copytree(backup_dir, target_dir)
                    logger.info(f"✅ Restored {dir_name}")
            
            logger.info("✅ Backup restoration terminée")
            
        except Exception as e:
            logger.error(f"❌ Erreur restoration backup: {e}")
    
    def _cleanup_deployment(self):
        """Nettoie artifacts de déploiement"""
        logger.info("🧹 Cleanup deployment...")
        
        try:
            # Remove temporary files
            temp_files = Path('.').glob('*.tmp')
            for temp_file in temp_files:
                temp_file.unlink()
            
            # Reset environment variables
            env_vars = ['MIA_DEPLOYMENT_ID', 'MIA_DEPLOYMENT_MODE']
            for var in env_vars:
                os.environ.pop(var, None)
            
            logger.info("✅ Cleanup terminé")
            
        except Exception as e:
            logger.error(f"❌ Erreur cleanup: {e}")
    
    def _emergency_shutdown(self):
        """Arrêt d'urgence complet"""
        logger.error("🚨 ARRÊT D'URGENCE SYSTÈME")
        
        try:
            self._stop_deployed_components()
            self.is_running = False
            
            # Kill all related processes if necessary
            # En production, ici on pourrait forcer l'arrêt de processus
            
            logger.error("🛑 Arrêt d'urgence terminé")
            
        except Exception as e:
            logger.error(f"❌ Erreur arrêt d'urgence: {e}")
    
    # === FAILURE HANDLING ===
    
    def _handle_deployment_failure(self, reason: str) -> DeploymentReport:
        """Gère échec de déploiement"""
        logger.error(f"❌ ÉCHEC DÉPLOIEMENT: {reason}")
        
        self.deployment_status = DeploymentStatus.FAILED
        self._update_stage(DeploymentStage.FAILED)
        
        # Rollback automatique si activé
        if self.config.enable_rollback and not self.rollback_triggered:
            self._trigger_emergency_rollback(f"Deployment failure: {reason}")
        
        return self._generate_deployment_report()
    
    # === UTILITIES ===
    
    def _update_stage(self, stage: DeploymentStage):
        """Met à jour l'étape actuelle"""
        self.current_stage = stage
        logger.info(f"📍 Stage: {stage.value.upper()}")
    
    def _get_current_health_score(self) -> float:
        """Obtient score de santé actuel"""
        try:
            if self.health_checker:
                health_status = self.health_checker.get_health_status()
                return health_status['overall_health']
            else:
                # Fallback: calcul simplifié
                return 80.0  # Assume reasonable health
                
        except Exception as e:
            logger.error(f"❌ Erreur health score: {e}")
            return 50.0  # Conservative fallback
    
    def _generate_deployment_report(self) -> DeploymentReport:
        """Génère rapport de déploiement complet"""
        end_time = datetime.now(timezone.utc)
        total_time = (end_time - self.start_time).total_seconds()
        
        report = DeploymentReport(
            deployment_id=self.deployment_id,
            start_time=self.start_time,
            end_time=end_time,
            config=self.config,
            target_environment=self.config.target_environment,
            current_stage=self.current_stage,
            overall_status=self.deployment_status,
            pre_checks=self.pre_checks,
            health_checks=self.health_checks,
            post_checks=self.post_checks,
            total_execution_time_seconds=total_time,
            components_deployed=self.deployed_components,
            components_failed=self.failed_components,
            rollback_triggered=self.rollback_triggered,
            health_score_pre_deployment=self.pre_deployment_state.get('system_health', 0),
            health_score_post_deployment=self._get_current_health_score()
        )
        
        # Sauvegarde rapport
        self._save_deployment_report(report)
        
        return report
    
    def _save_deployment_report(self, report: DeploymentReport):
        """Sauvegarde rapport de déploiement"""
        try:
            reports_dir = Path("reports/deployment")
            reports_dir.mkdir(parents=True, exist_ok=True)
            
            report_file = reports_dir / f"deployment_report_{self.deployment_id}.json"
            
            # Convert to dict for JSON serialization
            report_dict = asdict(report)
            
            # Convert datetime objects to ISO strings
            for key, value in report_dict.items():
                if isinstance(value, datetime):
                    report_dict[key] = value.isoformat()
            
            # Convert nested datetime objects
            for check_list_name in ['pre_checks', 'health_checks', 'post_checks']:
                for check in report_dict.get(check_list_name, []):
                    if 'timestamp' in check and isinstance(check['timestamp'], datetime):
                        check['timestamp'] = check['timestamp'].isoformat()
            
            with open(report_file, 'w') as f:
                json.dump(report_dict, f, indent=2, default=str)
            
            logger.info(f"📋 Rapport sauvegardé: {report_file}")
            
        except Exception as e:
            logger.error(f"❌ Erreur sauvegarde rapport: {e}")

# === FACTORY FUNCTIONS ===

def create_deployment_config(mode: str, **kwargs) -> DeploymentConfig:
    """Factory pour configuration déploiement"""
    mode_enum = DeploymentMode(mode)
    return DeploymentConfig(mode=mode_enum, **kwargs)

def deploy_validation_only() -> DeploymentReport:
    """Déploiement validation seulement"""
    config = create_deployment_config(
        mode="validation",
        enable_live_execution=False,
        require_manual_approval=False
    )
    
    deployer = LiveDeployer(config)
    return deployer.deploy()

def deploy_paper_to_live(max_position_size: int = 1, daily_loss_limit: float = 500.0) -> DeploymentReport:
    """Déploiement transition paper → live"""
    config = create_deployment_config(
        mode="paper_to_live",
        max_position_size=max_position_size,
        daily_loss_limit=daily_loss_limit,
        enable_live_execution=True,
        require_manual_approval=True,
        paper_trading_first=True
    )
    
    deployer = LiveDeployer(config)
    return deployer.deploy()

def deploy_cold_start() -> DeploymentReport:
    """Déploiement à froid complet"""
    config = create_deployment_config(
        mode="cold_start",
        backup_before_deployment=True,
        enable_circuit_breakers=True
    )
    
    deployer = LiveDeployer(config)
    return deployer.deploy()

def emergency_stop_all() -> bool:
    """Arrêt d'urgence tous systèmes"""
    logger.error("🚨 EMERGENCY STOP TRIGGERED")
    
    try:
        # Kill processus MIA_IA_SYSTEM
        current_pid = os.getpid()
        
        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                if proc.info['cmdline']:
                    cmdline = ' '.join(proc.info['cmdline'])
                    if any(keyword in cmdline.lower() for keyword in ['automation_main', 'simple_trader', 'mia_ia']):
                        if proc.info['pid'] != current_pid:
                            logger.warning(f"🔪 Killing process {proc.info['pid']}: {cmdline[:50]}")
                            proc.terminate()
                            
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                pass
        
        # Health check d'urgence
        if SYSTEM_INTEGRATION:
            emergency_health_check()
        
        logger.info("✅ Emergency stop completed")
        return True
        
    except Exception as e:
        logger.error(f"❌ Emergency stop error: {e}")
        return False

# === INTERFACE LIGNE DE COMMANDE ===

def main():
    """Interface ligne de commande"""
    parser = argparse.ArgumentParser(
        description="🚀 MIA_IA_SYSTEM Live Deployment",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Exemples d'utilisation:

  # Validation complète sans déploiement
  python scripts/deploy_live.py --mode validation

  # Déploiement paper trading → live trading
  python scripts/deploy_live.py --mode paper_to_live --position-size 1 --daily-limit 500

  # Déploiement à froid complet
  python scripts/deploy_live.py --mode cold_start --live --backup

  # Arrêt d'urgence tous systèmes
  python scripts/deploy_live.py --emergency-stop

  # Status health check rapide
  python scripts/deploy_live.py --health-check
        """
    )
    
    # Mode de déploiement
    parser.add_argument('--mode', choices=['validation', 'paper_to_live', 'cold_start', 'hot_upgrade'],
                       default='validation', help='Mode de déploiement')
    
    # Configuration
    parser.add_argument('--live', action='store_true', help='Enable live execution (REAL MONEY)')
    parser.add_argument('--position-size', type=int, default=1, help='Max position size')
    parser.add_argument('--daily-limit', type=float, default=500.0, help='Daily loss limit ($)')
    parser.add_argument('--no-approval', action='store_true', help='Skip manual approval')
    parser.add_argument('--no-backup', action='store_true', help='Skip backup creation')
    parser.add_argument('--no-rollback', action='store_true', help='Disable automatic rollback')
    
    # Actions spéciales
    parser.add_argument('--emergency-stop', action='store_true', help='Emergency stop all systems')
    parser.add_argument('--health-check', action='store_true', help='Run health check only')
    parser.add_argument('--report', help='Show deployment report (ID)')
    
    # Options avancées
    parser.add_argument('--timeout', type=int, default=30, help='Deployment timeout (minutes)')
    parser.add_argument('--config-file', help='Custom configuration file')
    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose logging')
    
    args = parser.parse_args()
    
    # Configure logging
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    try:
        print("🚀 MIA_IA_SYSTEM LIVE DEPLOYMENT SYSTEM")
        print("=" * 60)
        
        # Actions spéciales
        if args.emergency_stop:
            print("🚨 EMERGENCY STOP REQUESTED")
            success = emergency_stop_all()
            return 0 if success else 1
        
        if args.health_check:
            print("🏥 HEALTH CHECK RAPIDE")
            if SYSTEM_INTEGRATION:
                is_safe = emergency_health_check()
                return 0 if is_safe else 1
            else:
                print("⚠️ Health check non disponible (intégration limitée)")
                return 1
        
        if args.report:
            print(f"📋 DEPLOYMENT REPORT: {args.report}")
            report_file = Path(f"reports/deployment/deployment_report_{args.report}.json")
            if report_file.exists():
                with open(report_file) as f:
                    report_data = json.load(f)
                print(json.dumps(report_data, indent=2))
                return 0
            else:
                print(f"❌ Report not found: {report_file}")
                return 1
        
        # Configuration déploiement
        config = DeploymentConfig(
            mode=DeploymentMode(args.mode),
            enable_live_execution=args.live,
            max_position_size=args.position_size,
            daily_loss_limit=args.daily_limit,
            require_manual_approval=not args.no_approval,
            backup_before_deployment=not args.no_backup,
            enable_rollback=not args.no_rollback,
            max_deployment_time_minutes=args.timeout
        )
        
        # Warnings pour live trading
        if args.live:
            print("⚠️" * 20)
            print("🚨 LIVE TRADING MODE - REAL MONEY AT RISK")
            print("⚠️" * 20)
            print(f"Max Position Size: {args.position_size}")
            print(f"Daily Loss Limit: ${args.daily_limit}")
            print("⚠️" * 20)
            
            if not args.no_approval:
                confirmation = input("Type 'I UNDERSTAND THE RISKS' to continue: ")
                if confirmation != "I UNDERSTAND THE RISKS":
                    print("❌ Deployment cancelled")
                    return 1
        
        # Exécution déploiement
        print(f"🚀 Starting deployment: {args.mode}")
        print(f"Target: {'LIVE TRADING' if args.live else 'PAPER TRADING'}")
        print("=" * 60)
        
        deployer = LiveDeployer(config)
        report = deployer.deploy()
        
        # Affichage résultats
        print("\n" + "=" * 60)
        print("📊 DEPLOYMENT RESULTS")
        print("=" * 60)
        print(f"Status: {report.overall_status.value.upper()}")
        print(f"Duration: {report.total_execution_time_seconds:.1f}s")
        print(f"Components Deployed: {len(report.components_deployed)}")
        print(f"Components Failed: {len(report.components_failed)}")
        print(f"Health Score: {report.health_score_post_deployment:.1f}%")
        print(f"Rollback Triggered: {report.rollback_triggered}")
        
        if report.components_deployed:
            print(f"✅ Deployed: {', '.join(report.components_deployed)}")
        
        if report.components_failed:
            print(f"❌ Failed: {', '.join(report.components_failed)}")
        
        # Checks summary
        total_checks = len(report.pre_checks) + len(report.health_checks)
        passed_checks = len([c for c in report.pre_checks + report.health_checks 
                           if c.status == DeploymentStatus.SUCCESS])
        
        print(f"📋 Checks: {passed_checks}/{total_checks} passed")
        
        if report.overall_status == DeploymentStatus.SUCCESS:
            print("\n🎉 DEPLOYMENT SUCCESSFUL!")
            if SYSTEM_INTEGRATION and not args.live:
                print("🌐 Health Dashboard: http://127.0.0.1:8080")
            
            return 0
        else:
            print(f"\n❌ DEPLOYMENT FAILED: {report.overall_status.value}")
            return 1
        
    except KeyboardInterrupt:
        print("\n🛑 Deployment cancelled by user")
        return 1
    except Exception as e:
        print(f"\n❌ Deployment error: {e}")
        logger.exception("Deployment exception:")
        return 1

if __name__ == "__main__":
    sys.exit(main())