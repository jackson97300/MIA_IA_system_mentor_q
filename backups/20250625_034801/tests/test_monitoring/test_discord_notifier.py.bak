#!/usr/bin/env python3
"""
Tests pour Discord Notifier
Location: D:\MIA_IA_system\tests\test_monitoring\test_discord_notifier.py

Tests incluent:
- Tests unitaires avec mocks
- Tests d'int√©gration avec vrais webhooks
- Test interactif pour v√©rification visuelle
"""

import asyncio
import unittest
from unittest.mock import Mock, patch, AsyncMock
import json
import os
from datetime import datetime
import logging

# Ajout du path pour imports
import sys
sys.path.append(r'D:\MIA_IA_system')

from monitoring.discord_notifier import (
    DiscordNotifier, 
    NotificationChannel,
    AlertPriority,
    DiscordEmbed,
    create_discord_notifier
)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# === TESTS UNITAIRES ===

class TestDiscordNotifier(unittest.TestCase):
    """Tests unitaires avec mocks"""
    
    def setUp(self):
        """Setup pour chaque test"""
        self.test_config = {
            'bot_name': 'MIA Test Bot',
            'webhook_signals': 'https://discord.com/api/webhooks/test/signals',
            'webhook_trades': 'https://discord.com/api/webhooks/test/trades',
            'webhook_alerts': 'https://discord.com/api/webhooks/test/alerts',
            'webhook_performance': 'https://discord.com/api/webhooks/test/performance',
            'enabled': True
        }
        self.notifier = DiscordNotifier(self.test_config)
    
    def test_initialization(self):
        """Test initialisation correcte"""
        self.assertEqual(self.notifier.bot_name, 'MIA Test Bot')
        self.assertTrue(self.notifier.enabled)
        self.assertIsNotNone(self.notifier.webhooks)
    
    def test_embed_creation(self):
        """Test cr√©ation embed Discord"""
        embed = DiscordEmbed(
            title="Test Embed",
            description="Test description",
            color=0xff0000
        )
        
        embed_dict = embed.to_dict()
        self.assertEqual(embed_dict['title'], "Test Embed")
        self.assertEqual(embed_dict['color'], 0xff0000)
    
    @patch('aiohttp.ClientSession.post')
    async def test_send_signal_detected(self, mock_post):
        """Test envoi signal avec mock"""
        # Mock response
        mock_response = AsyncMock()
        mock_response.status = 204
        mock_post.return_value.__aenter__.return_value = mock_response
        
        # Test data
        signal_data = {
            'direction': 'LONG',
            'price': 4563.50,
            'vikings_strength': 0.82,
            'defenders_strength': 0.18,
            'base_quality': 0.75,
            'base_bars': 12,
            'confluence_score': 0.88,
            'confluence_factors': ['POC', 'Base', 'Momentum'],
            'entry': 4563.50,
            'stop': 4561.00,
            'target': 4568.50,
            'risk_ticks': 10,
            'reward_ticks': 20,
            'risk_reward': 2.0,
            'golden_rule_ok': True
        }
        
        # Envoi
        result = await self.notifier.send_signal_detected(signal_data)
        
        # V√©rifications
        self.assertTrue(result)
        mock_post.assert_called_once()
        
        # V√©rifier le payload
        call_args = mock_post.call_args
        self.assertIn('json', call_args.kwargs)
        payload = call_args.kwargs['json']
        self.assertIn('embeds', payload)
        self.assertEqual(len(payload['embeds']), 1)
    
    @patch('aiohttp.ClientSession.post')
    async def test_send_trade_executed(self, mock_post):
        """Test envoi trade ex√©cut√©"""
        mock_response = AsyncMock()
        mock_response.status = 204
        mock_post.return_value.__aenter__.return_value = mock_response
        
        trade_data = {
            'side': 'LONG',
            'quantity': 2,
            'intended_price': 4563.50,
            'fill_price': 4563.75,
            'slippage_ticks': 1,
            'position_size': 2,
            'avg_price': 4563.75,
            'risk_dollars': 250
        }
        
        result = await self.notifier.send_trade_executed(trade_data)
        self.assertTrue(result)
    
    def test_disabled_notifier(self):
        """Test notifier d√©sactiv√©"""
        self.notifier.enabled = False
        
        async def test_disabled():
            result = await self.notifier.send_signal_detected({})
            self.assertFalse(result)
        
        asyncio.run(test_disabled())
    
    def tearDown(self):
        """Cleanup apr√®s chaque test"""
        if self.notifier._session:
            asyncio.run(self.notifier.close())

# === TEST INT√âGRATION R√âEL ===

class TestDiscordIntegration:
    """Test avec vrais webhooks Discord"""
    
    def __init__(self):
        # Charger config depuis environnement
        self.config = {
            'bot_name': 'MIA Test Integration',
            'webhook_signals': os.getenv('DISCORD_WEBHOOK_SIGNALS'),
            'webhook_trades': os.getenv('DISCORD_WEBHOOK_TRADES'),
            'webhook_alerts': os.getenv('DISCORD_WEBHOOK_ALERTS'),
            'webhook_performance': os.getenv('DISCORD_WEBHOOK_PERFORMANCE'),
            'enabled': True
        }
        
        # V√©rifier si au moins un webhook est configur√©
        self.has_webhooks = any(
            self.config[key] for key in self.config 
            if key.startswith('webhook_') and self.config[key]
        )
    
    async def test_all_notifications(self):
        """Test toutes les notifications"""
        if not self.has_webhooks:
            logger.warning("‚ùå Pas de webhooks configur√©s - Skipping integration tests")
            logger.info("üí° Configurez les variables d'environnement DISCORD_WEBHOOK_* pour tester")
            return
        
        logger.info("üöÄ D√©but tests int√©gration Discord avec vrais webhooks")
        
        notifier = create_discord_notifier(self.config)
        
        # 1. Signal d√©tect√©
        logger.info("üìç Test 1: Signal d√©tect√©")
        await notifier.send_signal_detected({
            'direction': 'LONG',
            'price': 4563.50,
            'vikings_strength': 0.82,
            'defenders_strength': 0.18,
            'base_quality': 0.75,
            'base_bars': 12,
            'confluence_score': 0.88,
            'confluence_factors': ['POC', 'Base', 'Momentum'],
            'entry': 4563.50,
            'stop': 4561.00,
            'target': 4568.50,
            'risk_ticks': 10,
            'reward_ticks': 20,
            'risk_reward': 2.0,
            'golden_rule_ok': True,
            'market_regime': 'TREND'
        })
        await asyncio.sleep(3)  # Pause pour voir sur Discord
        
        # 2. Trade ex√©cut√©
        logger.info("üìç Test 2: Trade ex√©cut√©")
        await notifier.send_trade_executed({
            'side': 'LONG',
            'quantity': 2,
            'intended_price': 4563.50,
            'fill_price': 4563.75,
            'slippage_ticks': 1,
            'position_size': 2,
            'avg_price': 4563.75,
            'risk_dollars': 250,
            'battle_status': 'Vikings Winning'
        })
        await asyncio.sleep(3)
        
        # 3. Position update (gain)
        logger.info("üìç Test 3: Position update (profit)")
        await notifier.send_position_update({
            'pnl': 125.00,
            'pnl_ticks': 5,
            'max_pnl': 187.50,
            'min_pnl': -62.50,
            'current_stop': 4563.00,
            'stop_distance': 3,
            'stop_type': 'Trailing BE+2',
            'battle_status': 'Vikings Dominating',
            'golden_rule_ok': True,
            'time_in_position': 15
        })
        await asyncio.sleep(3)
        
        # 4. Trade ferm√© (gagnant)
        logger.info("üìç Test 4: Trade ferm√© (winner)")
        await notifier.send_trade_closed({
            'side': 'LONG',
            'exit_price': 4568.50,
            'pnl': 250.00,
            'pnl_ticks': 10,
            'roi': 0.02,
            'duration_minutes': 23,
            'max_profit_ticks': 12,
            'max_loss_ticks': -3,
            'exit_reason': 'Target Hit',
            'exit_type': 'Take Profit',
            'final_battle_analysis': 'Vikings victorious - Base held strong'
        })
        await asyncio.sleep(3)
        
        # 5. Alerte risque
        logger.info("üìç Test 5: Alerte risque")
        await notifier.send_risk_alert({
            'alert_type': 'Daily Loss Limit',
            'message': 'Approche limite quotidienne -$400/$500',
            'severity': 'high',
            'impact': 'Position sizing r√©duit',
            'action_taken': 'Max position size: 2 ‚Üí 1',
            'golden_rule_violation': False
        })
        await asyncio.sleep(3)
        
        # 6. Violation r√®gle d'or
        logger.info("üìç Test 6: Violation r√®gle d'or")
        await notifier.send_risk_alert({
            'alert_type': 'R√®gle d\'Or Violation',
            'message': 'ROUGE A FERM√â SOUS VERTE!',
            'severity': 'critical',
            'impact': 'Tendance potentiellement cass√©e',
            'action_taken': 'Surveillance accrue activ√©e',
            'golden_rule_violation': True
        })
        await asyncio.sleep(3)
        
        # 7. Rapport quotidien
        logger.info("üìç Test 7: Rapport quotidien")
        await notifier.send_daily_report({
            'date': datetime.now().strftime('%Y-%m-%d'),
            'total_pnl': 812.50,
            'total_trades': 5,
            'win_rate': 0.80,
            'profit_factor': 3.25,
            'signals_detected': 12,
            'signals_taken': 5,
            'selectivity': 0.417,
            'golden_rule_respect': 1.0,
            'best_trade': 437.50,
            'worst_trade': -125.00,
            'avg_win': 265.63,
            'avg_loss': 125.00,
            'session_performance': {
                'London Open': 0.85,
                'NY Open': 0.75,
                'Lunch': 0.45
            },
            'ml_insights': [
                'Meilleure performance pr√®s POC (3/3 wins)',
                'Base quality > 0.75 = 85% win rate',
                '√âviter trades apr√®s 15h30',
                'Vikings strength > 0.8 = forte probabilit√©'
            ]
        })
        await asyncio.sleep(3)
        
        # 8. Erreur syst√®me
        logger.info("üìç Test 8: Erreur syst√®me")
        await notifier.send_error_notification({
            'error_type': 'Connection Lost',
            'message': 'Connexion Sierra Chart perdue',
            'module': 'sierra_connector',
            'severity': 'critical',
            'stack_trace': 'ConnectionError at line 123...',
            'action_required': 'V√©rifier Sierra Chart et red√©marrer bot'
        })
        
        # Cleanup
        await notifier.close()
        
        logger.info("‚úÖ Tests int√©gration Discord termin√©s!")
        logger.info("üëÄ V√©rifiez vos canaux Discord pour voir les messages")

# === TEST INTERACTIF ===

async def interactive_test():
    """Test interactif pour envoyer des notifications personnalis√©es"""
    print("\nüéÆ TEST INTERACTIF DISCORD")
    print("=" * 50)
    
    # V√©rifier webhooks
    webhook = os.getenv('DISCORD_WEBHOOK_SIGNALS')
    if not webhook:
        print("‚ùå Pas de webhook configur√©!")
        print("üí° Configurez DISCORD_WEBHOOK_SIGNALS dans votre .env")
        return
    
    config = {
        'bot_name': 'MIA Interactive Test',
        'webhook_signals': webhook,
        'enabled': True
    }
    
    notifier = create_discord_notifier(config)
    
    while True:
        print("\nüìã MENU:")
        print("1. Envoyer signal LONG")
        print("2. Envoyer signal SHORT")
        print("3. Envoyer alerte custom")
        print("4. Test performance (10 messages rapides)")
        print("0. Quitter")
        
        choice = input("\nChoix: ").strip()
        
        if choice == '0':
            break
        
        elif choice == '1':
            await notifier.send_signal_detected({
                'direction': 'LONG',
                'price': 4565.25,
                'vikings_strength': 0.75,
                'defenders_strength': 0.25,
                'base_quality': 0.80,
                'base_bars': 15,
                'confluence_score': 0.85,
                'confluence_factors': ['VWAP', 'Base', 'Trend'],
                'entry': 4565.50,
                'stop': 4563.00,
                'target': 4570.50,
                'risk_ticks': 10,
                'reward_ticks': 20,
                'risk_reward': 2.0,
                'golden_rule_ok': True
            })
            print("‚úÖ Signal LONG envoy√©!")
        
        elif choice == '2':
            await notifier.send_signal_detected({
                'direction': 'SHORT',
                'price': 4570.75,
                'vikings_strength': 0.20,
                'defenders_strength': 0.80,
                'base_quality': 0.70,
                'base_bars': 10,
                'confluence_score': 0.75,
                'confluence_factors': ['Resistance', 'Volume'],
                'entry': 4570.50,
                'stop': 4573.00,
                'target': 4565.50,
                'risk_ticks': 10,
                'reward_ticks': 20,
                'risk_reward': 2.0,
                'golden_rule_ok': True
            })
            print("‚úÖ Signal SHORT envoy√©!")
        
        elif choice == '3':
            title = input("Titre du message: ")
            message = input("Message: ")
            await notifier.send_custom_message(
                NotificationChannel.SIGNALS,
                title,
                message,
                color=0x00ff00
            )
            print("‚úÖ Message custom envoy√©!")
        
        elif choice == '4':
            print("üöÄ Test performance - 10 messages...")
            start = datetime.now()
            for i in range(10):
                await notifier.send_custom_message(
                    NotificationChannel.SIGNALS,
                    f"Test Performance #{i+1}",
                    f"Message test {i+1}/10",
                    color=0x0099ff
                )
                await asyncio.sleep(0.5)  # Petit d√©lai
            
            duration = (datetime.now() - start).total_seconds()
            print(f"‚úÖ 10 messages envoy√©s en {duration:.2f} secondes")
    
    await notifier.close()
    print("\nüëã Test interactif termin√©!")

# === MAIN ===

def main():
    """Point d'entr√©e principal des tests"""
    print("\nüß™ TESTS DISCORD NOTIFIER")
    print("=" * 50)
    
    # Menu
    print("\nüìã OPTIONS:")
    print("1. Tests unitaires (mocks)")
    print("2. Tests int√©gration (vrais webhooks)")
    print("3. Test interactif")
    print("4. Tous les tests")
    
    choice = input("\nChoix (1-4): ").strip()
    
    if choice == '1' or choice == '4':
        print("\nüìù TESTS UNITAIRES")
        print("-" * 30)
        unittest.main(argv=[''], exit=False, verbosity=2)
    
    if choice == '2' or choice == '4':
        print("\nüåê TESTS INT√âGRATION")
        print("-" * 30)
        integration = TestDiscordIntegration()
        asyncio.run(integration.test_all_notifications())
    
    if choice == '3':
        asyncio.run(interactive_test())
    
    print("\n‚úÖ Tests termin√©s!")

if __name__ == "__main__":
    main()